module.exports = [
  "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "AbortError",
      () => AbortError,
      "AsyncIdQueue",
      () => AsyncIdQueue,
      "AsyncIteratorClass",
      () => AsyncIteratorClass,
      "EventPublisher",
      () => EventPublisher,
      "NullProtoObj",
      () => NullProtoObj,
      "ORPC_NAME",
      () => ORPC_NAME,
      "ORPC_SHARED_PACKAGE_NAME",
      () => ORPC_SHARED_PACKAGE_NAME,
      "ORPC_SHARED_PACKAGE_VERSION",
      () => ORPC_SHARED_PACKAGE_VERSION,
      "SequentialIdGenerator",
      () => SequentialIdGenerator,
      "asyncIteratorToStream",
      () => asyncIteratorToStream,
      "asyncIteratorToUnproxiedDataStream",
      () => asyncIteratorToUnproxiedDataStream,
      "asyncIteratorWithSpan",
      () => asyncIteratorWithSpan,
      "clone",
      () => clone,
      "compareSequentialIds",
      () => compareSequentialIds,
      "defer",
      () => defer,
      "fallback",
      () => fallback,
      "findDeepMatches",
      () => findDeepMatches,
      "get",
      () => get,
      "getConstructor",
      () => getConstructor,
      "getGlobalOtelConfig",
      () => getGlobalOtelConfig,
      "intercept",
      () => intercept,
      "isAsyncIteratorObject",
      () => isAsyncIteratorObject,
      "isObject",
      () => isObject,
      "isPropertyKey",
      () => isPropertyKey,
      "isTypescriptObject",
      () => isTypescriptObject,
      "onError",
      () => onError,
      "onFinish",
      () => onFinish,
      "onStart",
      () => onStart,
      "onSuccess",
      () => onSuccess,
      "once",
      () => once,
      "overlayProxy",
      () => overlayProxy,
      "parseEmptyableJSON",
      () => parseEmptyableJSON,
      "preventNativeAwait",
      () => preventNativeAwait,
      "readAsBuffer",
      () => readAsBuffer,
      "replicateAsyncIterator",
      () => replicateAsyncIterator,
      "resolveMaybeOptionalOptions",
      () => resolveMaybeOptionalOptions,
      "runInSpanContext",
      () => runInSpanContext,
      "runWithSpan",
      () => runWithSpan,
      "sequential",
      () => sequential,
      "setGlobalOtelConfig",
      () => setGlobalOtelConfig,
      "setSpanAttribute",
      () => setSpanAttribute,
      "setSpanError",
      () => setSpanError,
      "splitInHalf",
      () => splitInHalf,
      "startSpan",
      () => startSpan,
      "streamToAsyncIteratorClass",
      () => streamToAsyncIteratorClass,
      "stringifyJSON",
      () => stringifyJSON,
      "toArray",
      () => toArray,
      "toOtelException",
      () => toOtelException,
      "toSpanAttributeValue",
      () => toSpanAttributeValue,
      "tryDecodeURIComponent",
      () => tryDecodeURIComponent,
      "value",
      () => value,
    ]);
    function resolveMaybeOptionalOptions(rest) {
      return rest[0] ?? {};
    }
    function toArray(value) {
      return Array.isArray(value) ? value : value === void 0 || value === null ? [] : [value];
    }
    function splitInHalf(arr) {
      const half = Math.ceil(arr.length / 2);
      return [arr.slice(0, half), arr.slice(half)];
    }
    function readAsBuffer(source) {
      if (typeof source.bytes === "function") {
        return source.bytes();
      }
      return source.arrayBuffer();
    }
    const ORPC_NAME = "orpc";
    const ORPC_SHARED_PACKAGE_NAME = "@orpc/shared";
    const ORPC_SHARED_PACKAGE_VERSION = "1.13.5";
    class AbortError extends Error {
      constructor(...rest) {
        super(...rest);
        this.name = "AbortError";
      }
    }
    function once(fn) {
      let cached;
      return () => {
        if (cached) {
          return cached.result;
        }
        const result = fn();
        cached = {
          result,
        };
        return result;
      };
    }
    function sequential(fn) {
      let lastOperationPromise = Promise.resolve();
      return (...args) => {
        return (lastOperationPromise = lastOperationPromise
          .catch(() => {})
          .then(() => {
            return fn(...args);
          }));
      };
    }
    function defer(callback) {
      if (typeof setTimeout === "function") {
        setTimeout(callback, 0);
      } else {
        Promise.resolve().then(() =>
          Promise.resolve().then(() => Promise.resolve().then(callback)),
        );
      }
    }
    const SPAN_ERROR_STATUS = 2;
    const GLOBAL_OTEL_CONFIG_KEY = `__${ORPC_SHARED_PACKAGE_NAME}@${ORPC_SHARED_PACKAGE_VERSION}/otel/config__`;
    function setGlobalOtelConfig(config) {
      globalThis[GLOBAL_OTEL_CONFIG_KEY] = config;
    }
    function getGlobalOtelConfig() {
      return globalThis[GLOBAL_OTEL_CONFIG_KEY];
    }
    function startSpan(name, options = {}, context) {
      const tracer = getGlobalOtelConfig()?.tracer;
      return tracer?.startSpan(name, options, context);
    }
    function setSpanError(span, error, options = {}) {
      if (!span) {
        return;
      }
      const exception = toOtelException(error);
      span.recordException(exception);
      if (!options.signal?.aborted || options.signal.reason !== error) {
        span.setStatus({
          code: SPAN_ERROR_STATUS,
          message: exception.message,
        });
      }
    }
    function setSpanAttribute(span, key, value) {
      if (!span || value === void 0) {
        return;
      }
      span.setAttribute(key, value);
    }
    function toOtelException(error) {
      if (error instanceof Error) {
        const exception = {
          message: error.message,
          name: error.name,
          stack: error.stack,
        };
        if ("code" in error && (typeof error.code === "string" || typeof error.code === "number")) {
          exception.code = error.code;
        }
        return exception;
      }
      return {
        message: String(error),
      };
    }
    function toSpanAttributeValue(data) {
      if (data === void 0) {
        return "undefined";
      }
      try {
        return JSON.stringify(data, (_, value) => {
          if (typeof value === "bigint") {
            return value.toString();
          }
          if (value instanceof Map || value instanceof Set) {
            return Array.from(value);
          }
          return value;
        });
      } catch {
        return String(data);
      }
    }
    async function runWithSpan({ name, context, ...options }, fn) {
      const tracer = getGlobalOtelConfig()?.tracer;
      if (!tracer) {
        return fn();
      }
      const callback = async (span) => {
        try {
          return await fn(span);
        } catch (e) {
          setSpanError(span, e, options);
          throw e;
        } finally {
          span.end();
        }
      };
      if (context) {
        return tracer.startActiveSpan(name, options, context, callback);
      } else {
        return tracer.startActiveSpan(name, options, callback);
      }
    }
    async function runInSpanContext(span, fn) {
      const otelConfig = getGlobalOtelConfig();
      if (!span || !otelConfig) {
        return fn();
      }
      const ctx = otelConfig.trace.setSpan(otelConfig.context.active(), span);
      return otelConfig.context.with(ctx, fn);
    }
    class AsyncIdQueue {
      openIds = /* @__PURE__ */ new Set();
      queues = /* @__PURE__ */ new Map();
      waiters = /* @__PURE__ */ new Map();
      get length() {
        return this.openIds.size;
      }
      get waiterIds() {
        return Array.from(this.waiters.keys());
      }
      hasBufferedItems(id) {
        return Boolean(this.queues.get(id)?.length);
      }
      open(id) {
        this.openIds.add(id);
      }
      isOpen(id) {
        return this.openIds.has(id);
      }
      push(id, item) {
        this.assertOpen(id);
        const pending = this.waiters.get(id);
        if (pending?.length) {
          pending.shift()[0](item);
          if (pending.length === 0) {
            this.waiters.delete(id);
          }
        } else {
          const items = this.queues.get(id);
          if (items) {
            items.push(item);
          } else {
            this.queues.set(id, [item]);
          }
        }
      }
      async pull(id) {
        this.assertOpen(id);
        const items = this.queues.get(id);
        if (items?.length) {
          const item = items.shift();
          if (items.length === 0) {
            this.queues.delete(id);
          }
          return item;
        }
        return new Promise((resolve, reject) => {
          const waitingPulls = this.waiters.get(id);
          const pending = [resolve, reject];
          if (waitingPulls) {
            waitingPulls.push(pending);
          } else {
            this.waiters.set(id, [pending]);
          }
        });
      }
      close({ id, reason } = {}) {
        if (id === void 0) {
          this.waiters.forEach((pendingPulls, id2) => {
            const error2 =
              reason ??
              new AbortError(
                `[AsyncIdQueue] Queue[${id2}] was closed or aborted while waiting for pulling.`,
              );
            pendingPulls.forEach(([, reject]) => reject(error2));
          });
          this.waiters.clear();
          this.openIds.clear();
          this.queues.clear();
          return;
        }
        const error =
          reason ??
          new AbortError(
            `[AsyncIdQueue] Queue[${id}] was closed or aborted while waiting for pulling.`,
          );
        this.waiters.get(id)?.forEach(([, reject]) => reject(error));
        this.waiters.delete(id);
        this.openIds.delete(id);
        this.queues.delete(id);
      }
      assertOpen(id) {
        if (!this.isOpen(id)) {
          throw new Error(
            `[AsyncIdQueue] Cannot access queue[${id}] because it is not open or aborted.`,
          );
        }
      }
    }
    function isAsyncIteratorObject(maybe) {
      if (!maybe || typeof maybe !== "object") {
        return false;
      }
      return (
        "next" in maybe &&
        typeof maybe.next === "function" &&
        Symbol.asyncIterator in maybe &&
        typeof maybe[Symbol.asyncIterator] === "function"
      );
    }
    const fallbackAsyncDisposeSymbol = Symbol.for("asyncDispose");
    const asyncDisposeSymbol = Symbol.asyncDispose ?? fallbackAsyncDisposeSymbol;
    class AsyncIteratorClass {
      #isDone = false;
      #isExecuteComplete = false;
      #cleanup;
      #next;
      constructor(next, cleanup) {
        this.#cleanup = cleanup;
        this.#next = sequential(async () => {
          if (this.#isDone) {
            return {
              done: true,
              value: void 0,
            };
          }
          try {
            const result = await next();
            if (result.done) {
              this.#isDone = true;
            }
            return result;
          } catch (err) {
            this.#isDone = true;
            throw err;
          } finally {
            if (this.#isDone && !this.#isExecuteComplete) {
              this.#isExecuteComplete = true;
              await this.#cleanup("next");
            }
          }
        });
      }
      next() {
        return this.#next();
      }
      async return(value) {
        this.#isDone = true;
        if (!this.#isExecuteComplete) {
          this.#isExecuteComplete = true;
          await this.#cleanup("return");
        }
        return {
          done: true,
          value,
        };
      }
      async throw(err) {
        this.#isDone = true;
        if (!this.#isExecuteComplete) {
          this.#isExecuteComplete = true;
          await this.#cleanup("throw");
        }
        throw err;
      }
      /**
       * asyncDispose symbol only available in esnext, we should fallback to Symbol.for('asyncDispose')
       */ async [asyncDisposeSymbol]() {
        this.#isDone = true;
        if (!this.#isExecuteComplete) {
          this.#isExecuteComplete = true;
          await this.#cleanup("dispose");
        }
      }
      [Symbol.asyncIterator]() {
        return this;
      }
    }
    function replicateAsyncIterator(source, count) {
      const queue = new AsyncIdQueue();
      const ids = Array.from(
        {
          length: count,
        },
        (_, i) => i.toString(),
      );
      let isSourceFinished = false;
      const start = once(async () => {
        try {
          while (true) {
            const item = await source.next();
            ids.forEach((id) => {
              if (queue.isOpen(id)) {
                queue.push(id, {
                  next: item,
                });
              }
            });
            if (item.done) {
              break;
            }
          }
        } catch (error) {
          ids.forEach((id) => {
            if (queue.isOpen(id)) {
              queue.push(id, {
                error,
              });
            }
          });
        } finally {
          isSourceFinished = true;
        }
      });
      const replicated = ids.map((id) => {
        queue.open(id);
        return new AsyncIteratorClass(
          async () => {
            start();
            const item = await queue.pull(id);
            if (item.next) {
              return item.next;
            }
            throw item.error;
          },
          async (reason) => {
            queue.close({
              id,
            });
            if (reason !== "next" && !queue.length && !isSourceFinished) {
              isSourceFinished = true;
              await source?.return?.();
            }
          },
        );
      });
      return replicated;
    }
    function asyncIteratorWithSpan({ name, ...options }, iterator) {
      let span;
      return new AsyncIteratorClass(
        async () => {
          span ??= startSpan(name);
          try {
            const result = await runInSpanContext(span, () => iterator.next());
            span?.addEvent(result.done ? "completed" : "yielded");
            return result;
          } catch (err) {
            setSpanError(span, err, options);
            throw err;
          }
        },
        async (reason) => {
          try {
            if (reason !== "next") {
              await runInSpanContext(span, () => iterator.return?.());
            }
          } catch (err) {
            setSpanError(span, err, options);
            throw err;
          } finally {
            span?.end();
          }
        },
      );
    }
    class EventPublisher {
      #listenersMap = /* @__PURE__ */ new Map();
      #maxBufferedEvents;
      constructor(options = {}) {
        this.#maxBufferedEvents = options.maxBufferedEvents ?? 100;
      }
      get size() {
        return this.#listenersMap.size;
      }
      /**
       * Emits an event and delivers the payload to all subscribed listeners.
       */ publish(event, payload) {
        const listeners = this.#listenersMap.get(event);
        if (!listeners) {
          return;
        }
        for (const listener of listeners) {
          listener(payload);
        }
      }
      subscribe(event, listenerOrOptions) {
        if (typeof listenerOrOptions === "function") {
          let listeners = this.#listenersMap.get(event);
          if (!listeners) {
            this.#listenersMap.set(event, (listeners = []));
          }
          listeners.push(listenerOrOptions);
          return once(() => {
            listeners.splice(listeners.indexOf(listenerOrOptions), 1);
            if (listeners.length === 0) {
              this.#listenersMap.delete(event);
            }
          });
        }
        const signal = listenerOrOptions?.signal;
        const maxBufferedEvents = listenerOrOptions?.maxBufferedEvents ?? this.#maxBufferedEvents;
        signal?.throwIfAborted();
        const bufferedEvents = [];
        const pullResolvers = [];
        const unsubscribe = this.subscribe(event, (payload) => {
          const resolver = pullResolvers.shift();
          if (resolver) {
            resolver[0]({
              done: false,
              value: payload,
            });
          } else {
            bufferedEvents.push(payload);
            if (bufferedEvents.length > maxBufferedEvents) {
              bufferedEvents.shift();
            }
          }
        });
        const abortListener = (event2) => {
          unsubscribe();
          pullResolvers.forEach((resolver) => resolver[1](event2.target.reason));
          pullResolvers.length = 0;
          bufferedEvents.length = 0;
        };
        signal?.addEventListener("abort", abortListener, {
          once: true,
        });
        return new AsyncIteratorClass(
          async () => {
            if (signal?.aborted) {
              throw signal.reason;
            }
            if (bufferedEvents.length > 0) {
              return {
                done: false,
                value: bufferedEvents.shift(),
              };
            }
            return new Promise((resolve, reject) => {
              pullResolvers.push([resolve, reject]);
            });
          },
          async () => {
            unsubscribe();
            signal?.removeEventListener("abort", abortListener);
            pullResolvers.forEach((resolver) =>
              resolver[0]({
                done: true,
                value: void 0,
              }),
            );
            pullResolvers.length = 0;
            bufferedEvents.length = 0;
          },
        );
      }
    }
    class SequentialIdGenerator {
      index = BigInt(1);
      generate() {
        const id = this.index.toString(36);
        this.index++;
        return id;
      }
    }
    function compareSequentialIds(a, b) {
      if (a.length !== b.length) {
        return a.length - b.length;
      }
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function onStart(callback) {
      return async (options, ...rest) => {
        await callback(options, ...rest);
        return await options.next();
      };
    }
    function onSuccess(callback) {
      return async (options, ...rest) => {
        const result = await options.next();
        await callback(result, options, ...rest);
        return result;
      };
    }
    function onError(callback) {
      return async (options, ...rest) => {
        try {
          return await options.next();
        } catch (error) {
          await callback(error, options, ...rest);
          throw error;
        }
      };
    }
    function onFinish(callback) {
      let state;
      return async (options, ...rest) => {
        try {
          const result = await options.next();
          state = [null, result, true];
          return result;
        } catch (error) {
          state = [error, void 0, false];
          throw error;
        } finally {
          await callback(state, options, ...rest);
        }
      };
    }
    function intercept(interceptors, options, main) {
      const next = (options2, index) => {
        const interceptor = interceptors[index];
        if (!interceptor) {
          return main(options2);
        }
        return interceptor({
          ...options2,
          next: (newOptions = options2) => next(newOptions, index + 1),
        });
      };
      return next(options, 0);
    }
    function parseEmptyableJSON(text) {
      if (!text) {
        return void 0;
      }
      return JSON.parse(text);
    }
    function stringifyJSON(value) {
      return JSON.stringify(value);
    }
    function findDeepMatches(check, payload, segments = [], maps = [], values = []) {
      if (check(payload)) {
        maps.push(segments);
        values.push(payload);
      } else if (Array.isArray(payload)) {
        payload.forEach((v, i) => {
          findDeepMatches(check, v, [...segments, i], maps, values);
        });
      } else if (isObject(payload)) {
        for (const key in payload) {
          findDeepMatches(check, payload[key], [...segments, key], maps, values);
        }
      }
      return {
        maps,
        values,
      };
    }
    function getConstructor(value) {
      if (!isTypescriptObject(value)) {
        return null;
      }
      return Object.getPrototypeOf(value)?.constructor;
    }
    function isObject(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      const proto = Object.getPrototypeOf(value);
      return proto === Object.prototype || !proto || !proto.constructor;
    }
    function isTypescriptObject(value) {
      return !!value && (typeof value === "object" || typeof value === "function");
    }
    function clone(value) {
      if (Array.isArray(value)) {
        return value.map(clone);
      }
      if (isObject(value)) {
        const result = {};
        for (const key in value) {
          result[key] = clone(value[key]);
        }
        for (const sym of Object.getOwnPropertySymbols(value)) {
          result[sym] = clone(value[sym]);
        }
        return result;
      }
      return value;
    }
    function get(object, path) {
      let current = object;
      for (const key of path) {
        if (!isTypescriptObject(current)) {
          return void 0;
        }
        current = current[key];
      }
      return current;
    }
    function isPropertyKey(value) {
      const type = typeof value;
      return type === "string" || type === "number" || type === "symbol";
    }
    const NullProtoObj = /* @__PURE__ */ (() => {
      const e = function () {};
      e.prototype = /* @__PURE__ */ Object.create(null);
      Object.freeze(e.prototype);
      return e;
    })();
    function value(value2, ...args) {
      if (typeof value2 === "function") {
        return value2(...args);
      }
      return value2;
    }
    function fallback(value2, fallback2) {
      return value2 === void 0 ? fallback2 : value2;
    }
    function preventNativeAwait(target) {
      return new Proxy(target, {
        get(target2, prop, receiver) {
          const value2 = Reflect.get(target2, prop, receiver);
          if (prop !== "then" || typeof value2 !== "function") {
            return value2;
          }
          return new Proxy(value2, {
            apply(targetFn, thisArg, args) {
              if (args.length !== 2 || args.some((arg) => !isNativeFunction(arg))) {
                return Reflect.apply(targetFn, thisArg, args);
              }
              let shouldOmit = true;
              args[0].call(
                thisArg,
                preventNativeAwait(
                  new Proxy(target2, {
                    get: (target3, prop2, receiver2) => {
                      if (shouldOmit && prop2 === "then") {
                        shouldOmit = false;
                        return void 0;
                      }
                      return Reflect.get(target3, prop2, receiver2);
                    },
                  }),
                ),
              );
            },
          });
        },
      });
    }
    const NATIVE_FUNCTION_REGEX = /^\s*function\s*\(\)\s*\{\s*\[native code\]\s*\}\s*$/;
    function isNativeFunction(fn) {
      return typeof fn === "function" && NATIVE_FUNCTION_REGEX.test(fn.toString());
    }
    function overlayProxy(target, partial) {
      const proxy = new Proxy(typeof target === "function" ? partial : target, {
        get(_, prop) {
          const targetValue = prop in partial ? partial : value(target);
          const v = Reflect.get(targetValue, prop);
          return typeof v === "function" ? v.bind(targetValue) : v;
        },
        has(_, prop) {
          return Reflect.has(partial, prop) || Reflect.has(value(target), prop);
        },
      });
      return proxy;
    }
    function streamToAsyncIteratorClass(stream) {
      const reader = stream.getReader();
      return new AsyncIteratorClass(
        async () => {
          return reader.read();
        },
        async () => {
          await reader.cancel();
        },
      );
    }
    function asyncIteratorToStream(iterator) {
      return new ReadableStream({
        async pull(controller) {
          const { done, value } = await iterator.next();
          if (done) {
            controller.close();
          } else {
            controller.enqueue(value);
          }
        },
        async cancel() {
          await iterator.return?.();
        },
      });
    }
    function asyncIteratorToUnproxiedDataStream(iterator) {
      return new ReadableStream({
        async pull(controller) {
          const { done, value } = await iterator.next();
          if (done) {
            controller.close();
          } else {
            const unproxied = isObject(value)
              ? {
                  ...value,
                }
              : Array.isArray(value)
                ? value.map((i) => i)
                : value;
            controller.enqueue(unproxied);
          }
        },
        async cancel() {
          await iterator.return?.();
        },
      });
    }
    function tryDecodeURIComponent(value) {
      try {
        return decodeURIComponent(value);
      } catch {
        return value;
      }
    }
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "C",
      () => COMMON_ORPC_ERROR_DEFS,
      "O",
      () => ORPC_CLIENT_PACKAGE_NAME,
      "a",
      () => ORPC_CLIENT_PACKAGE_VERSION,
      "b",
      () => fallbackORPCErrorMessage,
      "c",
      () => ORPCError,
      "d",
      () => isORPCErrorStatus,
      "e",
      () => isORPCErrorJson,
      "f",
      () => fallbackORPCErrorStatus,
      "g",
      () => createORPCErrorFromJson,
      "i",
      () => isDefinedError,
      "t",
      () => toORPCError,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    const ORPC_CLIENT_PACKAGE_NAME = "@orpc/client";
    const ORPC_CLIENT_PACKAGE_VERSION = "1.13.5";
    const COMMON_ORPC_ERROR_DEFS = {
      BAD_REQUEST: {
        status: 400,
        message: "Bad Request",
      },
      UNAUTHORIZED: {
        status: 401,
        message: "Unauthorized",
      },
      FORBIDDEN: {
        status: 403,
        message: "Forbidden",
      },
      NOT_FOUND: {
        status: 404,
        message: "Not Found",
      },
      METHOD_NOT_SUPPORTED: {
        status: 405,
        message: "Method Not Supported",
      },
      NOT_ACCEPTABLE: {
        status: 406,
        message: "Not Acceptable",
      },
      TIMEOUT: {
        status: 408,
        message: "Request Timeout",
      },
      CONFLICT: {
        status: 409,
        message: "Conflict",
      },
      PRECONDITION_FAILED: {
        status: 412,
        message: "Precondition Failed",
      },
      PAYLOAD_TOO_LARGE: {
        status: 413,
        message: "Payload Too Large",
      },
      UNSUPPORTED_MEDIA_TYPE: {
        status: 415,
        message: "Unsupported Media Type",
      },
      UNPROCESSABLE_CONTENT: {
        status: 422,
        message: "Unprocessable Content",
      },
      TOO_MANY_REQUESTS: {
        status: 429,
        message: "Too Many Requests",
      },
      CLIENT_CLOSED_REQUEST: {
        status: 499,
        message: "Client Closed Request",
      },
      INTERNAL_SERVER_ERROR: {
        status: 500,
        message: "Internal Server Error",
      },
      NOT_IMPLEMENTED: {
        status: 501,
        message: "Not Implemented",
      },
      BAD_GATEWAY: {
        status: 502,
        message: "Bad Gateway",
      },
      SERVICE_UNAVAILABLE: {
        status: 503,
        message: "Service Unavailable",
      },
      GATEWAY_TIMEOUT: {
        status: 504,
        message: "Gateway Timeout",
      },
    };
    function fallbackORPCErrorStatus(code, status) {
      return status ?? COMMON_ORPC_ERROR_DEFS[code]?.status ?? 500;
    }
    function fallbackORPCErrorMessage(code, message) {
      return message || COMMON_ORPC_ERROR_DEFS[code]?.message || code;
    }
    const GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL = Symbol.for(
      `__${ORPC_CLIENT_PACKAGE_NAME}@${ORPC_CLIENT_PACKAGE_VERSION}/error/ORPC_ERROR_CONSTRUCTORS__`,
    );
    void (globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL] ??= /* @__PURE__ */ new WeakSet());
    const globalORPCErrorConstructors = globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL];
    class ORPCError extends Error {
      defined;
      code;
      status;
      data;
      constructor(code, ...rest) {
        const options = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "resolveMaybeOptionalOptions"
        ])(rest);
        if (options.status !== void 0 && !isORPCErrorStatus(options.status)) {
          throw new Error("[ORPCError] Invalid error status code.");
        }
        const message = fallbackORPCErrorMessage(code, options.message);
        super(message, options);
        this.code = code;
        this.status = fallbackORPCErrorStatus(code, options.status);
        this.defined = options.defined ?? false;
        this.data = options.data;
      }
      toJSON() {
        return {
          defined: this.defined,
          code: this.code,
          status: this.status,
          message: this.message,
          data: this.data,
        };
      }
      /**
       * Workaround for Next.js where different contexts use separate
       * dependency graphs, causing multiple ORPCError constructors existing and breaking
       * `instanceof` checks across contexts.
       *
       * This is particularly problematic with "Optimized SSR", where orpc-client
       * executes in one context but is invoked from another. When an error is thrown
       * in the execution context, `instanceof ORPCError` checks fail in the
       * invocation context due to separate class constructors.
       *
       * @todo Remove this and related code if Next.js resolves the multiple dependency graph issue.
       */ static [Symbol.hasInstance](instance) {
        if (globalORPCErrorConstructors.has(this)) {
          const constructor = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "getConstructor"
          ])(instance);
          if (constructor && globalORPCErrorConstructors.has(constructor)) {
            return true;
          }
        }
        return super[Symbol.hasInstance](instance);
      }
    }
    globalORPCErrorConstructors.add(ORPCError);
    function isDefinedError(error) {
      return error instanceof ORPCError && error.defined;
    }
    function toORPCError(error) {
      return error instanceof ORPCError
        ? error
        : new ORPCError("INTERNAL_SERVER_ERROR", {
            message: "Internal server error",
            cause: error,
          });
    }
    function isORPCErrorStatus(status) {
      return status < 200 || status >= 400;
    }
    function isORPCErrorJson(json) {
      if (
        !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "isObject"
        ])(json)
      ) {
        return false;
      }
      const validKeys = ["defined", "code", "status", "message", "data"];
      if (Object.keys(json).some((k) => !validKeys.includes(k))) {
        return false;
      }
      return (
        "defined" in json &&
        typeof json.defined === "boolean" &&
        "code" in json &&
        typeof json.code === "string" &&
        "status" in json &&
        typeof json.status === "number" &&
        isORPCErrorStatus(json.status) &&
        "message" in json &&
        typeof json.message === "string"
      );
    }
    function createORPCErrorFromJson(json, options = {}) {
      return new ORPCError(json.code, {
        ...options,
        ...json,
      });
    }
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["m", () => mapEventIterator]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-route] (ecmascript)",
      );
    function mapEventIterator(iterator, maps) {
      const mapError = async (error) => {
        let mappedError = await maps.error(error);
        if (mappedError !== error) {
          const meta = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "getEventMeta"
          ])(error);
          if (
            meta &&
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "isTypescriptObject"
            ])(mappedError)
          ) {
            mappedError = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "withEventMeta"
            ])(mappedError, meta);
          }
        }
        return mappedError;
      };
      return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "AsyncIteratorClass"
      ](
        async () => {
          const { done, value } = await (async () => {
            try {
              return await iterator.next();
            } catch (error) {
              throw await mapError(error);
            }
          })();
          let mappedValue = await maps.value(value, done);
          if (mappedValue !== value) {
            const meta = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "getEventMeta"
            ])(value);
            if (
              meta &&
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "isTypescriptObject"
              ])(mappedValue)
            ) {
              mappedValue = (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "withEventMeta"
              ])(mappedValue, meta);
            }
          }
          return {
            done,
            value: mappedValue,
          };
        },
        async () => {
          try {
            await iterator.return?.();
          } catch (error) {
            throw await mapError(error);
          }
        },
      );
    }
  },
  "[project]/node_modules/@orpc/client/dist/index.mjs [app-route] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "DynamicLink",
      () => DynamicLink,
      "consumeEventIterator",
      () => consumeEventIterator,
      "createORPCClient",
      () => createORPCClient,
      "createSafeClient",
      () => createSafeClient,
      "resolveFriendlyClientOptions",
      () => resolveFriendlyClientOptions,
      "safe",
      () => safe,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-route] (ecmascript)",
      );
    async function safe(promise) {
      try {
        const output = await promise;
        return Object.assign([null, output, false, true], {
          error: null,
          data: output,
          isDefined: false,
          isSuccess: true,
        });
      } catch (e) {
        const error = e;
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "i"
          ])(error)
        ) {
          return Object.assign([error, void 0, true, false], {
            error,
            data: void 0,
            isDefined: true,
            isSuccess: false,
          });
        }
        return Object.assign([error, void 0, false, false], {
          error,
          data: void 0,
          isDefined: false,
          isSuccess: false,
        });
      }
    }
    function resolveFriendlyClientOptions(options) {
      return {
        ...options,
        context: options.context ?? {},
      };
    }
    function consumeEventIterator(iterator, options) {
      void (async () => {
        let onFinishState;
        try {
          const resolvedIterator = await iterator;
          while (true) {
            const { done, value } = await resolvedIterator.next();
            if (done) {
              const realValue = value;
              onFinishState = [null, realValue, true];
              options.onSuccess?.(realValue);
              break;
            }
            options.onEvent(value);
          }
        } catch (error) {
          onFinishState = [error, void 0, false];
          if (!options.onError && !options.onFinish) {
            throw error;
          }
          options.onError?.(error);
        } finally {
          options.onFinish?.(onFinishState);
        }
      })();
      return async () => {
        await (await iterator)?.return?.();
      };
    }
    function createORPCClient(link, options = {}) {
      const path = options.path ?? [];
      const procedureClient = async (...[input, options2 = {}]) => {
        return await link.call(path, input, resolveFriendlyClientOptions(options2));
      };
      const recursive = new Proxy(procedureClient, {
        get(target, key) {
          if (typeof key !== "string") {
            return Reflect.get(target, key);
          }
          return createORPCClient(link, {
            ...options,
            path: [...path, key],
          });
        },
      });
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "preventNativeAwait"
      ])(recursive);
    }
    function createSafeClient(client) {
      const proxy = new Proxy((...args) => safe(client(...args)), {
        get(_, prop, receiver) {
          const value = Reflect.get(client, prop, receiver);
          if (typeof prop !== "string") {
            return value;
          }
          if (
            !(0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "isTypescriptObject"
            ])(value)
          ) {
            return value;
          }
          return createSafeClient(value);
        },
      });
      return proxy;
    }
    class DynamicLink {
      constructor(linkResolver) {
        this.linkResolver = linkResolver;
      }
      async call(path, input, options) {
        const resolvedLink = await this.linkResolver(options, path, input);
        const output = await resolvedLink.call(path, input, options);
        return output;
      }
    }
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export f as fallbackORPCErrorStatus>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "fallbackORPCErrorStatus",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "f"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export c as ORPCError>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "ORPCError",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "c"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export d as isORPCErrorStatus>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "isORPCErrorStatus",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "d"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "C",
      () => CompositeStandardLinkPlugin,
      "S",
      () => StandardLink,
      "a",
      () => STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES,
      "b",
      () => StandardRPCJsonSerializer,
      "c",
      () => StandardRPCLink,
      "d",
      () => StandardRPCLinkCodec,
      "e",
      () => StandardRPCSerializer,
      "f",
      () => toStandardHeaders,
      "g",
      () => getMalformedResponseErrorCode,
      "t",
      () => toHttpPath,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2d$fetch$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server-fetch/dist/index.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs [app-route] (ecmascript)",
      );
    class CompositeStandardLinkPlugin {
      plugins;
      constructor(plugins = []) {
        this.plugins = [...plugins].sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
      }
      init(options) {
        for (const plugin of this.plugins) {
          plugin.init?.(options);
        }
      }
    }
    class StandardLink {
      constructor(codec, sender, options = {}) {
        this.codec = codec;
        this.sender = sender;
        const plugin = new CompositeStandardLinkPlugin(options.plugins);
        plugin.init(options);
        this.interceptors = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "toArray"
        ])(options.interceptors);
        this.clientInterceptors = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "toArray"
        ])(options.clientInterceptors);
      }
      interceptors;
      clientInterceptors;
      call(path, input, options) {
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "runWithSpan"
        ])(
          {
            name: `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ORPC_NAME"]}.${path.join("/")}`,
            signal: options.signal,
          },
          (span) => {
            span?.setAttribute(
              "rpc.system",
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "ORPC_NAME"
              ],
            );
            span?.setAttribute("rpc.method", path.join("."));
            if (
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "isAsyncIteratorObject"
              ])(input)
            ) {
              input = (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "asyncIteratorWithSpan"
              ])(
                {
                  name: "consume_event_iterator_input",
                  signal: options.signal,
                },
                input,
              );
            }
            return (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "intercept"
            ])(
              this.interceptors,
              {
                ...options,
                path,
                input,
              },
              async ({ path: path2, input: input2, ...options2 }) => {
                const otelConfig = (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "getGlobalOtelConfig"
                ])();
                let otelContext;
                const currentSpan = otelConfig?.trace.getActiveSpan() ?? span;
                if (currentSpan && otelConfig) {
                  otelContext = otelConfig?.trace.setSpan(otelConfig.context.active(), currentSpan);
                }
                const request = await (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "runWithSpan"
                ])(
                  {
                    name: "encode_request",
                    context: otelContext,
                  },
                  () => this.codec.encode(path2, input2, options2),
                );
                const response = await (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "intercept"
                ])(
                  this.clientInterceptors,
                  {
                    ...options2,
                    input: input2,
                    path: path2,
                    request,
                  },
                  ({ input: input3, path: path3, request: request2, ...options3 }) => {
                    return (0,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                      "runWithSpan"
                    ])(
                      {
                        name: "send_request",
                        signal: options3.signal,
                        context: otelContext,
                      },
                      () => this.sender.call(request2, options3, path3, input3),
                    );
                  },
                );
                const output = await (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "runWithSpan"
                ])(
                  {
                    name: "decode_response",
                    context: otelContext,
                  },
                  () => this.codec.decode(response, options2, path2, input2),
                );
                if (
                  (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "isAsyncIteratorObject"
                  ])(output)
                ) {
                  return (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "asyncIteratorWithSpan"
                  ])(
                    {
                      name: "consume_event_iterator_output",
                      signal: options2.signal,
                    },
                    output,
                  );
                }
                return output;
              },
            );
          },
        );
      }
    }
    const STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES = {
      BIGINT: 0,
      DATE: 1,
      NAN: 2,
      UNDEFINED: 3,
      URL: 4,
      REGEXP: 5,
      SET: 6,
      MAP: 7,
    };
    class StandardRPCJsonSerializer {
      customSerializers;
      constructor(options = {}) {
        this.customSerializers = options.customJsonSerializers ?? [];
        if (
          this.customSerializers.length !==
          new Set(this.customSerializers.map((custom) => custom.type)).size
        ) {
          throw new Error("Custom serializer type must be unique.");
        }
      }
      serialize(data, segments = [], meta = [], maps = [], blobs = []) {
        for (const custom of this.customSerializers) {
          if (custom.condition(data)) {
            const result = this.serialize(custom.serialize(data), segments, meta, maps, blobs);
            meta.push([custom.type, ...segments]);
            return result;
          }
        }
        if (data instanceof Blob) {
          maps.push(segments);
          blobs.push(data);
          return [data, meta, maps, blobs];
        }
        if (typeof data === "bigint") {
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.BIGINT, ...segments]);
          return [data.toString(), meta, maps, blobs];
        }
        if (data instanceof Date) {
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.DATE, ...segments]);
          if (Number.isNaN(data.getTime())) {
            return [null, meta, maps, blobs];
          }
          return [data.toISOString(), meta, maps, blobs];
        }
        if (Number.isNaN(data)) {
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.NAN, ...segments]);
          return [null, meta, maps, blobs];
        }
        if (data instanceof URL) {
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.URL, ...segments]);
          return [data.toString(), meta, maps, blobs];
        }
        if (data instanceof RegExp) {
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.REGEXP, ...segments]);
          return [data.toString(), meta, maps, blobs];
        }
        if (data instanceof Set) {
          const result = this.serialize(Array.from(data), segments, meta, maps, blobs);
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.SET, ...segments]);
          return result;
        }
        if (data instanceof Map) {
          const result = this.serialize(Array.from(data.entries()), segments, meta, maps, blobs);
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.MAP, ...segments]);
          return result;
        }
        if (Array.isArray(data)) {
          const json = data.map((v, i) => {
            if (v === void 0) {
              meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.UNDEFINED, ...segments, i]);
              return v;
            }
            return this.serialize(v, [...segments, i], meta, maps, blobs)[0];
          });
          return [json, meta, maps, blobs];
        }
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "isObject"
          ])(data)
        ) {
          const json = {};
          for (const k in data) {
            if (k === "toJSON" && typeof data[k] === "function") {
              continue;
            }
            json[k] = this.serialize(data[k], [...segments, k], meta, maps, blobs)[0];
          }
          return [json, meta, maps, blobs];
        }
        return [data, meta, maps, blobs];
      }
      deserialize(json, meta, maps, getBlob) {
        const ref = {
          data: json,
        };
        if (maps && getBlob) {
          maps.forEach((segments, i) => {
            let currentRef = ref;
            let preSegment = "data";
            segments.forEach((segment) => {
              currentRef = currentRef[preSegment];
              preSegment = segment;
            });
            currentRef[preSegment] = getBlob(i);
          });
        }
        for (const item of meta) {
          const type = item[0];
          let currentRef = ref;
          let preSegment = "data";
          for (let i = 1; i < item.length; i++) {
            currentRef = currentRef[preSegment];
            preSegment = item[i];
          }
          for (const custom of this.customSerializers) {
            if (custom.type === type) {
              currentRef[preSegment] = custom.deserialize(currentRef[preSegment]);
              break;
            }
          }
          switch (type) {
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.BIGINT:
              currentRef[preSegment] = BigInt(currentRef[preSegment]);
              break;
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.DATE:
              currentRef[preSegment] = new Date(currentRef[preSegment] ?? "Invalid Date");
              break;
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.NAN:
              currentRef[preSegment] = Number.NaN;
              break;
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.UNDEFINED:
              currentRef[preSegment] = void 0;
              break;
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.URL:
              currentRef[preSegment] = new URL(currentRef[preSegment]);
              break;
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.REGEXP: {
              const [, pattern, flags] = currentRef[preSegment].match(/^\/(.*)\/([a-z]*)$/);
              currentRef[preSegment] = new RegExp(pattern, flags);
              break;
            }
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.SET:
              currentRef[preSegment] = new Set(currentRef[preSegment]);
              break;
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.MAP:
              currentRef[preSegment] = new Map(currentRef[preSegment]);
              break;
          }
        }
        return ref.data;
      }
    }
    function toHttpPath(path) {
      return `/${path.map(encodeURIComponent).join("/")}`;
    }
    function toStandardHeaders(headers) {
      if (typeof headers.forEach === "function") {
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2d$fetch$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "toStandardHeaders"
        ])(headers);
      }
      return headers;
    }
    function getMalformedResponseErrorCode(status) {
      return (
        Object.entries(
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "C"
          ],
        ).find(([, def]) => def.status === status)?.[0] ?? "MALFORMED_ORPC_ERROR_RESPONSE"
      );
    }
    class StandardRPCLinkCodec {
      constructor(serializer, options) {
        this.serializer = serializer;
        this.baseUrl = options.url;
        this.maxUrlLength = options.maxUrlLength ?? 2083;
        this.fallbackMethod = options.fallbackMethod ?? "POST";
        this.expectedMethod = options.method ?? this.fallbackMethod;
        this.headers = options.headers ?? {};
      }
      baseUrl;
      maxUrlLength;
      fallbackMethod;
      expectedMethod;
      headers;
      async encode(path, input, options) {
        let headers = toStandardHeaders(
          await (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "value"
          ])(this.headers, options, path, input),
        );
        if (options.lastEventId !== void 0) {
          headers = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "mergeStandardHeaders"
          ])(headers, {
            "last-event-id": options.lastEventId,
          });
        }
        const expectedMethod = await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "value"
        ])(this.expectedMethod, options, path, input);
        const baseUrl = await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "value"
        ])(this.baseUrl, options, path, input);
        const url = new URL(baseUrl);
        url.pathname = `${url.pathname.replace(/\/$/, "")}${toHttpPath(path)}`;
        const serialized = this.serializer.serialize(input);
        if (
          expectedMethod === "GET" &&
          !(serialized instanceof FormData) &&
          !(0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "isAsyncIteratorObject"
          ])(serialized)
        ) {
          const maxUrlLength = await (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "value"
          ])(this.maxUrlLength, options, path, input);
          const getUrl = new URL(url);
          getUrl.searchParams.append(
            "data",
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "stringifyJSON"
            ])(serialized),
          );
          if (getUrl.toString().length <= maxUrlLength) {
            return {
              body: void 0,
              method: expectedMethod,
              headers,
              url: getUrl,
              signal: options.signal,
            };
          }
        }
        return {
          url,
          method: expectedMethod === "GET" ? this.fallbackMethod : expectedMethod,
          headers,
          body: serialized,
          signal: options.signal,
        };
      }
      async decode(response) {
        const isOk = !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "d"
        ])(response.status);
        const deserialized = await (async () => {
          let isBodyOk = false;
          try {
            const body = await response.body();
            isBodyOk = true;
            return this.serializer.deserialize(body);
          } catch (error) {
            if (!isBodyOk) {
              throw new Error(
                "Cannot parse response body, please check the response body and content-type.",
                {
                  cause: error,
                },
              );
            }
            throw new Error("Invalid RPC response format.", {
              cause: error,
            });
          }
        })();
        if (!isOk) {
          if (
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "e"
            ])(deserialized)
          ) {
            throw (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "g"
            ])(deserialized);
          }
          throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "c"
          ](getMalformedResponseErrorCode(response.status), {
            status: response.status,
            data: {
              ...response,
              body: deserialized,
            },
          });
        }
        return deserialized;
      }
    }
    class StandardRPCSerializer {
      constructor(jsonSerializer) {
        this.jsonSerializer = jsonSerializer;
      }
      serialize(data) {
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "isAsyncIteratorObject"
          ])(data)
        ) {
          return (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "m"
          ])(data, {
            value: async (value) => this.#serialize(value, false),
            error: async (e) => {
              return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "ErrorEvent"
              ]({
                data: this.#serialize(
                  (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                    "t"
                  ])(e).toJSON(),
                  false,
                ),
                cause: e,
              });
            },
          });
        }
        return this.#serialize(data, true);
      }
      #serialize(data, enableFormData) {
        const [json, meta_, maps, blobs] = this.jsonSerializer.serialize(data);
        const meta = meta_.length === 0 ? void 0 : meta_;
        if (!enableFormData || blobs.length === 0) {
          return {
            json,
            meta,
          };
        }
        const form = new FormData();
        form.set(
          "data",
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "stringifyJSON"
          ])({
            json,
            meta,
            maps,
          }),
        );
        blobs.forEach((blob, i) => {
          form.set(i.toString(), blob);
        });
        return form;
      }
      deserialize(data) {
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "isAsyncIteratorObject"
          ])(data)
        ) {
          return (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "m"
          ])(data, {
            value: async (value) => this.#deserialize(value),
            error: async (e) => {
              if (
                !(
                  e instanceof
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                    "ErrorEvent"
                  ]
                )
              ) {
                return e;
              }
              const deserialized = this.#deserialize(e.data);
              if (
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                  "e"
                ])(deserialized)
              ) {
                return (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                  "g"
                ])(deserialized, {
                  cause: e,
                });
              }
              return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "ErrorEvent"
              ]({
                data: deserialized,
                cause: e,
              });
            },
          });
        }
        return this.#deserialize(data);
      }
      #deserialize(data) {
        if (data === void 0) {
          return void 0;
        }
        if (!(data instanceof FormData)) {
          return this.jsonSerializer.deserialize(data.json, data.meta ?? []);
        }
        const serialized = JSON.parse(data.get("data"));
        return this.jsonSerializer.deserialize(
          serialized.json,
          serialized.meta ?? [],
          serialized.maps,
          (i) => data.get(i.toString()),
        );
      }
    }
    class StandardRPCLink extends StandardLink {
      constructor(linkClient, options) {
        const jsonSerializer = new StandardRPCJsonSerializer(options);
        const serializer = new StandardRPCSerializer(jsonSerializer);
        const linkCodec = new StandardRPCLinkCodec(serializer, options);
        super(linkCodec, linkClient, options);
      }
    }
  },
  "[project]/node_modules/@orpc/client/dist/adapters/standard/index.mjs [app-route] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2d$fetch$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server-fetch/dist/index.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-route] (ecmascript) <export t as toHttpPath>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "toHttpPath",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "t"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs [app-route] (ecmascript) <export m as mapEventIterator>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "mapEventIterator",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "m"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export t as toORPCError>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "toORPCError",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "t"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-route] (ecmascript) <export b as StandardRPCJsonSerializer>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "StandardRPCJsonSerializer",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "b"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-route] (ecmascript) <export e as StandardRPCSerializer>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "StandardRPCSerializer",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "e"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "ErrorEvent",
      () => ErrorEvent,
      "EventDecoder",
      () => EventDecoder,
      "EventDecoderError",
      () => EventDecoderError,
      "EventDecoderStream",
      () => EventDecoderStream,
      "EventEncoderError",
      () => EventEncoderError,
      "HibernationEventIterator",
      () => HibernationEventIterator,
      "assertEventComment",
      () => assertEventComment,
      "assertEventId",
      () => assertEventId,
      "assertEventName",
      () => assertEventName,
      "assertEventRetry",
      () => assertEventRetry,
      "decodeEventMessage",
      () => decodeEventMessage,
      "encodeEventComments",
      () => encodeEventComments,
      "encodeEventData",
      () => encodeEventData,
      "encodeEventMessage",
      () => encodeEventMessage,
      "flattenHeader",
      () => flattenHeader,
      "generateContentDisposition",
      () => generateContentDisposition,
      "getEventMeta",
      () => getEventMeta,
      "getFilenameFromContentDisposition",
      () => getFilenameFromContentDisposition,
      "isEventIteratorHeaders",
      () => isEventIteratorHeaders,
      "mergeStandardHeaders",
      () => mergeStandardHeaders,
      "replicateStandardLazyResponse",
      () => replicateStandardLazyResponse,
      "withEventMeta",
      () => withEventMeta,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    class EventEncoderError extends TypeError {}
    class EventDecoderError extends TypeError {}
    class ErrorEvent extends Error {
      data;
      constructor(options) {
        super(options?.message ?? "An error event was received", options);
        this.data = options?.data;
      }
    }
    function decodeEventMessage(encoded) {
      const lines = encoded.replace(/\n+$/, "").split(/\n/);
      const message = {
        data: void 0,
        event: void 0,
        id: void 0,
        retry: void 0,
        comments: [],
      };
      for (const line of lines) {
        const index = line.indexOf(":");
        const key = index === -1 ? line : line.slice(0, index);
        const value = index === -1 ? "" : line.slice(index + 1).replace(/^\s/, "");
        if (index === 0) {
          message.comments.push(value);
        } else if (key === "data") {
          message.data ??= "";
          message.data += `${value}
`;
        } else if (key === "event") {
          message.event = value;
        } else if (key === "id") {
          message.id = value;
        } else if (key === "retry") {
          const maybeInteger = Number.parseInt(value);
          if (
            Number.isInteger(maybeInteger) &&
            maybeInteger >= 0 &&
            maybeInteger.toString() === value
          ) {
            message.retry = maybeInteger;
          }
        }
      }
      message.data = message.data?.replace(/\n$/, "");
      return message;
    }
    class EventDecoder {
      constructor(options = {}) {
        this.options = options;
      }
      incomplete = "";
      feed(chunk) {
        this.incomplete += chunk;
        const lastCompleteIndex = this.incomplete.lastIndexOf("\n\n");
        if (lastCompleteIndex === -1) {
          return;
        }
        const completes = this.incomplete.slice(0, lastCompleteIndex).split(/\n\n/);
        this.incomplete = this.incomplete.slice(lastCompleteIndex + 2);
        for (const encoded of completes) {
          const message = decodeEventMessage(`${encoded}

`);
          if (this.options.onEvent) {
            this.options.onEvent(message);
          }
        }
      }
      end() {
        if (this.incomplete) {
          throw new EventDecoderError("Event Iterator ended before complete");
        }
      }
    }
    class EventDecoderStream extends TransformStream {
      constructor() {
        let decoder;
        super({
          start(controller) {
            decoder = new EventDecoder({
              onEvent: (event) => {
                controller.enqueue(event);
              },
            });
          },
          transform(chunk) {
            decoder.feed(chunk);
          },
          flush() {
            decoder.end();
          },
        });
      }
    }
    function assertEventId(id) {
      if (id.includes("\n")) {
        throw new EventEncoderError("Event's id must not contain a newline character");
      }
    }
    function assertEventName(event) {
      if (event.includes("\n")) {
        throw new EventEncoderError("Event's event must not contain a newline character");
      }
    }
    function assertEventRetry(retry) {
      if (!Number.isInteger(retry) || retry < 0) {
        throw new EventEncoderError("Event's retry must be a integer and >= 0");
      }
    }
    function assertEventComment(comment) {
      if (comment.includes("\n")) {
        throw new EventEncoderError("Event's comment must not contain a newline character");
      }
    }
    function encodeEventData(data) {
      const lines = data?.split(/\n/) ?? [];
      let output = "";
      for (const line of lines) {
        output += `data: ${line}
`;
      }
      return output;
    }
    function encodeEventComments(comments) {
      let output = "";
      for (const comment of comments ?? []) {
        assertEventComment(comment);
        output += `: ${comment}
`;
      }
      return output;
    }
    function encodeEventMessage(message) {
      let output = "";
      output += encodeEventComments(message.comments);
      if (message.event !== void 0) {
        assertEventName(message.event);
        output += `event: ${message.event}
`;
      }
      if (message.retry !== void 0) {
        assertEventRetry(message.retry);
        output += `retry: ${message.retry}
`;
      }
      if (message.id !== void 0) {
        assertEventId(message.id);
        output += `id: ${message.id}
`;
      }
      output += encodeEventData(message.data);
      output += "\n";
      return output;
    }
    const EVENT_SOURCE_META_SYMBOL = Symbol("ORPC_EVENT_SOURCE_META");
    function withEventMeta(container, meta) {
      if (meta.id === void 0 && meta.retry === void 0 && !meta.comments?.length) {
        return container;
      }
      if (meta.id !== void 0) {
        assertEventId(meta.id);
      }
      if (meta.retry !== void 0) {
        assertEventRetry(meta.retry);
      }
      if (meta.comments !== void 0) {
        for (const comment of meta.comments) {
          assertEventComment(comment);
        }
      }
      return new Proxy(container, {
        get(target, prop, receiver) {
          if (prop === EVENT_SOURCE_META_SYMBOL) {
            return meta;
          }
          return Reflect.get(target, prop, receiver);
        },
      });
    }
    function getEventMeta(container) {
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "isTypescriptObject"
      ])(container)
        ? Reflect.get(container, EVENT_SOURCE_META_SYMBOL)
        : void 0;
    }
    class HibernationEventIterator
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "AsyncIteratorClass"
      ]
    {
      /**
       * this property is not transferred to the client, so it should be optional for type safety
       */ hibernationCallback;
      constructor(hibernationCallback) {
        super(
          async () => {
            throw new Error("Cannot iterate over hibernating iterator directly");
          },
          async (reason) => {
            if (reason !== "next") {
              throw new Error("Cannot cleanup hibernating iterator directly");
            }
          },
        );
        this.hibernationCallback = hibernationCallback;
      }
    }
    function generateContentDisposition(filename) {
      const escapedFileName = filename.replace(/"/g, '\\"');
      const encodedFilenameStar = encodeURIComponent(filename)
        .replace(/['()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`)
        .replace(/%(7C|60|5E)/g, (str, hex) => String.fromCharCode(Number.parseInt(hex, 16)));
      return `inline; filename="${escapedFileName}"; filename*=utf-8''${encodedFilenameStar}`;
    }
    function getFilenameFromContentDisposition(contentDisposition) {
      const encodedFilenameStarMatch = contentDisposition.match(/filename\*=(UTF-8'')?([^;]*)/i);
      if (encodedFilenameStarMatch && typeof encodedFilenameStarMatch[2] === "string") {
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "tryDecodeURIComponent"
        ])(encodedFilenameStarMatch[2]);
      }
      const encodedFilenameMatch = contentDisposition.match(/filename="((?:\\"|[^"])*)"/i);
      if (encodedFilenameMatch && typeof encodedFilenameMatch[1] === "string") {
        return encodedFilenameMatch[1].replace(/\\"/g, '"');
      }
    }
    function mergeStandardHeaders(a, b) {
      const merged = {
        ...a,
      };
      for (const key in b) {
        if (Array.isArray(b[key])) {
          merged[key] = [
            ...(0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "toArray"
            ])(merged[key]),
            ...b[key],
          ];
        } else if (b[key] !== void 0) {
          if (Array.isArray(merged[key])) {
            merged[key] = [...merged[key], b[key]];
          } else if (merged[key] !== void 0) {
            merged[key] = [merged[key], b[key]];
          } else {
            merged[key] = b[key];
          }
        }
      }
      return merged;
    }
    function flattenHeader(header) {
      if (typeof header === "string" || header === void 0) {
        return header;
      }
      if (header.length === 0) {
        return void 0;
      }
      return header.join(", ");
    }
    function replicateStandardLazyResponse(response, count) {
      const replicated = [];
      let bodyPromise;
      let replicatedAsyncIteratorObjects;
      for (let i = 0; i < count; i++) {
        replicated.push({
          ...response,
          body: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "once"
          ])(async () => {
            const body = await (bodyPromise ??= response.body());
            if (
              !(0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "isAsyncIteratorObject"
              ])(body)
            ) {
              return body;
            }
            replicatedAsyncIteratorObjects ??= (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "replicateAsyncIterator"
            ])(body, count);
            return replicatedAsyncIteratorObjects.shift();
          }),
        });
      }
      return replicated;
    }
    function isEventIteratorHeaders(headers) {
      return Boolean(
        flattenHeader(headers["content-type"])?.startsWith("text/event-stream") &&
        flattenHeader(headers["content-disposition"]) === void 0,
      );
    }
  },
  "[project]/node_modules/@orpc/standard-server/dist/batch/index.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "parseBatchRequest",
      () => parseBatchRequest,
      "parseBatchResponse",
      () => parseBatchResponse,
      "toBatchAbortSignal",
      () => toBatchAbortSignal,
      "toBatchRequest",
      () => toBatchRequest,
      "toBatchResponse",
      () => toBatchResponse,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    function toBatchAbortSignal(signals) {
      const realSignals = signals.filter((signal) => signal !== void 0);
      if (realSignals.length === 0 || realSignals.length !== signals.length) {
        return void 0;
      }
      const controller = new AbortController();
      const abortIfAllInputsAborted = () => {
        if (realSignals.every((signal) => signal.aborted)) {
          controller.abort();
        }
      };
      abortIfAllInputsAborted();
      for (const signal of realSignals) {
        signal.addEventListener(
          "abort",
          () => {
            abortIfAllInputsAborted();
          },
          {
            once: true,
            signal: controller.signal,
          },
        );
      }
      return controller.signal;
    }
    function toBatchRequest(options) {
      const url = new URL(options.url);
      let body;
      const batchRequestItems = options.requests.map((request) => ({
        body: request.body,
        headers: Object.keys(request.headers).length ? request.headers : void 0,
        method: request.method === options.method ? void 0 : request.method,
        url: request.url,
      }));
      if (options.method === "GET") {
        url.searchParams.append(
          "batch",
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "stringifyJSON"
          ])(batchRequestItems),
        );
      } else if (options.method === "POST") {
        body = batchRequestItems;
      }
      return {
        method: options.method,
        url,
        headers: options.headers,
        body,
        signal: toBatchAbortSignal(options.requests.map((request) => request.signal)),
      };
    }
    function parseBatchRequest(request) {
      const items =
        request.method === "GET"
          ? (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "parseEmptyableJSON"
            ])(request.url.searchParams.getAll("batch").at(-1))
          : request.body;
      if (!Array.isArray(items)) {
        throw new TypeError("Invalid batch request");
      }
      return items.map((item) => {
        return {
          method: item.method ?? request.method,
          url: new URL(item.url),
          headers: item.headers ?? {},
          body: item.body,
          signal: request.signal,
        };
      });
    }
    function toBatchResponse(options) {
      const mode = options.mode ?? "streaming";
      const minifyResponseItem = (item) => {
        return {
          index: item.index,
          status: item.status === options.status ? void 0 : item.status,
          headers: Object.keys(item.headers).length ? item.headers : void 0,
          body: item.body,
        };
      };
      if (mode === "buffered") {
        return (async () => {
          try {
            const body = [];
            for await (const item of options.body) {
              body.push(minifyResponseItem(item));
            }
            return {
              headers: options.headers,
              status: options.status,
              body,
            };
          } finally {
            await options.body.return?.();
          }
        })();
      }
      return {
        headers: options.headers,
        status: options.status,
        body: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "AsyncIteratorClass"
        ](
          async () => {
            const { done, value } = await options.body.next();
            if (done) {
              return {
                done,
                value,
              };
            }
            return {
              done,
              value: {
                index: value.index,
                status: value.status === options.status ? void 0 : value.status,
                headers: Object.keys(value.headers).length ? value.headers : void 0,
                body: value.body,
              },
            };
          },
          async (reason) => {
            if (reason !== "next") {
              await options.body.return?.();
            }
          },
        ),
      };
    }
    function parseBatchResponse(response) {
      const body = response.body;
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "isAsyncIteratorObject"
        ])(body) ||
        Array.isArray(body)
      ) {
        const iterator = (async function* () {
          for await (const item of body) {
            if (
              !(0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "isObject"
              ])(item) ||
              !("index" in item) ||
              typeof item.index !== "number"
            ) {
              throw new TypeError("Invalid batch response", {
                cause: item,
              });
            }
            yield {
              index: item.index,
              status: item.status ?? response.status,
              headers: item.headers ?? {},
              body: item.body,
            };
          }
        })();
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "AsyncIteratorClass"
        ](
          () => iterator.next(),
          async (reason) => {
            if (
              reason !== "next" &&
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "isAsyncIteratorObject"
              ])(body)
            ) {
              await body.return?.();
            }
          },
        );
      }
      throw new TypeError("Invalid batch response", {
        cause: response,
      });
    }
  },
  "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "C",
      () => ContractProcedure,
      "V",
      () => ValidationError,
      "i",
      () => isContractProcedure,
      "m",
      () => mergeErrorMap,
      "v",
      () => validateORPCError,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__f__as__fallbackORPCErrorStatus$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export f as fallbackORPCErrorStatus>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export c as ORPCError>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__d__as__isORPCErrorStatus$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export d as isORPCErrorStatus>",
      );
    class ValidationError extends Error {
      issues;
      data;
      constructor(options) {
        super(options.message, options);
        this.issues = options.issues;
        this.data = options.data;
      }
    }
    function mergeErrorMap(errorMap1, errorMap2) {
      return {
        ...errorMap1,
        ...errorMap2,
      };
    }
    async function validateORPCError(map, error) {
      const { code, status, message, data, cause, defined } = error;
      const config = map?.[error.code];
      if (
        !config ||
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__f__as__fallbackORPCErrorStatus$3e$__[
          "fallbackORPCErrorStatus"
        ])(error.code, config.status) !== error.status
      ) {
        return defined
          ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
              "ORPCError"
            ](code, {
              defined: false,
              status,
              message,
              data,
              cause,
            })
          : error;
      }
      if (!config.data) {
        return defined
          ? error
          : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
              "ORPCError"
            ](code, {
              defined: true,
              status,
              message,
              data,
              cause,
            });
      }
      const validated = await config.data["~standard"].validate(error.data);
      if (validated.issues) {
        return defined
          ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
              "ORPCError"
            ](code, {
              defined: false,
              status,
              message,
              data,
              cause,
            })
          : error;
      }
      return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
        "ORPCError"
      ](code, {
        defined: true,
        status,
        message,
        data: validated.value,
        cause,
      });
    }
    class ContractProcedure {
      /**
       * This property holds the defined options for the contract procedure.
       */ "~orpc";
      constructor(def) {
        if (
          def.route?.successStatus &&
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__d__as__isORPCErrorStatus$3e$__[
            "isORPCErrorStatus"
          ])(def.route.successStatus)
        ) {
          throw new Error("[ContractProcedure] Invalid successStatus.");
        }
        if (
          Object.values(def.errorMap).some(
            (val) =>
              val &&
              val.status &&
              !(0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__d__as__isORPCErrorStatus$3e$__[
                "isORPCErrorStatus"
              ])(val.status),
          )
        ) {
          throw new Error("[ContractProcedure] Invalid error status code.");
        }
        this["~orpc"] = def;
      }
    }
    function isContractProcedure(item) {
      if (item instanceof ContractProcedure) {
        return true;
      }
      return (
        (typeof item === "object" || typeof item === "function") &&
        item !== null &&
        "~orpc" in item &&
        typeof item["~orpc"] === "object" &&
        item["~orpc"] !== null &&
        "errorMap" in item["~orpc"] &&
        "route" in item["~orpc"] &&
        "meta" in item["~orpc"]
      );
    }
  },
  "[project]/node_modules/@orpc/contract/dist/index.mjs [app-route] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "ContractBuilder",
      () => ContractBuilder,
      "enhanceContractRouter",
      () => enhanceContractRouter,
      "enhanceRoute",
      () => enhanceRoute,
      "eventIterator",
      () => eventIterator,
      "fallbackContractConfig",
      () => fallbackContractConfig,
      "getContractRouter",
      () => getContractRouter,
      "getEventIteratorSchemaDetails",
      () => getEventIteratorSchemaDetails,
      "inferRPCMethodFromContractRouter",
      () => inferRPCMethodFromContractRouter,
      "isSchemaIssue",
      () => isSchemaIssue,
      "mergeMeta",
      () => mergeMeta,
      "mergePrefix",
      () => mergePrefix,
      "mergeRoute",
      () => mergeRoute,
      "mergeTags",
      () => mergeTags,
      "minifyContractRouter",
      () => minifyContractRouter,
      "oc",
      () => oc,
      "populateContractRouterPaths",
      () => populateContractRouterPaths,
      "prefixRoute",
      () => prefixRoute,
      "type",
      () => type,
      "unshiftTagRoute",
      () => unshiftTagRoute,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$adapters$2f$standard$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/adapters/standard/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__t__as__toHttpPath$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-route] (ecmascript) <export t as toHttpPath>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__m__as__mapEventIterator$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs [app-route] (ecmascript) <export m as mapEventIterator>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export c as ORPCError>",
      );
    function mergeMeta(meta1, meta2) {
      return {
        ...meta1,
        ...meta2,
      };
    }
    function mergeRoute(a, b) {
      return {
        ...a,
        ...b,
      };
    }
    function prefixRoute(route, prefix) {
      if (!route.path) {
        return route;
      }
      return {
        ...route,
        path: `${prefix}${route.path}`,
      };
    }
    function unshiftTagRoute(route, tags) {
      return {
        ...route,
        tags: [...tags, ...(route.tags ?? [])],
      };
    }
    function mergePrefix(a, b) {
      return a ? `${a}${b}` : b;
    }
    function mergeTags(a, b) {
      return a ? [...a, ...b] : b;
    }
    function enhanceRoute(route, options) {
      let router = route;
      if (options.prefix) {
        router = prefixRoute(router, options.prefix);
      }
      if (options.tags?.length) {
        router = unshiftTagRoute(router, options.tags);
      }
      return router;
    }
    function getContractRouter(router, path) {
      let current = router;
      for (let i = 0; i < path.length; i++) {
        const segment = path[i];
        if (!current) {
          return void 0;
        }
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "i"
          ])(current)
        ) {
          return void 0;
        }
        current = current[segment];
      }
      return current;
    }
    function enhanceContractRouter(router, options) {
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "i"
        ])(router)
      ) {
        const enhanced2 =
          new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "C"
          ]({
            ...router["~orpc"],
            errorMap: (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "m"
            ])(options.errorMap, router["~orpc"].errorMap),
            route: enhanceRoute(router["~orpc"].route, options),
          });
        return enhanced2;
      }
      const enhanced = {};
      for (const key in router) {
        enhanced[key] = enhanceContractRouter(router[key], options);
      }
      return enhanced;
    }
    function minifyContractRouter(router) {
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "i"
        ])(router)
      ) {
        const procedure = {
          "~orpc": {
            errorMap: {},
            meta: router["~orpc"].meta,
            route: router["~orpc"].route,
          },
        };
        return procedure;
      }
      const json = {};
      for (const key in router) {
        json[key] = minifyContractRouter(router[key]);
      }
      return json;
    }
    function populateContractRouterPaths(router, options = {}) {
      const path = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "toArray"
      ])(options.path);
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "i"
        ])(router)
      ) {
        if (router["~orpc"].route.path === void 0) {
          return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "C"
          ]({
            ...router["~orpc"],
            route: {
              ...router["~orpc"].route,
              path: (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__t__as__toHttpPath$3e$__[
                "toHttpPath"
              ])(path),
            },
          });
        }
        return router;
      }
      const populated = {};
      for (const key in router) {
        populated[key] = populateContractRouterPaths(router[key], {
          ...options,
          path: [...path, key],
        });
      }
      return populated;
    }
    class ContractBuilder
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "C"
      ]
    {
      constructor(def) {
        super(def);
        this["~orpc"].prefix = def.prefix;
        this["~orpc"].tags = def.tags;
      }
      /**
       * Sets or overrides the initial meta.
       *
       * @see {@link https://orpc.dev/docs/metadata Metadata Docs}
       */ $meta(initialMeta) {
        return new ContractBuilder({
          ...this["~orpc"],
          meta: initialMeta,
        });
      }
      /**
       * Sets or overrides the initial route.
       * This option is typically relevant when integrating with OpenAPI.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}
       * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
       */ $route(initialRoute) {
        return new ContractBuilder({
          ...this["~orpc"],
          route: initialRoute,
        });
      }
      /**
       * Sets or overrides the initial input schema.
       *
       * @see {@link https://orpc.dev/docs/procedure#initial-configuration Initial Procedure Configuration Docs}
       */ $input(initialInputSchema) {
        return new ContractBuilder({
          ...this["~orpc"],
          inputSchema: initialInputSchema,
        });
      }
      /**
       * Adds type-safe custom errors to the contract.
       * The provided errors are spared-merged with any existing errors in the contract.
       *
       * @see {@link https://orpc.dev/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
       */ errors(errors) {
        return new ContractBuilder({
          ...this["~orpc"],
          errorMap: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "m"
          ])(this["~orpc"].errorMap, errors),
        });
      }
      /**
       * Sets or updates the metadata for the contract.
       * The provided metadata is spared-merged with any existing metadata in the contract.
       *
       * @see {@link https://orpc.dev/docs/metadata Metadata Docs}
       */ meta(meta) {
        return new ContractBuilder({
          ...this["~orpc"],
          meta: mergeMeta(this["~orpc"].meta, meta),
        });
      }
      /**
       * Sets or updates the route definition for the contract.
       * The provided route is spared-merged with any existing route in the contract.
       * This option is typically relevant when integrating with OpenAPI.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}
       * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
       */ route(route) {
        return new ContractBuilder({
          ...this["~orpc"],
          route: mergeRoute(this["~orpc"].route, route),
        });
      }
      /**
       * Defines the input validation schema for the contract.
       *
       * @see {@link https://orpc.dev/docs/procedure#input-output-validation Input Validation Docs}
       */ input(schema) {
        return new ContractBuilder({
          ...this["~orpc"],
          inputSchema: schema,
        });
      }
      /**
       * Defines the output validation schema for the contract.
       *
       * @see {@link https://orpc.dev/docs/procedure#input-output-validation Output Validation Docs}
       */ output(schema) {
        return new ContractBuilder({
          ...this["~orpc"],
          outputSchema: schema,
        });
      }
      /**
       * Prefixes all procedures in the contract router.
       * The provided prefix is post-appended to any existing router prefix.
       *
       * @note This option does not affect procedures that do not define a path in their route definition.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}
       */ prefix(prefix) {
        return new ContractBuilder({
          ...this["~orpc"],
          prefix: mergePrefix(this["~orpc"].prefix, prefix),
        });
      }
      /**
       * Adds tags to all procedures in the contract router.
       * This helpful when you want to group procedures together in the OpenAPI specification.
       *
       * @see {@link https://orpc.dev/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}
       */ tag(...tags) {
        return new ContractBuilder({
          ...this["~orpc"],
          tags: mergeTags(this["~orpc"].tags, tags),
        });
      }
      /**
       * Applies all of the previously defined options to the specified contract router.
       *
       * @see {@link https://orpc.dev/docs/router#extending-router Extending Router Docs}
       */ router(router) {
        return enhanceContractRouter(router, this["~orpc"]);
      }
    }
    const oc = new ContractBuilder({
      errorMap: {},
      route: {},
      meta: {},
    });
    const DEFAULT_CONFIG = {
      defaultMethod: "POST",
      defaultSuccessStatus: 200,
      defaultSuccessDescription: "OK",
      defaultInputStructure: "compact",
      defaultOutputStructure: "compact",
    };
    function fallbackContractConfig(key, value) {
      if (value === void 0) {
        return DEFAULT_CONFIG[key];
      }
      return value;
    }
    const EVENT_ITERATOR_DETAILS_SYMBOL = Symbol("ORPC_EVENT_ITERATOR_DETAILS");
    function eventIterator(yields, returns) {
      return {
        "~standard": {
          [EVENT_ITERATOR_DETAILS_SYMBOL]: {
            yields,
            returns,
          },
          vendor: "orpc",
          version: 1,
          validate(iterator) {
            if (
              !(0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "isAsyncIteratorObject"
              ])(iterator)
            ) {
              return {
                issues: [
                  {
                    message: "Expect event iterator",
                    path: [],
                  },
                ],
              };
            }
            const mapped = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__m__as__mapEventIterator$3e$__[
              "mapEventIterator"
            ])(iterator, {
              async value(value, done) {
                const schema = done ? returns : yields;
                if (!schema) {
                  return value;
                }
                const result = await schema["~standard"].validate(value);
                if (result.issues) {
                  throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
                    "ORPCError"
                  ]("EVENT_ITERATOR_VALIDATION_FAILED", {
                    message: "Event iterator validation failed",
                    cause:
                      new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                        "V"
                      ]({
                        issues: result.issues,
                        message: "Event iterator validation failed",
                        data: value,
                      }),
                  });
                }
                return result.value;
              },
              error: async (error) => error,
            });
            return {
              value: mapped,
            };
          },
        },
      };
    }
    function getEventIteratorSchemaDetails(schema) {
      if (schema === void 0) {
        return void 0;
      }
      return schema["~standard"][EVENT_ITERATOR_DETAILS_SYMBOL];
    }
    function inferRPCMethodFromContractRouter(contract) {
      return (_, path) => {
        const procedure = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "get"
        ])(contract, path);
        if (
          !(0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "i"
          ])(procedure)
        ) {
          throw new Error(
            `[inferRPCMethodFromContractRouter] No valid procedure found at path "${path.join(".")}". This may happen when the contract router is not properly configured.`,
          );
        }
        const method = fallbackContractConfig("defaultMethod", procedure["~orpc"].route.method);
        return method === "HEAD" ? "GET" : method;
      };
    }
    function type(...[map]) {
      return {
        "~standard": {
          vendor: "custom",
          version: 1,
          async validate(value) {
            if (map) {
              return {
                value: await map(value),
              };
            }
            return {
              value,
            };
          },
        },
      };
    }
    function isSchemaIssue(issue) {
      if (
        !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "isTypescriptObject"
        ])(issue) ||
        typeof issue.message !== "string"
      ) {
        return false;
      }
      if (issue.path !== void 0) {
        if (!Array.isArray(issue.path)) {
          return false;
        }
        if (
          !issue.path.every(
            (segment) =>
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "isPropertyKey"
              ])(segment) ||
              ((0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "isTypescriptObject"
              ])(segment) &&
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "isPropertyKey"
                ])(segment.key)),
          )
        ) {
          return false;
        }
      }
      return true;
    }
  },
  "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript) <export m as mergeErrorMap>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "mergeErrorMap",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "m"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript) <export i as isContractProcedure>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "isContractProcedure",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "i"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript) <export v as validateORPCError>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "validateORPCError",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "v"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript) <export V as ValidationError>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "ValidationError",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "V"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/@orpc/standard-server-fetch/dist/index.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "toEventIterator",
      () => toEventIterator,
      "toEventStream",
      () => toEventStream,
      "toFetchBody",
      () => toFetchBody,
      "toFetchHeaders",
      () => toFetchHeaders,
      "toFetchRequest",
      () => toFetchRequest,
      "toFetchResponse",
      () => toFetchResponse,
      "toStandardBody",
      () => toStandardBody,
      "toStandardHeaders",
      () => toStandardHeaders,
      "toStandardLazyRequest",
      () => toStandardLazyRequest,
      "toStandardLazyResponse",
      () => toStandardLazyResponse,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-route] (ecmascript)",
      );
    function toEventIterator(stream, options = {}) {
      const eventStream = stream
        ?.pipeThrough(new TextDecoderStream())
        .pipeThrough(
          new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "EventDecoderStream"
          ](),
        );
      const reader = eventStream?.getReader();
      let span;
      let isCancelled = false;
      return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "AsyncIteratorClass"
      ](
        async () => {
          span ??= (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "startSpan"
          ])("consume_event_iterator_stream");
          try {
            while (true) {
              if (reader === void 0) {
                return {
                  done: true,
                  value: void 0,
                };
              }
              const { done, value: value1 } = await (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "runInSpanContext"
              ])(span, () => reader.read());
              if (done) {
                if (isCancelled) {
                  throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "AbortError"
                  ]("Stream was cancelled");
                }
                return {
                  done: true,
                  value: void 0,
                };
              }
              switch (value1.event) {
                case "message": {
                  let message = (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "parseEmptyableJSON"
                  ])(value1.data);
                  if (
                    (0,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                      "isTypescriptObject"
                    ])(message)
                  ) {
                    message = (0,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                      "withEventMeta"
                    ])(message, value1);
                  }
                  span?.addEvent("message");
                  return {
                    done: false,
                    value: message,
                  };
                }
                case "error": {
                  let error =
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                      "ErrorEvent"
                    ]({
                      data: (0,
                      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                        "parseEmptyableJSON"
                      ])(value1.data),
                    });
                  error = (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                    "withEventMeta"
                  ])(error, value1);
                  span?.addEvent("error");
                  throw error;
                }
                case "done": {
                  let done2 = (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "parseEmptyableJSON"
                  ])(value1.data);
                  if (
                    (0,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                      "isTypescriptObject"
                    ])(done2)
                  ) {
                    done2 = (0,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                      "withEventMeta"
                    ])(done2, value1);
                  }
                  span?.addEvent("done");
                  return {
                    done: true,
                    value: done2,
                  };
                }
                default: {
                  span?.addEvent("maybe_keepalive");
                }
              }
            }
          } catch (e) {
            if (
              !(
                e instanceof
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                  "ErrorEvent"
                ]
              )
            ) {
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "setSpanError"
              ])(span, e, options);
            }
            throw e;
          }
        },
        async (reason) => {
          try {
            if (reason !== "next") {
              isCancelled = true;
              span?.addEvent("cancelled");
            }
            await (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "runInSpanContext"
            ])(span, () => reader?.cancel());
          } catch (e) {
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "setSpanError"
            ])(span, e, options);
            throw e;
          } finally {
            span?.end();
          }
        },
      );
    }
    function toEventStream(iterator, options = {}) {
      const keepAliveEnabled = options.eventIteratorKeepAliveEnabled ?? true;
      const keepAliveInterval = options.eventIteratorKeepAliveInterval ?? 5e3;
      const keepAliveComment = options.eventIteratorKeepAliveComment ?? "";
      const initialCommentEnabled = options.eventIteratorInitialCommentEnabled ?? true;
      const initialComment = options.eventIteratorInitialComment ?? "";
      let cancelled = false;
      let timeout;
      let span;
      const stream = new ReadableStream({
        start(controller) {
          span = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "startSpan"
          ])("stream_event_iterator");
          if (initialCommentEnabled) {
            controller.enqueue(
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "encodeEventMessage"
              ])({
                comments: [initialComment],
              }),
            );
          }
        },
        async pull(controller) {
          try {
            if (keepAliveEnabled) {
              timeout = setInterval(() => {
                controller.enqueue(
                  (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                    "encodeEventMessage"
                  ])({
                    comments: [keepAliveComment],
                  }),
                );
                span?.addEvent("keepalive");
              }, keepAliveInterval);
            }
            const value1 = await (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "runInSpanContext"
            ])(span, () => iterator.next());
            clearInterval(timeout);
            if (cancelled) {
              return;
            }
            const meta = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "getEventMeta"
            ])(value1.value);
            if (!value1.done || value1.value !== void 0 || meta !== void 0) {
              const event = value1.done ? "done" : "message";
              controller.enqueue(
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                  "encodeEventMessage"
                ])({
                  ...meta,
                  event,
                  data: (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "stringifyJSON"
                  ])(value1.value),
                }),
              );
              span?.addEvent(event);
            }
            if (value1.done) {
              controller.close();
              span?.end();
            }
          } catch (err) {
            clearInterval(timeout);
            if (cancelled) {
              return;
            }
            if (
              err instanceof
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "ErrorEvent"
              ]
            ) {
              controller.enqueue(
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                  "encodeEventMessage"
                ])({
                  ...(0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                    "getEventMeta"
                  ])(err),
                  event: "error",
                  data: (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "stringifyJSON"
                  ])(err.data),
                }),
              );
              span?.addEvent("error");
              controller.close();
            } else {
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "setSpanError"
              ])(span, err);
              controller.error(err);
            }
            span?.end();
          }
        },
        async cancel() {
          try {
            cancelled = true;
            clearInterval(timeout);
            span?.addEvent("cancelled");
            await (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "runInSpanContext"
            ])(span, () => iterator.return?.());
          } catch (e) {
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "setSpanError"
            ])(span, e);
            throw e;
          } finally {
            span?.end();
          }
        },
      }).pipeThrough(new TextEncoderStream());
      return stream;
    }
    function toStandardBody(re, options = {}) {
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "runWithSpan"
      ])(
        {
          name: "parse_standard_body",
          signal: options.signal,
        },
        async () => {
          const contentDisposition = re.headers.get("content-disposition");
          if (typeof contentDisposition === "string") {
            const fileName =
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "getFilenameFromContentDisposition"
              ])(contentDisposition) ?? "blob";
            const blob2 = await re.blob();
            return new File([blob2], fileName, {
              type: blob2.type,
            });
          }
          const contentType = re.headers.get("content-type");
          if (!contentType || contentType.startsWith("application/json")) {
            const text = await re.text();
            return (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "parseEmptyableJSON"
            ])(text);
          }
          if (contentType.startsWith("multipart/form-data")) {
            return await re.formData();
          }
          if (contentType.startsWith("application/x-www-form-urlencoded")) {
            const text = await re.text();
            return new URLSearchParams(text);
          }
          if (contentType.startsWith("text/event-stream")) {
            return toEventIterator(re.body, options);
          }
          if (contentType.startsWith("text/plain")) {
            return await re.text();
          }
          const blob = await re.blob();
          return new File([blob], "blob", {
            type: blob.type,
          });
        },
      );
    }
    function toFetchBody(body, headers, options = {}) {
      const currentContentDisposition = headers.get("content-disposition");
      headers.delete("content-type");
      headers.delete("content-disposition");
      if (body === void 0) {
        return void 0;
      }
      if (body instanceof Blob) {
        headers.set("content-type", body.type);
        headers.set("content-length", body.size.toString());
        headers.set(
          "content-disposition",
          currentContentDisposition ??
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "generateContentDisposition"
            ])(body instanceof File ? body.name : "blob"),
        );
        return body;
      }
      if (body instanceof FormData) {
        return body;
      }
      if (body instanceof URLSearchParams) {
        return body;
      }
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "isAsyncIteratorObject"
        ])(body)
      ) {
        headers.set("content-type", "text/event-stream");
        return toEventStream(body, options);
      }
      headers.set("content-type", "application/json");
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "stringifyJSON"
      ])(body);
    }
    function toStandardHeaders(headers, standardHeaders = {}) {
      headers.forEach((value1, key) => {
        if (Array.isArray(standardHeaders[key])) {
          standardHeaders[key].push(value1);
        } else if (standardHeaders[key] !== void 0) {
          standardHeaders[key] = [standardHeaders[key], value1];
        } else {
          standardHeaders[key] = value1;
        }
      });
      return standardHeaders;
    }
    function toFetchHeaders(headers, fetchHeaders = new Headers()) {
      for (const [key, value1] of Object.entries(headers)) {
        if (Array.isArray(value1)) {
          for (const v of value1) {
            fetchHeaders.append(key, v);
          }
        } else if (value1 !== void 0) {
          fetchHeaders.append(key, value1);
        }
      }
      return fetchHeaders;
    }
    function toStandardLazyRequest(request) {
      return {
        url: new URL(request.url),
        signal: request.signal,
        method: request.method,
        body: (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "once"
        ])(() =>
          toStandardBody(request, {
            signal: request.signal,
          }),
        ),
        get headers() {
          const headers = toStandardHeaders(request.headers);
          Object.defineProperty(this, "headers", {
            value: headers,
            writable: true,
          });
          return headers;
        },
        set headers(value) {
          Object.defineProperty(this, "headers", {
            value,
            writable: true,
          });
        },
      };
    }
    function toFetchRequest(request, options = {}) {
      const headers = toFetchHeaders(request.headers);
      const body = toFetchBody(request.body, headers, options);
      return new Request(request.url, {
        signal: request.signal,
        method: request.method,
        headers,
        body,
      });
    }
    function toFetchResponse(response, options = {}) {
      const headers = toFetchHeaders(response.headers);
      const body = toFetchBody(response.body, headers, options);
      return new Response(body, {
        headers,
        status: response.status,
      });
    }
    function toStandardLazyResponse(response, options = {}) {
      return {
        body: (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "once"
        ])(() => toStandardBody(response, options)),
        status: response.status,
        get headers() {
          const headers = toStandardHeaders(response.headers);
          Object.defineProperty(this, "headers", {
            value: headers,
            writable: true,
          });
          return headers;
        },
        set headers(value) {
          Object.defineProperty(this, "headers", {
            value,
            writable: true,
          });
        },
      };
    }
  },
  "[project]/node_modules/@orpc/server/dist/shared/server.Ds4HPpvH.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "L",
      () => LAZY_SYMBOL,
      "P",
      () => Procedure,
      "a",
      () => createContractedProcedure,
      "b",
      () => addMiddleware,
      "c",
      () => createProcedureClient,
      "d",
      () => isLazy,
      "e",
      () => enhanceRouter,
      "f",
      () => createAssertedLazyProcedure,
      "g",
      () => getRouter,
      "h",
      () => createORPCErrorConstructorMap,
      "i",
      () => isProcedure,
      "j",
      () => getLazyMeta,
      "k",
      () => middlewareOutputFn,
      "l",
      () => lazy,
      "m",
      () => mergeCurrentContext,
      "n",
      () => isStartWithMiddlewares,
      "o",
      () => mergeMiddlewares,
      "p",
      () => call,
      "q",
      () => getHiddenRouterContract,
      "r",
      () => createAccessibleLazyRouter,
      "s",
      () => setHiddenRouterContract,
      "t",
      () => traverseContractProcedures,
      "u",
      () => unlazy,
      "v",
      () => resolveContractProcedures,
      "w",
      () => unlazyRouter,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__i__as__isContractProcedure$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript) <export i as isContractProcedure>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__v__as__validateORPCError$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript) <export v as validateORPCError>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__V__as__ValidationError$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript) <export V as ValidationError>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__m__as__mergeErrorMap$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript) <export m as mergeErrorMap>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export c as ORPCError>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__m__as__mapEventIterator$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs [app-route] (ecmascript) <export m as mapEventIterator>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-route] (ecmascript)",
      );
    const LAZY_SYMBOL = Symbol("ORPC_LAZY_SYMBOL");
    function lazy(loader, meta = {}) {
      return {
        [LAZY_SYMBOL]: {
          loader,
          meta,
        },
      };
    }
    function isLazy(item) {
      return (
        (typeof item === "object" || typeof item === "function") &&
        item !== null &&
        LAZY_SYMBOL in item
      );
    }
    function getLazyMeta(lazied) {
      return lazied[LAZY_SYMBOL].meta;
    }
    function unlazy(lazied) {
      return isLazy(lazied)
        ? lazied[LAZY_SYMBOL].loader()
        : Promise.resolve({
            default: lazied,
          });
    }
    function isStartWithMiddlewares(middlewares, compare) {
      if (compare.length > middlewares.length) {
        return false;
      }
      for (let i = 0; i < middlewares.length; i++) {
        if (compare[i] === void 0) {
          return true;
        }
        if (middlewares[i] !== compare[i]) {
          return false;
        }
      }
      return true;
    }
    function mergeMiddlewares(first, second, options) {
      if (options.dedupeLeading && isStartWithMiddlewares(second, first)) {
        return second;
      }
      return [...first, ...second];
    }
    function addMiddleware(middlewares, addition) {
      return [...middlewares, addition];
    }
    class Procedure {
      /**
       * This property holds the defined options.
       */ "~orpc";
      constructor(def) {
        this["~orpc"] = def;
      }
    }
    function isProcedure(item) {
      if (item instanceof Procedure) {
        return true;
      }
      return (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__i__as__isContractProcedure$3e$__[
          "isContractProcedure"
        ])(item) &&
        "middlewares" in item["~orpc"] &&
        "inputValidationIndex" in item["~orpc"] &&
        "outputValidationIndex" in item["~orpc"] &&
        "handler" in item["~orpc"]
      );
    }
    function mergeCurrentContext(context, other) {
      return {
        ...context,
        ...other,
      };
    }
    function createORPCErrorConstructorMap(errors) {
      const proxy = new Proxy(errors, {
        get(target, code) {
          if (typeof code !== "string") {
            return Reflect.get(target, code);
          }
          const item = (...rest) => {
            const options = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "resolveMaybeOptionalOptions"
            ])(rest);
            const config = errors[code];
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
              "ORPCError"
            ](code, {
              defined: Boolean(config),
              status: config?.status,
              message: options.message ?? config?.message,
              data: options.data,
              cause: options.cause,
            });
          };
          return item;
        },
      });
      return proxy;
    }
    function middlewareOutputFn(output) {
      return {
        output,
        context: {},
      };
    }
    function createProcedureClient(lazyableProcedure, ...rest) {
      const options = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "resolveMaybeOptionalOptions"
      ])(rest);
      return async (...[input, callerOptions]) => {
        const path = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "toArray"
        ])(options.path);
        const { default: procedure } = await unlazy(lazyableProcedure);
        const clientContext = callerOptions?.context ?? {};
        const context = await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "value"
        ])(options.context ?? {}, clientContext);
        const errors = createORPCErrorConstructorMap(procedure["~orpc"].errorMap);
        const validateError = async (e) => {
          if (
            e instanceof
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
              "ORPCError"
            ]
          ) {
            return await (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__v__as__validateORPCError$3e$__[
              "validateORPCError"
            ])(procedure["~orpc"].errorMap, e);
          }
          return e;
        };
        try {
          const output = await (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "runWithSpan"
          ])(
            {
              name: "call_procedure",
              signal: callerOptions?.signal,
            },
            (span) => {
              span?.setAttribute("procedure.path", [...path]);
              return (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "intercept"
              ])(
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "toArray"
                ])(options.interceptors),
                {
                  context,
                  input,
                  // input only optional when it undefinable so we can safely cast it
                  errors,
                  path,
                  procedure,
                  signal: callerOptions?.signal,
                  lastEventId: callerOptions?.lastEventId,
                },
                (interceptorOptions) =>
                  executeProcedureInternal(interceptorOptions.procedure, interceptorOptions),
              );
            },
          );
          if (
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "isAsyncIteratorObject"
            ])(output)
          ) {
            if (
              output instanceof
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "HibernationEventIterator"
              ]
            ) {
              return output;
            }
            return (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "overlayProxy"
            ])(
              output,
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__m__as__mapEventIterator$3e$__[
                "mapEventIterator"
              ])(
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "asyncIteratorWithSpan"
                ])(
                  {
                    name: "consume_event_iterator_output",
                    signal: callerOptions?.signal,
                  },
                  output,
                ),
                {
                  value: (v) => v,
                  error: (e) => validateError(e),
                },
              ),
            );
          }
          return output;
        } catch (e) {
          throw await validateError(e);
        }
      };
    }
    async function validateInput(procedure, input) {
      const schema = procedure["~orpc"].inputSchema;
      if (!schema) {
        return input;
      }
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "runWithSpan"
      ])(
        {
          name: "validate_input",
        },
        async () => {
          const result = await schema["~standard"].validate(input);
          if (result.issues) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
              "ORPCError"
            ]("BAD_REQUEST", {
              message: "Input validation failed",
              data: {
                issues: result.issues,
              },
              cause:
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__V__as__ValidationError$3e$__[
                  "ValidationError"
                ]({
                  message: "Input validation failed",
                  issues: result.issues,
                  data: input,
                }),
            });
          }
          return result.value;
        },
      );
    }
    async function validateOutput(procedure, output) {
      const schema = procedure["~orpc"].outputSchema;
      if (!schema) {
        return output;
      }
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "runWithSpan"
      ])(
        {
          name: "validate_output",
        },
        async () => {
          const result = await schema["~standard"].validate(output);
          if (result.issues) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
              "ORPCError"
            ]("INTERNAL_SERVER_ERROR", {
              message: "Output validation failed",
              cause:
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__V__as__ValidationError$3e$__[
                  "ValidationError"
                ]({
                  message: "Output validation failed",
                  issues: result.issues,
                  data: output,
                }),
            });
          }
          return result.value;
        },
      );
    }
    async function executeProcedureInternal(procedure, options) {
      const middlewares = procedure["~orpc"].middlewares;
      const inputValidationIndex = Math.min(
        Math.max(0, procedure["~orpc"].inputValidationIndex),
        middlewares.length,
      );
      const outputValidationIndex = Math.min(
        Math.max(0, procedure["~orpc"].outputValidationIndex),
        middlewares.length,
      );
      const next = async (index, context, input) => {
        let currentInput = input;
        if (index === inputValidationIndex) {
          currentInput = await validateInput(procedure, currentInput);
        }
        const mid = middlewares[index];
        const output = mid
          ? await (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "runWithSpan"
            ])(
              {
                name: `middleware.${mid.name}`,
                signal: options.signal,
              },
              async (span) => {
                span?.setAttribute("middleware.index", index);
                span?.setAttribute("middleware.name", mid.name);
                const result = await mid(
                  {
                    ...options,
                    context,
                    next: async (...[nextOptions]) => {
                      const nextContext = nextOptions?.context ?? {};
                      return {
                        output: await next(
                          index + 1,
                          mergeCurrentContext(context, nextContext),
                          currentInput,
                        ),
                        context: nextContext,
                      };
                    },
                  },
                  currentInput,
                  middlewareOutputFn,
                );
                return result.output;
              },
            )
          : await (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "runWithSpan"
            ])(
              {
                name: "handler",
                signal: options.signal,
              },
              () =>
                procedure["~orpc"].handler({
                  ...options,
                  context,
                  input: currentInput,
                }),
            );
        if (index === outputValidationIndex) {
          return await validateOutput(procedure, output);
        }
        return output;
      };
      return next(0, options.context, options.input);
    }
    const HIDDEN_ROUTER_CONTRACT_SYMBOL = Symbol("ORPC_HIDDEN_ROUTER_CONTRACT");
    function setHiddenRouterContract(router, contract) {
      return new Proxy(router, {
        get(target, key) {
          if (key === HIDDEN_ROUTER_CONTRACT_SYMBOL) {
            return contract;
          }
          return Reflect.get(target, key);
        },
      });
    }
    function getHiddenRouterContract(router) {
      return router[HIDDEN_ROUTER_CONTRACT_SYMBOL];
    }
    function getRouter(router, path) {
      let current = router;
      for (let i = 0; i < path.length; i++) {
        const segment = path[i];
        if (!current) {
          return void 0;
        }
        if (isProcedure(current)) {
          return void 0;
        }
        if (!isLazy(current)) {
          current = current[segment];
          continue;
        }
        const lazied = current;
        const rest = path.slice(i);
        return lazy(async () => {
          const unwrapped = await unlazy(lazied);
          const next = getRouter(unwrapped.default, rest);
          return unlazy(next);
        }, getLazyMeta(lazied));
      }
      return current;
    }
    function createAccessibleLazyRouter(lazied) {
      const recursive = new Proxy(lazied, {
        get(target, key) {
          if (typeof key !== "string") {
            return Reflect.get(target, key);
          }
          const next = getRouter(lazied, [key]);
          return createAccessibleLazyRouter(next);
        },
      });
      return recursive;
    }
    function enhanceRouter(router, options) {
      if (isLazy(router)) {
        const laziedMeta = getLazyMeta(router);
        const enhancedPrefix = laziedMeta?.prefix
          ? (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "mergePrefix"
            ])(options.prefix, laziedMeta?.prefix)
          : options.prefix;
        const enhanced2 = lazy(
          async () => {
            const { default: unlaziedRouter } = await unlazy(router);
            const enhanced3 = enhanceRouter(unlaziedRouter, options);
            return unlazy(enhanced3);
          },
          {
            ...laziedMeta,
            prefix: enhancedPrefix,
          },
        );
        const accessible = createAccessibleLazyRouter(enhanced2);
        return accessible;
      }
      if (isProcedure(router)) {
        const newMiddlewares = mergeMiddlewares(options.middlewares, router["~orpc"].middlewares, {
          dedupeLeading: options.dedupeLeadingMiddlewares,
        });
        const newMiddlewareAdded = newMiddlewares.length - router["~orpc"].middlewares.length;
        const enhanced2 = new Procedure({
          ...router["~orpc"],
          route: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "enhanceRoute"
          ])(router["~orpc"].route, options),
          errorMap: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__m__as__mergeErrorMap$3e$__[
            "mergeErrorMap"
          ])(options.errorMap, router["~orpc"].errorMap),
          middlewares: newMiddlewares,
          inputValidationIndex: router["~orpc"].inputValidationIndex + newMiddlewareAdded,
          outputValidationIndex: router["~orpc"].outputValidationIndex + newMiddlewareAdded,
        });
        return enhanced2;
      }
      const enhanced = {};
      for (const key in router) {
        enhanced[key] = enhanceRouter(router[key], options);
      }
      return enhanced;
    }
    function traverseContractProcedures(options, callback, lazyOptions = []) {
      let currentRouter = options.router;
      const hiddenContract = getHiddenRouterContract(options.router);
      if (hiddenContract !== void 0) {
        currentRouter = hiddenContract;
      }
      if (isLazy(currentRouter)) {
        lazyOptions.push({
          router: currentRouter,
          path: options.path,
        });
      } else if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__i__as__isContractProcedure$3e$__[
          "isContractProcedure"
        ])(currentRouter)
      ) {
        callback({
          contract: currentRouter,
          path: options.path,
        });
      } else {
        for (const key in currentRouter) {
          traverseContractProcedures(
            {
              router: currentRouter[key],
              path: [...options.path, key],
            },
            callback,
            lazyOptions,
          );
        }
      }
      return lazyOptions;
    }
    async function resolveContractProcedures(options, callback) {
      const pending = [options];
      for (const options2 of pending) {
        const lazyOptions = traverseContractProcedures(options2, callback);
        for (const options3 of lazyOptions) {
          const { default: router } = await unlazy(options3.router);
          pending.push({
            router,
            path: options3.path,
          });
        }
      }
    }
    async function unlazyRouter(router) {
      if (isProcedure(router)) {
        return router;
      }
      const unlazied = {};
      for (const key in router) {
        const item = router[key];
        const { default: unlaziedRouter } = await unlazy(item);
        unlazied[key] = await unlazyRouter(unlaziedRouter);
      }
      return unlazied;
    }
    function createAssertedLazyProcedure(lazied) {
      const lazyProcedure = lazy(async () => {
        const { default: maybeProcedure } = await unlazy(lazied);
        if (!isProcedure(maybeProcedure)) {
          throw new Error(`
            Expected a lazy<procedure> but got lazy<unknown>.
            This should be caught by TypeScript compilation.
            Please report this issue if this makes you feel uncomfortable.
        `);
        }
        return {
          default: maybeProcedure,
        };
      }, getLazyMeta(lazied));
      return lazyProcedure;
    }
    function createContractedProcedure(procedure, contract) {
      return new Procedure({
        ...procedure["~orpc"],
        errorMap: contract["~orpc"].errorMap,
        route: contract["~orpc"].route,
        meta: contract["~orpc"].meta,
      });
    }
    function call(procedure, input, ...rest) {
      const options = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "resolveMaybeOptionalOptions"
      ])(rest);
      return createProcedureClient(procedure, options)(input, options);
    }
  },
  "[project]/node_modules/@orpc/server/dist/index.mjs [app-route] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "Builder",
      () => Builder,
      "DecoratedProcedure",
      () => DecoratedProcedure,
      "createActionableClient",
      () => createActionableClient,
      "createRouterClient",
      () => createRouterClient,
      "decorateMiddleware",
      () => decorateMiddleware,
      "fallbackConfig",
      () => fallbackConfig,
      "implement",
      () => implement,
      "implementerInternal",
      () => implementerInternal,
      "inferRPCMethodFromRouter",
      () => inferRPCMethodFromRouter,
      "os",
      () => os,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__m__as__mergeErrorMap$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript) <export m as mergeErrorMap>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__i__as__isContractProcedure$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/shared/contract.D_dZrO__.mjs [app-route] (ecmascript) <export i as isContractProcedure>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/server/dist/shared/server.Ds4HPpvH.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__t__as__toORPCError$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export t as toORPCError>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-route] (ecmascript)",
      );
    const DEFAULT_CONFIG = {
      initialInputValidationIndex: 0,
      initialOutputValidationIndex: 0,
      dedupeLeadingMiddlewares: true,
    };
    function fallbackConfig(key, value) {
      if (value === void 0) {
        return DEFAULT_CONFIG[key];
      }
      return value;
    }
    function decorateMiddleware(middleware) {
      const decorated = (...args) => middleware(...args);
      decorated.mapInput = (mapInput) => {
        const mapped = decorateMiddleware((options, input, ...rest) =>
          middleware(options, mapInput(input), ...rest),
        );
        return mapped;
      };
      decorated.concat = (concatMiddleware, mapInput) => {
        const mapped = mapInput
          ? decorateMiddleware(concatMiddleware).mapInput(mapInput)
          : concatMiddleware;
        const concatted = decorateMiddleware((options, input, output, ...rest) => {
          const merged = middleware(
            {
              ...options,
              next: (...[nextOptions1]) =>
                mapped(
                  {
                    ...options,
                    context: {
                      ...options.context,
                      ...nextOptions1?.context,
                    },
                    next: (...[nextOptions2]) =>
                      options.next({
                        context: {
                          ...nextOptions1?.context,
                          ...nextOptions2?.context,
                        },
                      }),
                  },
                  input,
                  output,
                  ...rest,
                ),
            },
            input,
            output,
            ...rest,
          );
          return merged;
        });
        return concatted;
      };
      return decorated;
    }
    function createActionableClient(client) {
      const action = async (input) => {
        try {
          return [null, await client(input)];
        } catch (error) {
          if (
            error instanceof Error &&
            "digest" in error &&
            typeof error.digest === "string" &&
            error.digest.startsWith("NEXT_")
          ) {
            throw error;
          }
          if (
            (error instanceof Response &&
              "options" in error &&
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "isObject"
              ])(error.options)) ||
            ((0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "isObject"
            ])(error) &&
              error.isNotFound === true)
          ) {
            throw error;
          }
          return [
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__t__as__toORPCError$3e$__[
              "toORPCError"
            ])(error).toJSON(),
            void 0,
          ];
        }
      };
      return action;
    }
    class DecoratedProcedure
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "P"
      ]
    {
      /**
       * Adds type-safe custom errors.
       * The provided errors are spared-merged with any existing errors.
       *
       * @see {@link https://orpc.dev/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
       */ errors(errors) {
        return new DecoratedProcedure({
          ...this["~orpc"],
          errorMap: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__m__as__mergeErrorMap$3e$__[
            "mergeErrorMap"
          ])(this["~orpc"].errorMap, errors),
        });
      }
      /**
       * Sets or updates the metadata.
       * The provided metadata is spared-merged with any existing metadata.
       *
       * @see {@link https://orpc.dev/docs/metadata Metadata Docs}
       */ meta(meta) {
        return new DecoratedProcedure({
          ...this["~orpc"],
          meta: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "mergeMeta"
          ])(this["~orpc"].meta, meta),
        });
      }
      /**
       * Sets or updates the route definition.
       * The provided route is spared-merged with any existing route.
       * This option is typically relevant when integrating with OpenAPI.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}
       * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
       */ route(route) {
        return new DecoratedProcedure({
          ...this["~orpc"],
          route: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "mergeRoute"
          ])(this["~orpc"].route, route),
        });
      }
      use(middleware, mapInput) {
        const mapped = mapInput ? decorateMiddleware(middleware).mapInput(mapInput) : middleware;
        return new DecoratedProcedure({
          ...this["~orpc"],
          middlewares: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "b"
          ])(this["~orpc"].middlewares, mapped),
        });
      }
      /**
       * Make this procedure callable (works like a function while still being a procedure).
       *
       * @see {@link https://orpc.dev/docs/client/server-side Server-side Client Docs}
       */ callable(...rest) {
        const client = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "c"
        ])(this, ...rest);
        return new Proxy(client, {
          get: (target, key) => {
            return Reflect.has(this, key) ? Reflect.get(this, key) : Reflect.get(target, key);
          },
          has: (target, key) => {
            return Reflect.has(this, key) || Reflect.has(target, key);
          },
        });
      }
      /**
       * Make this procedure compatible with server action.
       *
       * @see {@link https://orpc.dev/docs/server-action Server Action Docs}
       */ actionable(...rest) {
        const action = createActionableClient(
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "c"
          ])(this, ...rest),
        );
        return new Proxy(action, {
          get: (target, key) => {
            return Reflect.has(this, key) ? Reflect.get(this, key) : Reflect.get(target, key);
          },
          has: (target, key) => {
            return Reflect.has(this, key) || Reflect.has(target, key);
          },
        });
      }
    }
    class Builder {
      /**
       * This property holds the defined options.
       */ "~orpc";
      constructor(def) {
        this["~orpc"] = def;
      }
      /**
       * Sets or overrides the config.
       *
       * @see {@link https://orpc.dev/docs/client/server-side#middlewares-order Middlewares Order Docs}
       * @see {@link https://orpc.dev/docs/best-practices/dedupe-middleware#configuration Dedupe Middleware Docs}
       */ $config(config) {
        const inputValidationCount =
          this["~orpc"].inputValidationIndex -
          fallbackConfig(
            "initialInputValidationIndex",
            this["~orpc"].config.initialInputValidationIndex,
          );
        const outputValidationCount =
          this["~orpc"].outputValidationIndex -
          fallbackConfig(
            "initialOutputValidationIndex",
            this["~orpc"].config.initialOutputValidationIndex,
          );
        return new Builder({
          ...this["~orpc"],
          config,
          dedupeLeadingMiddlewares: fallbackConfig(
            "dedupeLeadingMiddlewares",
            config.dedupeLeadingMiddlewares,
          ),
          inputValidationIndex:
            fallbackConfig("initialInputValidationIndex", config.initialInputValidationIndex) +
            inputValidationCount,
          outputValidationIndex:
            fallbackConfig("initialOutputValidationIndex", config.initialOutputValidationIndex) +
            outputValidationCount,
        });
      }
      /**
       * Set or override the initial context.
       *
       * @see {@link https://orpc.dev/docs/context Context Docs}
       */ $context() {
        return new Builder({
          ...this["~orpc"],
          middlewares: [],
          inputValidationIndex: fallbackConfig(
            "initialInputValidationIndex",
            this["~orpc"].config.initialInputValidationIndex,
          ),
          outputValidationIndex: fallbackConfig(
            "initialOutputValidationIndex",
            this["~orpc"].config.initialOutputValidationIndex,
          ),
        });
      }
      /**
       * Sets or overrides the initial meta.
       *
       * @see {@link https://orpc.dev/docs/metadata Metadata Docs}
       */ $meta(initialMeta) {
        return new Builder({
          ...this["~orpc"],
          meta: initialMeta,
        });
      }
      /**
       * Sets or overrides the initial route.
       * This option is typically relevant when integrating with OpenAPI.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}
       * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
       */ $route(initialRoute) {
        return new Builder({
          ...this["~orpc"],
          route: initialRoute,
        });
      }
      /**
       * Sets or overrides the initial input schema.
       *
       * @see {@link https://orpc.dev/docs/procedure#initial-configuration Initial Procedure Configuration Docs}
       */ $input(initialInputSchema) {
        return new Builder({
          ...this["~orpc"],
          inputSchema: initialInputSchema,
        });
      }
      /**
       * Creates a middleware.
       *
       * @see {@link https://orpc.dev/docs/middleware Middleware Docs}
       */ middleware(middleware) {
        return decorateMiddleware(middleware);
      }
      /**
       * Adds type-safe custom errors.
       * The provided errors are spared-merged with any existing errors.
       *
       * @see {@link https://orpc.dev/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
       */ errors(errors) {
        return new Builder({
          ...this["~orpc"],
          errorMap: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__m__as__mergeErrorMap$3e$__[
            "mergeErrorMap"
          ])(this["~orpc"].errorMap, errors),
        });
      }
      use(middleware, mapInput) {
        const mapped = mapInput ? decorateMiddleware(middleware).mapInput(mapInput) : middleware;
        return new Builder({
          ...this["~orpc"],
          middlewares: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "b"
          ])(this["~orpc"].middlewares, mapped),
        });
      }
      /**
       * Sets or updates the metadata.
       * The provided metadata is spared-merged with any existing metadata.
       *
       * @see {@link https://orpc.dev/docs/metadata Metadata Docs}
       */ meta(meta) {
        return new Builder({
          ...this["~orpc"],
          meta: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "mergeMeta"
          ])(this["~orpc"].meta, meta),
        });
      }
      /**
       * Sets or updates the route definition.
       * The provided route is spared-merged with any existing route.
       * This option is typically relevant when integrating with OpenAPI.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}
       * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
       */ route(route) {
        return new Builder({
          ...this["~orpc"],
          route: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "mergeRoute"
          ])(this["~orpc"].route, route),
        });
      }
      /**
       * Defines the input validation schema.
       *
       * @see {@link https://orpc.dev/docs/procedure#input-output-validation Input Validation Docs}
       */ input(schema) {
        return new Builder({
          ...this["~orpc"],
          inputSchema: schema,
          inputValidationIndex:
            fallbackConfig(
              "initialInputValidationIndex",
              this["~orpc"].config.initialInputValidationIndex,
            ) + this["~orpc"].middlewares.length,
        });
      }
      /**
       * Defines the output validation schema.
       *
       * @see {@link https://orpc.dev/docs/procedure#input-output-validation Output Validation Docs}
       */ output(schema) {
        return new Builder({
          ...this["~orpc"],
          outputSchema: schema,
          outputValidationIndex:
            fallbackConfig(
              "initialOutputValidationIndex",
              this["~orpc"].config.initialOutputValidationIndex,
            ) + this["~orpc"].middlewares.length,
        });
      }
      /**
       * Defines the handler of the procedure.
       *
       * @see {@link https://orpc.dev/docs/procedure Procedure Docs}
       */ handler(handler) {
        return new DecoratedProcedure({
          ...this["~orpc"],
          handler,
        });
      }
      /**
       * Prefixes all procedures in the router.
       * The provided prefix is post-appended to any existing router prefix.
       *
       * @note This option does not affect procedures that do not define a path in their route definition.
       *
       * @see {@link https://orpc.dev/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}
       */ prefix(prefix) {
        return new Builder({
          ...this["~orpc"],
          prefix: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "mergePrefix"
          ])(this["~orpc"].prefix, prefix),
        });
      }
      /**
       * Adds tags to all procedures in the router.
       * This helpful when you want to group procedures together in the OpenAPI specification.
       *
       * @see {@link https://orpc.dev/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}
       */ tag(...tags) {
        return new Builder({
          ...this["~orpc"],
          tags: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "mergeTags"
          ])(this["~orpc"].tags, tags),
        });
      }
      /**
       * Applies all of the previously defined options to the specified router.
       *
       * @see {@link https://orpc.dev/docs/router#extending-router Extending Router Docs}
       */ router(router) {
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "e"
        ])(router, this["~orpc"]);
      }
      /**
       * Create a lazy router
       * And applies all of the previously defined options to the specified router.
       *
       * @see {@link https://orpc.dev/docs/router#extending-router Extending Router Docs}
       */ lazy(loader) {
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "e"
        ])(
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "l"
          ])(loader),
          this["~orpc"],
        );
      }
    }
    const os = new Builder({
      config: {},
      route: {},
      meta: {},
      errorMap: {},
      inputValidationIndex: fallbackConfig("initialInputValidationIndex"),
      outputValidationIndex: fallbackConfig("initialOutputValidationIndex"),
      middlewares: [],
      dedupeLeadingMiddlewares: true,
    });
    function implementerInternal(contract, config, middlewares) {
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$shared$2f$contract$2e$D_dZrO_$5f2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__i__as__isContractProcedure$3e$__[
          "isContractProcedure"
        ])(contract)
      ) {
        const impl2 = new Builder({
          ...contract["~orpc"],
          config,
          middlewares,
          inputValidationIndex:
            fallbackConfig("initialInputValidationIndex", config?.initialInputValidationIndex) +
            middlewares.length,
          outputValidationIndex:
            fallbackConfig("initialOutputValidationIndex", config?.initialOutputValidationIndex) +
            middlewares.length,
          dedupeLeadingMiddlewares: fallbackConfig(
            "dedupeLeadingMiddlewares",
            config.dedupeLeadingMiddlewares,
          ),
        });
        return impl2;
      }
      const impl = new Proxy(contract, {
        get: (target, key) => {
          if (typeof key !== "string") {
            return Reflect.get(target, key);
          }
          let method;
          if (key === "middleware") {
            method = (mid) => decorateMiddleware(mid);
          } else if (key === "use") {
            method = (mid) => {
              return implementerInternal(
                contract,
                config,
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                  "b"
                ])(middlewares, mid),
              );
            };
          } else if (key === "router") {
            method = (router) => {
              const adapted = (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "e"
              ])(router, {
                middlewares,
                errorMap: {},
                prefix: void 0,
                tags: void 0,
                dedupeLeadingMiddlewares: fallbackConfig(
                  "dedupeLeadingMiddlewares",
                  config.dedupeLeadingMiddlewares,
                ),
              });
              return (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "s"
              ])(adapted, contract);
            };
          } else if (key === "lazy") {
            method = (loader) => {
              const adapted = (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "e"
              ])(
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                  "l"
                ])(loader),
                {
                  middlewares,
                  errorMap: {},
                  prefix: void 0,
                  tags: void 0,
                  dedupeLeadingMiddlewares: fallbackConfig(
                    "dedupeLeadingMiddlewares",
                    config.dedupeLeadingMiddlewares,
                  ),
                },
              );
              return (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "s"
              ])(adapted, contract);
            };
          }
          const next = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "getContractRouter"
          ])(target, [key]);
          if (!next) {
            return method ?? next;
          }
          const nextImpl = implementerInternal(next, config, middlewares);
          if (method) {
            return new Proxy(method, {
              get(_, key2) {
                return Reflect.get(nextImpl, key2);
              },
            });
          }
          return nextImpl;
        },
      });
      return impl;
    }
    function implement(contract, config = {}) {
      const implInternal = implementerInternal(contract, config, []);
      const impl = new Proxy(implInternal, {
        get: (target, key) => {
          let method;
          if (key === "$context") {
            method = () => impl;
          } else if (key === "$config") {
            method = (config2) => implement(contract, config2);
          }
          const next = Reflect.get(target, key);
          if (!method || !next || (typeof next !== "function" && typeof next !== "object")) {
            return method || next;
          }
          return new Proxy(method, {
            get(_, key2) {
              return Reflect.get(next, key2);
            },
          });
        },
      });
      return impl;
    }
    function inferRPCMethodFromRouter(router) {
      return async (_, path) => {
        const { default: procedure } = await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "u"
        ])(
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "g"
          ])(router, path),
        );
        if (
          !(0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "i"
          ])(procedure)
        ) {
          throw new Error(
            `[inferRPCMethodFromRouter] No valid procedure found at path "${path.join(".")}". This may happen when the router is not properly configured.`,
          );
        }
        const method = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "fallbackContractConfig"
        ])("defaultMethod", procedure["~orpc"].route.method);
        return method === "HEAD" ? "GET" : method;
      };
    }
    function createRouterClient(router, ...rest) {
      const options = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "resolveMaybeOptionalOptions"
      ])(rest);
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "i"
        ])(router)
      ) {
        const caller = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "c"
        ])(router, options);
        return caller;
      }
      const procedureCaller = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "d"
      ])(router)
        ? (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "c"
          ])(
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "f"
            ])(router),
            options,
          )
        : {};
      const recursive = new Proxy(procedureCaller, {
        get(target, key) {
          if (typeof key !== "string") {
            return Reflect.get(target, key);
          }
          const next = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "g"
          ])(router, [key]);
          if (!next) {
            return Reflect.get(target, key);
          }
          return createRouterClient(next, {
            ...rest[0],
            path: [...(rest[0]?.path ?? []), key],
          });
        },
      });
      return recursive;
    }
  },
  "[project]/node_modules/@orpc/server/dist/shared/server.DZ5BIITo.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["r", () => resolveFriendlyStandardHandleOptions]);
    function resolveFriendlyStandardHandleOptions(options) {
      return {
        ...options,
        context: options.context ?? {},
      };
    }
  },
  "[project]/node_modules/@orpc/server/dist/shared/server.Bxx6tqNe.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "C",
      () => CompositeStandardHandlerPlugin,
      "S",
      () => StandardHandler,
      "a",
      () => StandardRPCCodec,
      "b",
      () => StandardRPCHandler,
      "c",
      () => StandardRPCMatcher,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$adapters$2f$standard$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/adapters/standard/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__t__as__toHttpPath$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-route] (ecmascript) <export t as toHttpPath>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__b__as__StandardRPCJsonSerializer$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-route] (ecmascript) <export b as StandardRPCJsonSerializer>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__e__as__StandardRPCSerializer$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-route] (ecmascript) <export e as StandardRPCSerializer>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export c as ORPCError>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__t__as__toORPCError$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export t as toORPCError>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/server/dist/shared/server.Ds4HPpvH.mjs [app-route] (ecmascript)",
      );
    class CompositeStandardHandlerPlugin {
      plugins;
      constructor(plugins = []) {
        this.plugins = [...plugins].sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
      }
      init(options, router) {
        for (const plugin of this.plugins) {
          plugin.init?.(options, router);
        }
      }
    }
    class StandardHandler {
      constructor(router, matcher, codec, options) {
        this.matcher = matcher;
        this.codec = codec;
        const plugins = new CompositeStandardHandlerPlugin(options.plugins);
        plugins.init(options, router);
        this.interceptors = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "toArray"
        ])(options.interceptors);
        this.clientInterceptors = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "toArray"
        ])(options.clientInterceptors);
        this.rootInterceptors = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "toArray"
        ])(options.rootInterceptors);
        this.matcher.init(router);
      }
      interceptors;
      clientInterceptors;
      rootInterceptors;
      async handle(request, options) {
        const prefix = options.prefix?.replace(/\/$/, "") || void 0;
        if (
          prefix &&
          !request.url.pathname.startsWith(`${prefix}/`) &&
          request.url.pathname !== prefix
        ) {
          return {
            matched: false,
            response: void 0,
          };
        }
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "intercept"
        ])(
          this.rootInterceptors,
          {
            ...options,
            request,
            prefix,
          },
          async (interceptorOptions) => {
            return (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "runWithSpan"
            ])(
              {
                name: `${request.method} ${request.url.pathname}`,
              },
              async (span) => {
                let step;
                try {
                  return await (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "intercept"
                  ])(
                    this.interceptors,
                    interceptorOptions,
                    async ({ request: request2, context, prefix: prefix2 }) => {
                      const method = request2.method;
                      const url = request2.url;
                      const pathname = prefix2 ? url.pathname.replace(prefix2, "") : url.pathname;
                      const match = await (0,
                      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                        "runWithSpan"
                      ])(
                        {
                          name: "find_procedure",
                        },
                        () => this.matcher.match(method, `/${pathname.replace(/^\/|\/$/g, "")}`),
                      );
                      if (!match) {
                        return {
                          matched: false,
                          response: void 0,
                        };
                      }
                      span?.updateName(
                        `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ORPC_NAME"]}.${match.path.join("/")}`,
                      );
                      span?.setAttribute(
                        "rpc.system",
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                          "ORPC_NAME"
                        ],
                      );
                      span?.setAttribute("rpc.method", match.path.join("."));
                      step = "decode_input";
                      let input = await (0,
                      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                        "runWithSpan"
                      ])(
                        {
                          name: "decode_input",
                        },
                        () => this.codec.decode(request2, match.params, match.procedure),
                      );
                      step = void 0;
                      if (
                        (0,
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                          "isAsyncIteratorObject"
                        ])(input)
                      ) {
                        input = (0,
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                          "asyncIteratorWithSpan"
                        ])(
                          {
                            name: "consume_event_iterator_input",
                            signal: request2.signal,
                          },
                          input,
                        );
                      }
                      const client = (0,
                      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                        "c"
                      ])(match.procedure, {
                        context,
                        path: match.path,
                        interceptors: this.clientInterceptors,
                      });
                      step = "call_procedure";
                      const output = await client(input, {
                        signal: request2.signal,
                        lastEventId: (0,
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                          "flattenHeader"
                        ])(request2.headers["last-event-id"]),
                      });
                      step = void 0;
                      const response = this.codec.encode(output, match.procedure);
                      return {
                        matched: true,
                        response,
                      };
                    },
                  );
                } catch (e) {
                  if (step !== "call_procedure") {
                    (0,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                      "setSpanError"
                    ])(span, e);
                  }
                  const error =
                    step === "decode_input" &&
                    !(
                      e instanceof
                      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
                        "ORPCError"
                      ]
                    )
                      ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
                          "ORPCError"
                        ]("BAD_REQUEST", {
                          message: `Malformed request. Ensure the request body is properly formatted and the 'Content-Type' header is set correctly.`,
                          cause: e,
                        })
                      : (0,
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__t__as__toORPCError$3e$__[
                          "toORPCError"
                        ])(e);
                  const response = this.codec.encodeError(error);
                  return {
                    matched: true,
                    response,
                  };
                }
              },
            );
          },
        );
      }
    }
    class StandardRPCCodec {
      constructor(serializer) {
        this.serializer = serializer;
      }
      async decode(request, _params, _procedure) {
        const serialized =
          request.method === "GET"
            ? (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "parseEmptyableJSON"
              ])(request.url.searchParams.getAll("data").at(-1))
            : await request.body();
        return this.serializer.deserialize(serialized);
      }
      encode(output, _procedure) {
        return {
          status: 200,
          headers: {},
          body: this.serializer.serialize(output),
        };
      }
      encodeError(error) {
        return {
          status: error.status,
          headers: {},
          body: this.serializer.serialize(error.toJSON()),
        };
      }
    }
    class StandardRPCMatcher {
      filter;
      tree =
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "NullProtoObj"
        ]();
      pendingRouters = [];
      constructor(options = {}) {
        this.filter = options.filter ?? true;
      }
      init(router, path = []) {
        const laziedOptions = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "t"
        ])(
          {
            router,
            path,
          },
          (traverseOptions) => {
            if (
              !(0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "value"
              ])(this.filter, traverseOptions)
            ) {
              return;
            }
            const { path: path2, contract } = traverseOptions;
            const httpPath = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__t__as__toHttpPath$3e$__[
              "toHttpPath"
            ])(path2);
            if (
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "i"
              ])(contract)
            ) {
              this.tree[httpPath] = {
                path: path2,
                contract,
                procedure: contract,
                // this mean dev not used contract-first so we can used contract as procedure directly
                router,
              };
            } else {
              this.tree[httpPath] = {
                path: path2,
                contract,
                procedure: void 0,
                router,
              };
            }
          },
        );
        this.pendingRouters.push(
          ...laziedOptions.map((option) => ({
            ...option,
            httpPathPrefix: (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__t__as__toHttpPath$3e$__[
              "toHttpPath"
            ])(option.path),
          })),
        );
      }
      async match(_method, pathname) {
        if (this.pendingRouters.length) {
          const newPendingRouters = [];
          for (const pendingRouter of this.pendingRouters) {
            if (pathname.startsWith(pendingRouter.httpPathPrefix)) {
              const { default: router } = await (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "u"
              ])(pendingRouter.router);
              this.init(router, pendingRouter.path);
            } else {
              newPendingRouters.push(pendingRouter);
            }
          }
          this.pendingRouters = newPendingRouters;
        }
        const match = this.tree[pathname];
        if (!match) {
          return void 0;
        }
        if (!match.procedure) {
          const { default: maybeProcedure } = await (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "u"
          ])(
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "g"
            ])(match.router, match.path),
          );
          if (
            !(0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "i"
            ])(maybeProcedure)
          ) {
            throw new Error(`
          [Contract-First] Missing or invalid implementation for procedure at path: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__t__as__toHttpPath$3e$__["toHttpPath"])(match.path)}.
          Ensure that the procedure is correctly defined and matches the expected contract.
        `);
          }
          match.procedure = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "a"
          ])(maybeProcedure, match.contract);
        }
        return {
          path: match.path,
          procedure: match.procedure,
        };
      }
    }
    class StandardRPCHandler extends StandardHandler {
      constructor(router, options = {}) {
        const jsonSerializer =
          new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__b__as__StandardRPCJsonSerializer$3e$__[
            "StandardRPCJsonSerializer"
          ](options);
        const serializer =
          new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__e__as__StandardRPCSerializer$3e$__[
            "StandardRPCSerializer"
          ](jsonSerializer);
        const matcher = new StandardRPCMatcher(options);
        const codec = new StandardRPCCodec(serializer);
        super(router, matcher, codec, options);
      }
    }
  },
  "[project]/node_modules/@orpc/server/dist/shared/server.TEVCLCFC.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["S", () => StrictGetMethodPlugin]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export c as ORPCError>",
      );
    const STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT_SYMBOL = Symbol(
      "STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT",
    );
    class StrictGetMethodPlugin {
      error;
      /**
       * make sure execute before batch plugin to get real method
       */ order = 7e6;
      constructor(options = {}) {
        this.error =
          options.error ??
          new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
            "ORPCError"
          ]("METHOD_NOT_SUPPORTED");
      }
      init(options) {
        options.rootInterceptors ??= [];
        options.clientInterceptors ??= [];
        options.rootInterceptors.unshift((options2) => {
          const isGetMethod = options2.request.method === "GET";
          return options2.next({
            ...options2,
            context: {
              ...options2.context,
              [STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT_SYMBOL]: isGetMethod,
            },
          });
        });
        options.clientInterceptors.unshift((options2) => {
          if (
            typeof options2.context[STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT_SYMBOL] !==
            "boolean"
          ) {
            throw new TypeError(
              "[StrictGetMethodPlugin] strict GET method context has been corrupted or modified by another plugin or interceptor",
            );
          }
          const procedureMethod = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "fallbackContractConfig"
          ])("defaultMethod", options2.procedure["~orpc"].route.method);
          if (
            options2.context[STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT_SYMBOL] &&
            procedureMethod !== "GET"
          ) {
            throw this.error;
          }
          return options2.next();
        });
      }
    }
  },
  "[project]/node_modules/@orpc/server/dist/adapters/fetch/index.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "BodyLimitPlugin",
      () => BodyLimitPlugin,
      "CompositeFetchHandlerPlugin",
      () => CompositeFetchHandlerPlugin,
      "CompressionPlugin",
      () => CompressionPlugin,
      "FetchHandler",
      () => FetchHandler,
      "RPCHandler",
      () => RPCHandler,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-route] (ecmascript) <export c as ORPCError>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2d$fetch$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server-fetch/dist/index.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$DZ5BIITo$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/server/dist/shared/server.DZ5BIITo.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$contract$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/contract/dist/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Bxx6tqNe$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/server/dist/shared/server.Bxx6tqNe.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$adapters$2f$standard$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/adapters/standard/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$batch$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/batch/index.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$TEVCLCFC$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/server/dist/shared/server.TEVCLCFC.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Ds4HPpvH$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/server/dist/shared/server.Ds4HPpvH.mjs [app-route] (ecmascript)",
      );
    class BodyLimitPlugin {
      maxBodySize;
      constructor(options) {
        this.maxBodySize = options.maxBodySize;
      }
      initRuntimeAdapter(options) {
        options.adapterInterceptors ??= [];
        options.adapterInterceptors.push(async (options2) => {
          if (!options2.request.body) {
            return options2.next();
          }
          let currentBodySize = 0;
          const rawReader = options2.request.body.getReader();
          const reader = new ReadableStream({
            start: async (controller) => {
              try {
                if (Number(options2.request.headers.get("content-length")) > this.maxBodySize) {
                  controller.error(
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
                      "ORPCError"
                    ]("PAYLOAD_TOO_LARGE"),
                  );
                  return;
                }
                while (true) {
                  const { done, value } = await rawReader.read();
                  if (done) {
                    break;
                  }
                  currentBodySize += value.length;
                  if (currentBodySize > this.maxBodySize) {
                    controller.error(
                      new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__c__as__ORPCError$3e$__[
                        "ORPCError"
                      ]("PAYLOAD_TOO_LARGE"),
                    );
                    break;
                  }
                  controller.enqueue(value);
                }
              } finally {
                controller.close();
              }
            },
          });
          const requestInit = {
            body: reader,
            duplex: "half",
          };
          return options2.next({
            ...options2,
            request: new Request(options2.request, requestInit),
          });
        });
      }
    }
    const ORDERED_SUPPORTED_ENCODINGS = ["gzip", "deflate"];
    class CompressionPlugin {
      encodings;
      threshold;
      filter;
      constructor(options = {}) {
        this.encodings = options.encodings ?? ORDERED_SUPPORTED_ENCODINGS;
        this.threshold = options.threshold ?? 1024;
        this.filter = (request, response) => {
          const hasContentDisposition = response.headers.has("content-disposition");
          const contentType = response.headers.get("content-type");
          if (!hasContentDisposition && contentType?.startsWith("text/event-stream")) {
            return false;
          }
          return options.filter
            ? options.filter(request, response)
            : isCompressibleContentType(contentType);
        };
      }
      initRuntimeAdapter(options) {
        options.adapterInterceptors ??= [];
        options.adapterInterceptors.unshift(async (options2) => {
          const result = await options2.next();
          if (!result.matched) {
            return result;
          }
          const response = result.response;
          if (
            response.headers.has("content-encoding") ||
            response.headers.has("transfer-encoding") ||
            isNoTransformCacheControl(response.headers.get("cache-control"))
          ) {
            return result;
          }
          const contentLength = response.headers.get("content-length");
          if (contentLength && Number(contentLength) < this.threshold) {
            return result;
          }
          const acceptEncoding = options2.request.headers
            .get("accept-encoding")
            ?.split(",")
            .map((enc) => enc.trim().split(";")[0]);
          const encoding = this.encodings.find((enc) => acceptEncoding?.includes(enc));
          if (!response.body || encoding === void 0) {
            return result;
          }
          if (!this.filter(options2.request, response)) {
            return result;
          }
          const compressedBody = response.body.pipeThrough(new CompressionStream(encoding));
          const compressedHeaders = new Headers(response.headers);
          compressedHeaders.delete("content-length");
          compressedHeaders.set("content-encoding", encoding);
          return {
            ...result,
            response: new Response(compressedBody, {
              status: response.status,
              statusText: response.statusText,
              headers: compressedHeaders,
            }),
          };
        });
      }
    }
    const COMPRESSIBLE_CONTENT_TYPE_REGEX =
      /^\s*(?:text\/(?!event-stream(?:[;\s]|$))[^;\s]+|application\/(?:javascript|json|xml|xml-dtd|ecmascript|dart|postscript|rtf|tar|toml|vnd\.dart|vnd\.ms-fontobject|vnd\.ms-opentype|wasm|x-httpd-php|x-javascript|x-ns-proxy-autoconfig|x-sh|x-tar|x-virtualbox-hdd|x-virtualbox-ova|x-virtualbox-ovf|x-virtualbox-vbox|x-virtualbox-vdi|x-virtualbox-vhd|x-virtualbox-vmdk|x-www-form-urlencoded)|font\/(?:otf|ttf)|image\/(?:bmp|vnd\.adobe\.photoshop|vnd\.microsoft\.icon|vnd\.ms-dds|x-icon|x-ms-bmp)|message\/rfc822|model\/gltf-binary|x-shader\/x-fragment|x-shader\/x-vertex|[^;\s]+?\+(?:json|text|xml|yaml))(?:[;\s]|$)/i;
    function isCompressibleContentType(contentType) {
      if (contentType === null) {
        return false;
      }
      return COMPRESSIBLE_CONTENT_TYPE_REGEX.test(contentType);
    }
    const CACHE_CONTROL_NO_TRANSFORM_REGEX = /(?:^|,)\s*no-transform\s*(?:,|$)/i;
    function isNoTransformCacheControl(cacheControl) {
      if (cacheControl === null) {
        return false;
      }
      return CACHE_CONTROL_NO_TRANSFORM_REGEX.test(cacheControl);
    }
    class CompositeFetchHandlerPlugin
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Bxx6tqNe$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "C"
      ]
    {
      initRuntimeAdapter(options) {
        for (const plugin of this.plugins) {
          plugin.initRuntimeAdapter?.(options);
        }
      }
    }
    class FetchHandler {
      constructor(standardHandler, options = {}) {
        this.standardHandler = standardHandler;
        const plugin = new CompositeFetchHandlerPlugin(options.plugins);
        plugin.initRuntimeAdapter(options);
        this.adapterInterceptors = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "toArray"
        ])(options.adapterInterceptors);
        this.toFetchResponseOptions = options;
      }
      toFetchResponseOptions;
      adapterInterceptors;
      async handle(request, ...rest) {
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "intercept"
        ])(
          this.adapterInterceptors,
          {
            ...(0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$DZ5BIITo$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "r"
            ])(
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "resolveMaybeOptionalOptions"
              ])(rest),
            ),
            request,
            toFetchResponseOptions: this.toFetchResponseOptions,
          },
          async ({ request: request2, toFetchResponseOptions, ...options }) => {
            const standardRequest = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2d$fetch$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "toStandardLazyRequest"
            ])(request2);
            const result = await this.standardHandler.handle(standardRequest, options);
            if (!result.matched) {
              return result;
            }
            return {
              matched: true,
              response: (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2d$fetch$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "toFetchResponse"
              ])(result.response, toFetchResponseOptions),
            };
          },
        );
      }
    }
    class RPCHandler extends FetchHandler {
      constructor(router, options = {}) {
        if (options.strictGetMethodPluginEnabled ?? true) {
          options.plugins ??= [];
          options.plugins.push(
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$TEVCLCFC$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "S"
            ](),
          );
        }
        super(
          new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$server$2f$dist$2f$shared$2f$server$2e$Bxx6tqNe$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "b"
          ](router, options),
          options,
        );
      }
    }
  },
  "[project]/node_modules/dotenv/package.json (json)",
  (__turbopack_context__) => {
    __turbopack_context__.v({
      name: "dotenv",
      version: "17.3.1",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": { types: "./lib/main.d.ts", require: "./lib/main.js", default: "./lib/main.js" },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json",
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        pretest: "npm run lint && npm run dts-check",
        test: "tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000",
        "test:coverage":
          "tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version",
      },
      repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" },
      homepage: "https://github.com/motdotla/dotenv#readme",
      funding: "https://dotenvx.com",
      keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^18.11.3",
        decache: "^4.6.2",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-version": "^9.5.0",
        tap: "^19.2.0",
        typescript: "^4.8.4",
      },
      engines: { node: ">=12" },
      browser: { fs: false },
    });
  },
  "[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
    const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
    const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
    const crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
    const packageJson = __turbopack_context__.r(
      "[project]/node_modules/dotenv/package.json (json)",
    );
    const version = packageJson.version;
    // Array of tips to display randomly
    const TIPS = [
      " encrypt with Dotenvx: https://dotenvx.com",
      " prevent committing .env to code: https://dotenvx.com/precommit",
      " prevent building .env in docker: https://dotenvx.com/prebuild",
      " agentic secret storage: https://dotenvx.com/as2",
      " secrets for agents: https://dotenvx.com/as2",
      " auth for agents: https://vestauth.com",
      "  run anywhere with `dotenvx run -- yourcommand`",
      "  specify custom .env file path with { path: '/custom/path/.env' }",
      "  enable debug logging with { debug: true }",
      "  override existing env vars with { override: true }",
      "  suppress all logs with { quiet: true }",
      "  write to custom object with { processEnv: myObject }",
      "  load multiple .env files with { path: ['.env.local', '.env'] }",
    ];
    // Get a random tip from the tips array
    function _getRandomTip() {
      return TIPS[Math.floor(Math.random() * TIPS.length)];
    }
    function parseBoolean(value) {
      if (typeof value === "string") {
        return !["false", "0", "no", "off", ""].includes(value.toLowerCase());
      }
      return Boolean(value);
    }
    function supportsAnsi() {
      return process.stdout.isTTY; // && process.env.TERM !== 'dumb'
    }
    function dim(text) {
      return supportsAnsi() ? `\x1b[2m${text}\x1b[0m` : text;
    }
    const LINE =
      /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;
    // Parse src into an Object
    function parse(src) {
      const obj = {};
      // Convert buffer to string
      let lines = src.toString();
      // Convert line breaks to same format
      lines = lines.replace(/\r\n?/gm, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        // Default undefined or null to empty string
        let value = match[2] || "";
        // Remove whitespace
        value = value.trim();
        // Check if double quoted
        const maybeQuote = value[0];
        // Remove surrounding quotes
        value = value.replace(/^(['"`])([\s\S]*)\1$/gm, "$2");
        // Expand newlines if double quoted
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        // Add to object
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      options = options || {};
      const vaultPath = _vaultPath(options);
      options.path = vaultPath; // parse .env.vault
      const result = DotenvModule.configDotenv(options);
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      // handle scenario for comma separated keys - for use with key rotation
      // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          // Get full key
          const key = keys[i].trim();
          // Get instructions for decrypt
          const attrs = _instructions(result, key);
          // Decrypt
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          // last key
          if (i + 1 >= length) {
            throw error;
          }
          // try next key
        }
      }
      // Parse decrypted .env string
      return DotenvModule.parse(decrypted);
    }
    function _warn(message) {
      console.error(`[dotenv@${version}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _log(message) {
      console.log(`[dotenv@${version}] ${message}`);
    }
    function _dotenvKey(options) {
      // prioritize developer directly setting options.DOTENV_KEY
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      // secondary infra already contains a DOTENV_KEY environment variable
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      // fallback to empty string
      return "";
    }
    function _instructions(result, dotenvKey) {
      // Parse DOTENV_KEY. Format is a URI
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error(
            "INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development",
          );
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      // Get decrypt key
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      // Get environment
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      // Get ciphertext payload
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey]; // DOTENV_VAULT_PRODUCTION
      if (!ciphertext) {
        const err = new Error(
          `NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`,
        );
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return {
        ciphertext,
        key,
      };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault")
            ? options.path
            : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
      }
      if (fs.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || (options && options.debug));
      const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || (options && options.quiet));
      if (debug || !quiet) {
        _log("Loading env from encrypted .env.vault");
      }
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return {
        parsed,
      };
    }
    function configDotenv(options) {
      const dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || (options && options.debug));
      let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || (options && options.quiet));
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath]; // default, look for .env
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = []; // reset default
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
      // parsed data, we will combine it with process.env (or options.processEnv if provided).
      let lastError;
      const parsedAll = {};
      for (const path of optionPaths) {
        try {
          // Specifying an encoding returns a string instead of a buffer
          const parsed = DotenvModule.parse(
            fs.readFileSync(path, {
              encoding,
            }),
          );
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${path} ${e.message}`);
          }
          lastError = e;
        }
      }
      const populated = DotenvModule.populate(processEnv, parsedAll, options);
      // handle user settings DOTENV_CONFIG_ options inside .env file(s)
      debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug);
      quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);
      if (debug || !quiet) {
        const keysCount = Object.keys(populated).length;
        const shortPaths = [];
        for (const filePath of optionPaths) {
          try {
            const relative = path.relative(process.cwd(), filePath);
            shortPaths.push(relative);
          } catch (e) {
            if (debug) {
              _debug(`Failed to load ${filePath} ${e.message}`);
            }
            lastError = e;
          }
        }
        _log(
          `injecting env (${keysCount}) from ${shortPaths.join(",")} ${dim(`-- tip: ${_getRandomTip()}`)}`,
        );
      }
      if (lastError) {
        return {
          parsed: parsedAll,
          error: lastError,
        };
      } else {
        return {
          parsed: parsedAll,
        };
      }
    }
    // Populates process.env from .env file
    function config(options) {
      // fallback to original dotenv if DOTENV_KEY is not set
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      // dotenvKey exists but .env.vault file does not exist
      if (!vaultPath) {
        _warn(
          `You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`,
        );
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed =
          error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    // Populate process.env with parsed values
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      const populated = {};
      if (typeof parsed !== "object") {
        const err = new Error(
          "OBJECT_REQUIRED: Please check the processEnv argument being passed to populate",
        );
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      // Set process.env
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
            populated[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
          populated[key] = parsed[key];
        }
      }
      return populated;
    }
    const DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse,
      populate,
    };
    module.exports.configDotenv = DotenvModule.configDotenv;
    module.exports._configVault = DotenvModule._configVault;
    module.exports._parseVault = DotenvModule._parseVault;
    module.exports.config = DotenvModule.config;
    module.exports.decrypt = DotenvModule.decrypt;
    module.exports.parse = DotenvModule.parse;
    module.exports.populate = DotenvModule.populate;
    module.exports = DotenvModule;
  },
  "[project]/node_modules/dotenv/lib/env-options.js [app-route] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    // ../config.js accepts options via environment variables
    const options = {};
    if (process.env.DOTENV_CONFIG_ENCODING != null) {
      options.encoding = process.env.DOTENV_CONFIG_ENCODING;
    }
    if (process.env.DOTENV_CONFIG_PATH != null) {
      options.path = process.env.DOTENV_CONFIG_PATH;
    }
    if (process.env.DOTENV_CONFIG_QUIET != null) {
      options.quiet = process.env.DOTENV_CONFIG_QUIET;
    }
    if (process.env.DOTENV_CONFIG_DEBUG != null) {
      options.debug = process.env.DOTENV_CONFIG_DEBUG;
    }
    if (process.env.DOTENV_CONFIG_OVERRIDE != null) {
      options.override = process.env.DOTENV_CONFIG_OVERRIDE;
    }
    if (process.env.DOTENV_CONFIG_DOTENV_KEY != null) {
      options.DOTENV_KEY = process.env.DOTENV_CONFIG_DOTENV_KEY;
    }
    module.exports = options;
  },
  "[project]/node_modules/dotenv/lib/cli-options.js [app-route] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    const re = /^dotenv_config_(encoding|path|quiet|debug|override|DOTENV_KEY)=(.+)$/;
    module.exports = function optionMatcher(args) {
      const options = args.reduce(function (acc, cur) {
        const matches = cur.match(re);
        if (matches) {
          acc[matches[1]] = matches[2];
        }
        return acc;
      }, {});
      if (!("quiet" in options)) {
        options.quiet = "true";
      }
      return options;
    };
  },
  "[project]/node_modules/dotenv/config.js [app-route] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    (function () {
      __turbopack_context__
        .r("[project]/node_modules/dotenv/lib/main.js [app-route] (ecmascript)")
        .config(
          Object.assign(
            {},
            __turbopack_context__.r(
              "[project]/node_modules/dotenv/lib/env-options.js [app-route] (ecmascript)",
            ),
            __turbopack_context__.r(
              "[project]/node_modules/dotenv/lib/cli-options.js [app-route] (ecmascript)",
            )(process.argv),
          ),
        );
    })();
  },
  "[project]/node_modules/@t3-oss/env-core/dist/standard.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "ensureSynchronous",
      () => ensureSynchronous,
      "parseWithDictionary",
      () => parseWithDictionary,
    ]);
    //#region src/standard.ts
    function ensureSynchronous(value, message) {
      if (value instanceof Promise) throw new Error(message);
    }
    function parseWithDictionary(dictionary, value) {
      const result = {};
      const issues = [];
      for (const key in dictionary) {
        const propResult = dictionary[key]["~standard"].validate(value[key]);
        ensureSynchronous(
          propResult,
          `Validation must be synchronous, but ${key} returned a Promise.`,
        );
        if (propResult.issues) {
          issues.push(
            ...propResult.issues.map((issue) => ({
              ...issue,
              message: issue.message,
              path: [key, ...(issue.path ?? [])],
            })),
          );
          continue;
        }
        result[key] = propResult.value;
      }
      if (issues.length)
        return {
          issues,
        };
      return {
        value: result,
      };
    }
  },
  //# sourceMappingURL=standard.js.map
  "[project]/node_modules/@t3-oss/env-core/dist/index.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["createEnv", () => createEnv]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$t3$2d$oss$2f$env$2d$core$2f$dist$2f$standard$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@t3-oss/env-core/dist/standard.js [app-route] (ecmascript)",
      );
    //#region src/index.ts
    /**
     * Create a new environment variable schema.
     */ function createEnv(opts) {
      const runtimeEnv = opts.runtimeEnvStrict ?? opts.runtimeEnv ?? process.env;
      if (opts.emptyStringAsUndefined ?? false) {
        for (const [key, value] of Object.entries(runtimeEnv))
          if (value === "") delete runtimeEnv[key];
      }
      if (!!opts.skipValidation) {
        if (opts.extends) for (const preset of opts.extends) preset.skipValidation = true;
        return runtimeEnv;
      }
      const _client = typeof opts.client === "object" ? opts.client : {};
      const _server = typeof opts.server === "object" ? opts.server : {};
      const _shared = typeof opts.shared === "object" ? opts.shared : {};
      const isServer =
        opts.isServer ??
        (("TURBOPACK compile-time value", "undefined") === "undefined" || "Deno" in window);
      const finalSchemaShape = isServer
        ? {
            ..._server,
            ..._shared,
            ..._client,
          }
        : {
            ..._client,
            ..._shared,
          };
      const parsed =
        opts.createFinalSchema?.(finalSchemaShape, isServer)?.["~standard"].validate(runtimeEnv) ??
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$t3$2d$oss$2f$env$2d$core$2f$dist$2f$standard$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "parseWithDictionary"
        ])(finalSchemaShape, runtimeEnv);
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$t3$2d$oss$2f$env$2d$core$2f$dist$2f$standard$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "ensureSynchronous"
      ])(parsed, "Validation must be synchronous");
      const onValidationError =
        opts.onValidationError ??
        ((issues) => {
          console.error(" Invalid environment variables:", issues);
          throw new Error("Invalid environment variables");
        });
      const onInvalidAccess =
        opts.onInvalidAccess ??
        (() => {
          throw new Error(
            " Attempted to access a server-side environment variable on the client",
          );
        });
      if (parsed.issues) return onValidationError(parsed.issues);
      const isServerAccess = (prop) => {
        if (!opts.clientPrefix) return true;
        return !prop.startsWith(opts.clientPrefix) && !(prop in _shared);
      };
      const isValidServerAccess = (prop) => {
        return isServer || !isServerAccess(prop);
      };
      const ignoreProp = (prop) => {
        return prop === "__esModule" || prop === "$$typeof";
      };
      const extendedObj = (opts.extends ?? []).reduce((acc, curr) => {
        return Object.assign(acc, curr);
      }, {});
      const fullObj = Object.assign(extendedObj, parsed.value);
      return new Proxy(fullObj, {
        get(target, prop) {
          if (typeof prop !== "string") return void 0;
          if (ignoreProp(prop)) return void 0;
          if (!isValidServerAccess(prop)) return onInvalidAccess(prop);
          return Reflect.get(target, prop);
        },
      });
    }
  },
  //# sourceMappingURL=index.js.map
  "[project]/node_modules/@better-auth/utils/dist/random.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["createRandomStringGenerator", () => createRandomStringGenerator]);
    function expandAlphabet(alphabet) {
      switch (alphabet) {
        case "a-z":
          return "abcdefghijklmnopqrstuvwxyz";
        case "A-Z":
          return "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        case "0-9":
          return "0123456789";
        case "-_":
          return "-_";
        default:
          throw new Error(`Unsupported alphabet: ${alphabet}`);
      }
    }
    function createRandomStringGenerator(...baseAlphabets) {
      const baseCharSet = baseAlphabets.map(expandAlphabet).join("");
      if (baseCharSet.length === 0) {
        throw new Error("No valid characters provided for random string generation.");
      }
      const baseCharSetLength = baseCharSet.length;
      return (length, ...alphabets) => {
        if (length <= 0) {
          throw new Error("Length must be a positive integer.");
        }
        let charSet = baseCharSet;
        let charSetLength = baseCharSetLength;
        if (alphabets.length > 0) {
          charSet = alphabets.map(expandAlphabet).join("");
          charSetLength = charSet.length;
        }
        const maxValid = Math.floor(256 / charSetLength) * charSetLength;
        const buf = new Uint8Array(length * 2);
        const bufLength = buf.length;
        let result = "";
        let bufIndex = bufLength;
        let rand;
        while (result.length < length) {
          if (bufIndex >= bufLength) {
            crypto.getRandomValues(buf);
            bufIndex = 0;
          }
          rand = buf[bufIndex++];
          if (rand < maxValid) {
            result += charSet[rand % charSetLength];
          }
        }
        return result;
      };
    }
  },
  "[project]/node_modules/@better-auth/utils/dist/hex.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["hex", () => hex]);
    const hexadecimal = "0123456789abcdef";
    const hex = {
      encode: (data) => {
        if (typeof data === "string") {
          data = new TextEncoder().encode(data);
        }
        if (data.byteLength === 0) {
          return "";
        }
        const buffer = new Uint8Array(data);
        let result = "";
        for (const byte of buffer) {
          result += byte.toString(16).padStart(2, "0");
        }
        return result;
      },
      decode: (data) => {
        if (!data) {
          return "";
        }
        if (typeof data === "string") {
          if (data.length % 2 !== 0) {
            throw new Error("Invalid hexadecimal string");
          }
          if (!new RegExp(`^[${hexadecimal}]+$`).test(data)) {
            throw new Error("Invalid hexadecimal string");
          }
          const result = new Uint8Array(data.length / 2);
          for (let i = 0; i < data.length; i += 2) {
            result[i / 2] = parseInt(data.slice(i, i + 2), 16);
          }
          return new TextDecoder().decode(result);
        }
        return new TextDecoder().decode(data);
      },
    };
  },
  "[project]/node_modules/@better-auth/utils/dist/index.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["getWebcryptoSubtle", () => getWebcryptoSubtle]);
    function getWebcryptoSubtle() {
      const cr = typeof globalThis !== "undefined" && globalThis.crypto;
      if (cr && typeof cr.subtle === "object" && cr.subtle != null) return cr.subtle;
      throw new Error("crypto.subtle must be defined");
    }
  },
  "[project]/node_modules/@better-auth/utils/dist/base64.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["base64", () => base64, "base64Url", () => base64Url]);
    function getAlphabet(urlSafe) {
      return urlSafe
        ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    }
    function base64Encode(data, alphabet, padding) {
      let result = "";
      let buffer = 0;
      let shift = 0;
      for (const byte of data) {
        buffer = (buffer << 8) | byte;
        shift += 8;
        while (shift >= 6) {
          shift -= 6;
          result += alphabet[(buffer >> shift) & 63];
        }
      }
      if (shift > 0) {
        result += alphabet[(buffer << (6 - shift)) & 63];
      }
      if (padding) {
        const padCount = (4 - (result.length % 4)) % 4;
        result += "=".repeat(padCount);
      }
      return result;
    }
    function base64Decode(data, alphabet) {
      const decodeMap = /* @__PURE__ */ new Map();
      for (let i = 0; i < alphabet.length; i++) {
        decodeMap.set(alphabet[i], i);
      }
      const result = [];
      let buffer = 0;
      let bitsCollected = 0;
      for (const char of data) {
        if (char === "=") break;
        const value = decodeMap.get(char);
        if (value === void 0) {
          throw new Error(`Invalid Base64 character: ${char}`);
        }
        buffer = (buffer << 6) | value;
        bitsCollected += 6;
        if (bitsCollected >= 8) {
          bitsCollected -= 8;
          result.push((buffer >> bitsCollected) & 255);
        }
      }
      return Uint8Array.from(result);
    }
    const base64 = {
      encode(data, options = {}) {
        const alphabet = getAlphabet(false);
        const buffer =
          typeof data === "string" ? new TextEncoder().encode(data) : new Uint8Array(data);
        return base64Encode(buffer, alphabet, options.padding ?? true);
      },
      decode(data) {
        if (typeof data !== "string") {
          data = new TextDecoder().decode(data);
        }
        const urlSafe = data.includes("-") || data.includes("_");
        const alphabet = getAlphabet(urlSafe);
        return base64Decode(data, alphabet);
      },
    };
    const base64Url = {
      encode(data, options = {}) {
        const alphabet = getAlphabet(true);
        const buffer =
          typeof data === "string" ? new TextEncoder().encode(data) : new Uint8Array(data);
        return base64Encode(buffer, alphabet, options.padding ?? true);
      },
      decode(data) {
        const urlSafe = data.includes("-") || data.includes("_");
        const alphabet = getAlphabet(urlSafe);
        return base64Decode(data, alphabet);
      },
    };
  },
  "[project]/node_modules/@better-auth/utils/dist/hash.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["createHash", () => createHash]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/utils/dist/base64.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/utils/dist/index.mjs [app-route] (ecmascript)",
      );
    function createHash(algorithm, encoding) {
      return {
        digest: async (input) => {
          const encoder = new TextEncoder();
          const data = typeof input === "string" ? encoder.encode(input) : input;
          const hashBuffer = await (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "getWebcryptoSubtle"
          ])().digest(algorithm, data);
          if (encoding === "hex") {
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
            return hashHex;
          }
          if (encoding === "base64" || encoding === "base64url" || encoding === "base64urlnopad") {
            if (encoding.includes("url")) {
              return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "base64Url"
              ].encode(hashBuffer, {
                padding: encoding !== "base64urlnopad",
              });
            }
            const hashBase64 =
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "base64"
              ].encode(hashBuffer);
            return hashBase64;
          }
          return hashBuffer;
        },
      };
    }
  },
  "[project]/node_modules/@better-auth/utils/dist/binary.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["binary", () => binary]);
    const decoders = /* @__PURE__ */ new Map();
    const encoder = new TextEncoder();
    const binary = {
      decode: (data, encoding = "utf-8") => {
        if (!decoders.has(encoding)) {
          decoders.set(encoding, new TextDecoder(encoding));
        }
        const decoder = decoders.get(encoding);
        return decoder.decode(data);
      },
      encode: encoder.encode,
    };
  },
  "[project]/node_modules/@better-auth/utils/dist/hmac.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["createHMAC", () => createHMAC]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hex$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/utils/dist/hex.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/utils/dist/base64.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/utils/dist/index.mjs [app-route] (ecmascript)",
      );
    const createHMAC = (algorithm = "SHA-256", encoding = "none") => {
      const hmac = {
        importKey: async (key, keyUsage) => {
          return (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "getWebcryptoSubtle"
          ])().importKey(
            "raw",
            typeof key === "string" ? new TextEncoder().encode(key) : key,
            {
              name: "HMAC",
              hash: {
                name: algorithm,
              },
            },
            false,
            [keyUsage],
          );
        },
        sign: async (hmacKey, data) => {
          if (typeof hmacKey === "string") {
            hmacKey = await hmac.importKey(hmacKey, "sign");
          }
          const signature = await (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "getWebcryptoSubtle"
          ])().sign(
            "HMAC",
            hmacKey,
            typeof data === "string" ? new TextEncoder().encode(data) : data,
          );
          if (encoding === "hex") {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hex$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "hex"
            ].encode(signature);
          }
          if (encoding === "base64" || encoding === "base64url" || encoding === "base64urlnopad") {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "base64Url"
            ].encode(signature, {
              padding: encoding !== "base64urlnopad",
            });
          }
          return signature;
        },
        verify: async (hmacKey, data, signature) => {
          if (typeof hmacKey === "string") {
            hmacKey = await hmac.importKey(hmacKey, "verify");
          }
          if (encoding === "hex") {
            signature =
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hex$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "hex"
              ].decode(signature);
          }
          if (encoding === "base64" || encoding === "base64url" || encoding === "base64urlnopad") {
            signature =
              await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "base64"
              ].decode(signature);
          }
          return (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "getWebcryptoSubtle"
          ])().verify(
            "HMAC",
            hmacKey,
            typeof signature === "string" ? new TextEncoder().encode(signature) : signature,
            typeof data === "string" ? new TextEncoder().encode(data) : data,
          );
        },
      };
      return hmac;
    };
  },
  "[project]/node_modules/@noble/hashes/utils.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    /**
     * Utilities for hex, bytes, CSPRNG.
     * @module
     */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ /** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ __turbopack_context__.s(
      [
        "abytes",
        () => abytes,
        "aexists",
        () => aexists,
        "ahash",
        () => ahash,
        "anumber",
        () => anumber,
        "aoutput",
        () => aoutput,
        "asyncLoop",
        () => asyncLoop,
        "byteSwap",
        () => byteSwap,
        "byteSwap32",
        () => byteSwap32,
        "bytesToHex",
        () => bytesToHex,
        "checkOpts",
        () => checkOpts,
        "clean",
        () => clean,
        "concatBytes",
        () => concatBytes,
        "createHasher",
        () => createHasher,
        "createView",
        () => createView,
        "hexToBytes",
        () => hexToBytes,
        "isBytes",
        () => isBytes,
        "isLE",
        () => isLE,
        "kdfInputToBytes",
        () => kdfInputToBytes,
        "nextTick",
        () => nextTick,
        "oidNist",
        () => oidNist,
        "randomBytes",
        () => randomBytes,
        "rotl",
        () => rotl,
        "rotr",
        () => rotr,
        "swap32IfBE",
        () => swap32IfBE,
        "swap8IfBE",
        () => swap8IfBE,
        "u32",
        () => u32,
        "u8",
        () => u8,
        "utf8ToBytes",
        () => utf8ToBytes,
      ],
    );
    function isBytes(a) {
      return (
        a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array")
      );
    }
    function anumber(n, title = "") {
      if (!Number.isSafeInteger(n) || n < 0) {
        const prefix = title && `"${title}" `;
        throw new Error(`${prefix}expected integer >= 0, got ${n}`);
      }
    }
    function abytes(value, length, title = "") {
      const bytes = isBytes(value);
      const len = value?.length;
      const needsLen = length !== undefined;
      if (!bytes || (needsLen && len !== length)) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : "";
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
      }
      return value;
    }
    function ahash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash must wrapped by utils.createHasher");
      anumber(h.outputLen);
      anumber(h.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed) throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out, undefined, "digestInto() output");
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error('"digestInto() output" expected to be of length >=' + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr(word, shift) {
      return (word << (32 - shift)) | (word >>> shift);
    }
    function rotl(word, shift) {
      return (word << shift) | ((word >>> (32 - shift)) >>> 0);
    }
    const isLE = /* @__PURE__ */ (() =>
      new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
    function byteSwap(word) {
      return (
        ((word << 24) & 0xff000000) |
        ((word << 8) & 0xff0000) |
        ((word >>> 8) & 0xff00) |
        ((word >>> 24) & 0xff)
      );
    }
    const swap8IfBE = isLE ? (n) => n : (n) => byteSwap(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
      }
      return arr;
    }
    const swap32IfBE = isLE ? (u) => u : byteSwap32;
    // Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
    const hasHexBuiltin = /* @__PURE__ */ (() =>
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" &&
      typeof Uint8Array.fromHex === "function")();
    // Array where index 0xf0 (240) is mapped to string 'f0'
    const hexes = /* @__PURE__ */ Array.from(
      {
        length: 256,
      },
      (_, i) => i.toString(16).padStart(2, "0"),
    );
    function bytesToHex(bytes) {
      abytes(bytes);
      // @ts-ignore
      if (hasHexBuiltin) return bytes.toHex();
      // pre-caching improves the speed 6x
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    // We use optimized technique to convert hex string to byte array
    const asciis = {
      _0: 48,
      _9: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102,
    };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
      if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
      if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
      // @ts-ignore
      if (hasHexBuiltin) return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2) throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error(
            'hex string expected, got non-hex character "' + char + '" at index ' + hi,
          );
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
      }
      return array;
    }
    const nextTick = async () => {};
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await nextTick();
        ts += diff;
      }
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string") throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
    }
    function kdfInputToBytes(data, errorTitle = "") {
      if (typeof data === "string") return utf8ToBytes(data);
      return abytes(data, undefined, errorTitle);
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts !== undefined && {}.toString.call(opts) !== "[object Object]")
        throw new Error("options must be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    function createHasher(hashCons, info = {}) {
      const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
      const tmp = hashCons(undefined);
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      Object.assign(hashC, info);
      return Object.freeze(hashC);
    }
    function randomBytes(bytesLength = 32) {
      const cr = typeof globalThis === "object" ? globalThis.crypto : null;
      if (typeof cr?.getRandomValues !== "function")
        throw new Error("crypto.getRandomValues must be defined");
      return cr.getRandomValues(new Uint8Array(bytesLength));
    }
    const oidNist = (suffix) => ({
      oid: Uint8Array.from([0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, suffix]),
    }); //# sourceMappingURL=utils.js.map
  },
  "[project]/node_modules/@noble/hashes/hmac.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["_HMAC", () => _HMAC, "hmac", () => hmac]);
    /**
     * HMAC: RFC2104 message authentication code.
     * @module
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/hashes/utils.js [app-route] (ecmascript)",
      );
    class _HMAC {
      oHash;
      iHash;
      blockLen;
      outputLen;
      finished = false;
      destroyed = false;
      constructor(hash, key) {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "ahash"
        ])(hash);
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "abytes"
        ])(key, undefined, "key");
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "clean"
        ])(pad);
      }
      update(buf) {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "aexists"
        ])(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "aexists"
        ])(this);
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "abytes"
        ])(out, this.outputLen, "output");
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to ||= Object.create(Object.getPrototypeOf(this), {});
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    }
    const hmac = (hash, key, message) => new _HMAC(hash, key).update(message).digest();
    hmac.create = (hash, key) => new _HMAC(hash, key); //# sourceMappingURL=hmac.js.map
  },
  "[project]/node_modules/@noble/hashes/hkdf.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["expand", () => expand, "extract", () => extract, "hkdf", () => hkdf]);
    /**
     * HKDF (RFC 5869): extract + expand in one step.
     * See https://soatok.blog/2021/11/17/understanding-hkdf/.
     * @module
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$hmac$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/hashes/hmac.js [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/hashes/utils.js [app-route] (ecmascript)",
      );
    function extract(hash, ikm, salt) {
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "ahash"
      ])(hash);
      // NOTE: some libraries treat zero-length array as 'not provided';
      // we don't, since we have undefined as 'not provided'
      // https://github.com/RustCrypto/KDFs/issues/15
      if (salt === undefined) salt = new Uint8Array(hash.outputLen);
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$hmac$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "hmac"
      ])(hash, salt, ikm);
    }
    const HKDF_COUNTER = /* @__PURE__ */ Uint8Array.of(0);
    const EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();
    function expand(hash, prk, info, length = 32) {
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "ahash"
      ])(hash);
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "anumber"
      ])(length, "length");
      const olen = hash.outputLen;
      if (length > 255 * olen) throw new Error("Length must be <= 255*HashLen");
      const blocks = Math.ceil(length / olen);
      if (info === undefined) info = EMPTY_BUFFER;
      else
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "abytes"
        ])(info, undefined, "info");
      // first L(ength) octets of T
      const okm = new Uint8Array(blocks * olen);
      // Re-use HMAC instance between blocks
      const HMAC =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$hmac$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "hmac"
        ].create(hash, prk);
      const HMACTmp = HMAC._cloneInto();
      const T = new Uint8Array(HMAC.outputLen);
      for (let counter = 0; counter < blocks; counter++) {
        HKDF_COUNTER[0] = counter + 1;
        // T(0) = empty string (zero length)
        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)
        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)
          .update(info)
          .update(HKDF_COUNTER)
          .digestInto(T);
        okm.set(T, olen * counter);
        HMAC._cloneInto(HMACTmp);
      }
      HMAC.destroy();
      HMACTmp.destroy();
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "clean"
      ])(T, HKDF_COUNTER);
      return okm.slice(0, length);
    }
    const hkdf = (hash, ikm, salt, info, length) =>
      expand(hash, extract(hash, ikm, salt), info, length); //# sourceMappingURL=hkdf.js.map
  },
  "[project]/node_modules/@noble/hashes/_md.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "Chi",
      () => Chi,
      "HashMD",
      () => HashMD,
      "Maj",
      () => Maj,
      "SHA224_IV",
      () => SHA224_IV,
      "SHA256_IV",
      () => SHA256_IV,
      "SHA384_IV",
      () => SHA384_IV,
      "SHA512_IV",
      () => SHA512_IV,
    ]);
    /**
     * Internal Merkle-Damgard hash utils.
     * @module
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/hashes/utils.js [app-route] (ecmascript)",
      );
    function Chi(a, b, c) {
      return (a & b) ^ (~a & c);
    }
    function Maj(a, b, c) {
      return (a & b) ^ (a & c) ^ (b & c);
    }
    class HashMD {
      blockLen;
      outputLen;
      padOffset;
      isLE;
      // For partial updates less than block size
      buffer;
      view;
      finished = false;
      length = 0;
      pos = 0;
      destroyed = false;
      constructor(blockLen, outputLen, padOffset, isLE) {
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "createView"
        ])(this.buffer);
      }
      update(data) {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "aexists"
        ])(this);
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "abytes"
        ])(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          // Fast path: we have at least one block in input, cast it to view and process
          if (take === blockLen) {
            const dataView = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "createView"
            ])(data);
            for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "aexists"
        ])(this);
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "aoutput"
        ])(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "clean"
        ])(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++) buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "createView"
        ])(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which must be fused in single op with modulo by JIT
        if (len % 4) throw new Error("_sha2: outputLen must be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to ||= new this.constructor();
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
      }
      clone() {
        return this._cloneInto();
      }
    }
    const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
      0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,
      0x5be0cd19,
    ]);
    const SHA224_IV = /* @__PURE__ */ Uint32Array.from([
      0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7,
      0xbefa4fa4,
    ]);
    const SHA384_IV = /* @__PURE__ */ Uint32Array.from([
      0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8,
      0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7,
      0x47b5481d, 0xbefa4fa4,
    ]);
    const SHA512_IV = /* @__PURE__ */ Uint32Array.from([
      0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a,
      0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b,
      0x5be0cd19, 0x137e2179,
    ]); //# sourceMappingURL=_md.js.map
  },
  "[project]/node_modules/@noble/hashes/_u64.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "add",
      () => add,
      "add3H",
      () => add3H,
      "add3L",
      () => add3L,
      "add4H",
      () => add4H,
      "add4L",
      () => add4L,
      "add5H",
      () => add5H,
      "add5L",
      () => add5L,
      "default",
      () => __TURBOPACK__default__export__,
      "fromBig",
      () => fromBig,
      "rotlBH",
      () => rotlBH,
      "rotlBL",
      () => rotlBL,
      "rotlSH",
      () => rotlSH,
      "rotlSL",
      () => rotlSL,
      "rotr32H",
      () => rotr32H,
      "rotr32L",
      () => rotr32L,
      "rotrBH",
      () => rotrBH,
      "rotrBL",
      () => rotrBL,
      "rotrSH",
      () => rotrSH,
      "rotrSL",
      () => rotrSL,
      "shrSH",
      () => shrSH,
      "shrSL",
      () => shrSL,
      "split",
      () => split,
      "toBig",
      () => toBig,
    ]);
    /**
     * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
     * @todo re-check https://issues.chromium.org/issues/42212588
     * @module
     */ const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    const _32n = /* @__PURE__ */ BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return {
          h: Number(n & U32_MASK64),
          l: Number((n >> _32n) & U32_MASK64),
        };
      return {
        h: Number((n >> _32n) & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0,
      };
    }
    function split(lst, le = false) {
      const len = lst.length;
      let Ah = new Uint32Array(len);
      let Al = new Uint32Array(len);
      for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
    // for Shift in [0, 32)
    const shrSH = (h, _l, s) => h >>> s;
    const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
    // Right rotate for Shift in [1, 32)
    const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
    const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
    // Right rotate for Shift in (32, 64), NOTE: 32 is special case.
    const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
    const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
    // Right rotate for shift===32 (just swaps l&h)
    const rotr32H = (_h, l) => l;
    const rotr32L = (h, _l) => h;
    // Left rotate for Shift in [1, 32)
    const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
    const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
    // Left rotate for Shift in (32, 64), NOTE: 32 is special case.
    const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
    const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
    // JS uses 32-bit signed integers for bitwise operations which means we cannot
    // simple take carry out of low bit sum by shift, we need to use division.
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return {
        h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0,
        l: l | 0,
      };
    }
    // Addition with more than 2 elements
    const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
    const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
    const add5L = (Al, Bl, Cl, Dl, El) =>
      (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
    // prettier-ignore
    const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
    const __TURBOPACK__default__export__ = u64;
    //# sourceMappingURL=_u64.js.map
  },
  "[project]/node_modules/@noble/hashes/sha2.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "_SHA224",
      () => _SHA224,
      "_SHA256",
      () => _SHA256,
      "_SHA384",
      () => _SHA384,
      "_SHA512",
      () => _SHA512,
      "_SHA512_224",
      () => _SHA512_224,
      "_SHA512_256",
      () => _SHA512_256,
      "sha224",
      () => sha224,
      "sha256",
      () => sha256,
      "sha384",
      () => sha384,
      "sha512",
      () => sha512,
      "sha512_224",
      () => sha512_224,
      "sha512_256",
      () => sha512_256,
    ]);
    /**
     * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
     * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
     * Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and
     * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
     * @module
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/hashes/_md.js [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/hashes/_u64.js [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/hashes/utils.js [app-route] (ecmascript)",
      );
    /**
     * Round constants:
     * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
     */ // prettier-ignore
    const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
    /** Reusable temporary buffer. "W" comes straight from spec. */ const SHA256_W =
      /* @__PURE__ */ new Uint32Array(64);
    /** Internal 32-byte base SHA2 hash class. */ class SHA2_32B
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "HashMD"
      ]
    {
      constructor(outputLen) {
        super(64, outputLen, 8, false);
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
      process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 =
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotr"
            ])(W15, 7) ^
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotr"
            ])(W15, 18) ^
            (W15 >>> 3);
          const s1 =
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotr"
            ])(W2, 17) ^
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotr"
            ])(W2, 19) ^
            (W2 >>> 10);
          SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 =
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotr"
            ])(E, 6) ^
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotr"
            ])(E, 11) ^
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotr"
            ])(E, 25);
          const T1 =
            (H +
              sigma1 +
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "Chi"
              ])(E, F, G) +
              SHA256_K[i] +
              SHA256_W[i]) |
            0;
          const sigma0 =
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotr"
            ])(A, 2) ^
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotr"
            ])(A, 13) ^
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotr"
            ])(A, 22);
          const T2 =
            (sigma0 +
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "Maj"
              ])(A, B, C)) |
            0;
          H = G;
          G = F;
          F = E;
          E = (D + T1) | 0;
          D = C;
          C = B;
          B = A;
          A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "clean"
        ])(SHA256_W);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "clean"
        ])(this.buffer);
      }
    }
    class _SHA256 extends SHA2_32B {
      // We cannot use array here since array allows indexing by variable
      // which means optimizer/compiler cannot use registers.
      A =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA256_IV"
        ][0] | 0;
      B =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA256_IV"
        ][1] | 0;
      C =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA256_IV"
        ][2] | 0;
      D =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA256_IV"
        ][3] | 0;
      E =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA256_IV"
        ][4] | 0;
      F =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA256_IV"
        ][5] | 0;
      G =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA256_IV"
        ][6] | 0;
      H =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA256_IV"
        ][7] | 0;
      constructor() {
        super(32);
      }
    }
    class _SHA224 extends SHA2_32B {
      A =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA224_IV"
        ][0] | 0;
      B =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA224_IV"
        ][1] | 0;
      C =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA224_IV"
        ][2] | 0;
      D =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA224_IV"
        ][3] | 0;
      E =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA224_IV"
        ][4] | 0;
      F =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA224_IV"
        ][5] | 0;
      G =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA224_IV"
        ][6] | 0;
      H =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA224_IV"
        ][7] | 0;
      constructor() {
        super(28);
      }
    }
    // SHA2-512 is slower than sha256 in js because u64 operations are slow.
    // Round contants
    // First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
    // prettier-ignore
    const K512 = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["split"]([
        '0x428a2f98d728ae22',
        '0x7137449123ef65cd',
        '0xb5c0fbcfec4d3b2f',
        '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538',
        '0x59f111f1b605d019',
        '0x923f82a4af194f9b',
        '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242',
        '0x12835b0145706fbe',
        '0x243185be4ee4b28c',
        '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f',
        '0x80deb1fe3b1696b1',
        '0x9bdc06a725c71235',
        '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2',
        '0xefbe4786384f25e3',
        '0x0fc19dc68b8cd5b5',
        '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275',
        '0x4a7484aa6ea6e483',
        '0x5cb0a9dcbd41fbd4',
        '0x76f988da831153b5',
        '0x983e5152ee66dfab',
        '0xa831c66d2db43210',
        '0xb00327c898fb213f',
        '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2',
        '0xd5a79147930aa725',
        '0x06ca6351e003826f',
        '0x142929670a0e6e70',
        '0x27b70a8546d22ffc',
        '0x2e1b21385c26c926',
        '0x4d2c6dfc5ac42aed',
        '0x53380d139d95b3df',
        '0x650a73548baf63de',
        '0x766a0abb3c77b2a8',
        '0x81c2c92e47edaee6',
        '0x92722c851482353b',
        '0xa2bfe8a14cf10364',
        '0xa81a664bbc423001',
        '0xc24b8b70d0f89791',
        '0xc76c51a30654be30',
        '0xd192e819d6ef5218',
        '0xd69906245565a910',
        '0xf40e35855771202a',
        '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8',
        '0x1e376c085141ab53',
        '0x2748774cdf8eeb99',
        '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63',
        '0x4ed8aa4ae3418acb',
        '0x5b9cca4f7763e373',
        '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc',
        '0x78a5636f43172f60',
        '0x84c87814a1f0ab72',
        '0x8cc702081a6439ec',
        '0x90befffa23631e28',
        '0xa4506cebde82bde9',
        '0xbef9a3f7b2c67915',
        '0xc67178f2e372532b',
        '0xca273eceea26619c',
        '0xd186b8c721c0c207',
        '0xeada7dd6cde0eb1e',
        '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba',
        '0x0a637dc5a2c898a6',
        '0x113f9804bef90dae',
        '0x1b710b35131c471b',
        '0x28db77f523047d84',
        '0x32caab7b40c72493',
        '0x3c9ebe0a15c9bebc',
        '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6',
        '0x597f299cfc657e2a',
        '0x5fcb6fab3ad6faec',
        '0x6c44198c4a475817'
    ].map((n)=>BigInt(n))))();
    const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
    const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
    // Reusable temporary buffers
    const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
    const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
    /** Internal 64-byte base SHA2 hash class. */ class SHA2_64B
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "HashMD"
      ]
    {
      constructor(outputLen) {
        super(128, outputLen, 16, false);
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
        ];
    }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
      process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
          // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrSH"
            ](W15h, W15l, 1) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrSH"
            ](W15h, W15l, 8) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "shrSH"
            ](W15h, W15l, 7);
          const s0l =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrSL"
            ](W15h, W15l, 1) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrSL"
            ](W15h, W15l, 8) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "shrSL"
            ](W15h, W15l, 7);
          // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrSH"
            ](W2h, W2l, 19) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrBH"
            ](W2h, W2l, 61) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "shrSH"
            ](W2h, W2l, 6);
          const s1l =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrSL"
            ](W2h, W2l, 19) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrBL"
            ](W2h, W2l, 61) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "shrSL"
            ](W2h, W2l, 6);
          // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
          const SUMl =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "add4L"
            ](s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "add4H"
            ](SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
          // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
          const sigma1h =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrSH"
            ](Eh, El, 14) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrSH"
            ](Eh, El, 18) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrBH"
            ](Eh, El, 41);
          const sigma1l =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrSL"
            ](Eh, El, 14) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrSL"
            ](Eh, El, 18) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrBL"
            ](Eh, El, 41);
          //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
          const CHIh = (Eh & Fh) ^ (~Eh & Gh);
          const CHIl = (El & Fl) ^ (~El & Gl);
          // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
          // prettier-ignore
          const T1ll = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add5L"](Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "add5H"
            ](T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
          const sigma0h =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrSH"
            ](Ah, Al, 28) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrBH"
            ](Ah, Al, 34) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrBH"
            ](Ah, Al, 39);
          const sigma0l =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrSL"
            ](Ah, Al, 28) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrBL"
            ](Ah, Al, 34) ^
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "rotrBL"
            ](Ah, Al, 39);
          const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
          const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "add"
            ](Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "add3L"
            ](T1l, sigma0l, MAJl);
          Ah =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "add3H"
            ](All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "add"
          ](this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "add"
          ](this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "add"
          ](this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "add"
          ](this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "add"
          ](this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "add"
          ](this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "add"
          ](this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_u64$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "add"
          ](this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "clean"
        ])(SHA512_W_H, SHA512_W_L);
      }
      destroy() {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "clean"
        ])(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    }
    class _SHA512 extends SHA2_64B {
      Ah =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][0] | 0;
      Al =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][1] | 0;
      Bh =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][2] | 0;
      Bl =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][3] | 0;
      Ch =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][4] | 0;
      Cl =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][5] | 0;
      Dh =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][6] | 0;
      Dl =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][7] | 0;
      Eh =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][8] | 0;
      El =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][9] | 0;
      Fh =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][10] | 0;
      Fl =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][11] | 0;
      Gh =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][12] | 0;
      Gl =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][13] | 0;
      Hh =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][14] | 0;
      Hl =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA512_IV"
        ][15] | 0;
      constructor() {
        super(64);
      }
    }
    class _SHA384 extends SHA2_64B {
      Ah =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][0] | 0;
      Al =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][1] | 0;
      Bh =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][2] | 0;
      Bl =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][3] | 0;
      Ch =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][4] | 0;
      Cl =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][5] | 0;
      Dh =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][6] | 0;
      Dl =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][7] | 0;
      Eh =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][8] | 0;
      El =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][9] | 0;
      Fh =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][10] | 0;
      Fl =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][11] | 0;
      Gh =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][12] | 0;
      Gl =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][13] | 0;
      Hh =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][14] | 0;
      Hl =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$_md$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "SHA384_IV"
        ][15] | 0;
      constructor() {
        super(48);
      }
    }
    /**
     * Truncated SHA512/256 and SHA512/224.
     * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
     * Then t hashes string to produce result IV.
     * See `test/misc/sha2-gen-iv.js`.
     */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([
      0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514,
      0x582f9fcf, 0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8,
      0x1112e6ad, 0x91d692a1,
    ]);
    /** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([
      0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719,
      0x5940eabd, 0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa,
      0x0eb72ddc, 0x81c52ca2,
    ]);
    class _SHA512_224 extends SHA2_64B {
      Ah = T224_IV[0] | 0;
      Al = T224_IV[1] | 0;
      Bh = T224_IV[2] | 0;
      Bl = T224_IV[3] | 0;
      Ch = T224_IV[4] | 0;
      Cl = T224_IV[5] | 0;
      Dh = T224_IV[6] | 0;
      Dl = T224_IV[7] | 0;
      Eh = T224_IV[8] | 0;
      El = T224_IV[9] | 0;
      Fh = T224_IV[10] | 0;
      Fl = T224_IV[11] | 0;
      Gh = T224_IV[12] | 0;
      Gl = T224_IV[13] | 0;
      Hh = T224_IV[14] | 0;
      Hl = T224_IV[15] | 0;
      constructor() {
        super(28);
      }
    }
    class _SHA512_256 extends SHA2_64B {
      Ah = T256_IV[0] | 0;
      Al = T256_IV[1] | 0;
      Bh = T256_IV[2] | 0;
      Bl = T256_IV[3] | 0;
      Ch = T256_IV[4] | 0;
      Cl = T256_IV[5] | 0;
      Dh = T256_IV[6] | 0;
      Dl = T256_IV[7] | 0;
      Eh = T256_IV[8] | 0;
      El = T256_IV[9] | 0;
      Fh = T256_IV[10] | 0;
      Fl = T256_IV[11] | 0;
      Gh = T256_IV[12] | 0;
      Gl = T256_IV[13] | 0;
      Hh = T256_IV[14] | 0;
      Hl = T256_IV[15] | 0;
      constructor() {
        super(32);
      }
    }
    const sha256 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createHasher"
    ])(
      () => new _SHA256(),
      /* @__PURE__ */ (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "oidNist"
      ])(0x01),
    );
    const sha224 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createHasher"
    ])(
      () => new _SHA224(),
      /* @__PURE__ */ (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "oidNist"
      ])(0x04),
    );
    const sha512 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createHasher"
    ])(
      () => new _SHA512(),
      /* @__PURE__ */ (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "oidNist"
      ])(0x03),
    );
    const sha384 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createHasher"
    ])(
      () => new _SHA384(),
      /* @__PURE__ */ (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "oidNist"
      ])(0x02),
    );
    const sha512_256 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createHasher"
    ])(
      () => new _SHA512_256(),
      /* @__PURE__ */ (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "oidNist"
      ])(0x06),
    );
    const sha512_224 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createHasher"
    ])(
      () => new _SHA512_224(),
      /* @__PURE__ */ (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "oidNist"
      ])(0x05),
    ); //# sourceMappingURL=sha2.js.map
  },
  "[project]/node_modules/@noble/hashes/pbkdf2.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["pbkdf2", () => pbkdf2, "pbkdf2Async", () => pbkdf2Async]);
    /**
     * PBKDF (RFC 2898). Can be used to create a key from password and salt.
     * @module
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$hmac$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/hashes/hmac.js [app-route] (ecmascript)",
      );
    // prettier-ignore
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/utils.js [app-route] (ecmascript)");
    // Common start and end for sync/async functions
    function pbkdf2Init(hash, _password, _salt, _opts) {
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "ahash"
      ])(hash);
      const opts = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "checkOpts"
      ])(
        {
          dkLen: 32,
          asyncTick: 10,
        },
        _opts,
      );
      const { c, dkLen, asyncTick } = opts;
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "anumber"
      ])(c, "c");
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "anumber"
      ])(dkLen, "dkLen");
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "anumber"
      ])(asyncTick, "asyncTick");
      if (c < 1) throw new Error("iterations (c) must be >= 1");
      const password = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "kdfInputToBytes"
      ])(_password, "password");
      const salt = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "kdfInputToBytes"
      ])(_salt, "salt");
      // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
      const DK = new Uint8Array(dkLen);
      // U1 = PRF(Password, Salt + INT_32_BE(i))
      const PRF =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$hmac$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "hmac"
        ].create(hash, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return {
        c,
        dkLen,
        asyncTick,
        DK,
        PRF,
        PRFSalt,
      };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW) prfW.destroy();
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "clean"
      ])(u);
      return DK;
    }
    function pbkdf2(hash, password, salt, opts) {
      const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW; // Working copy
      const arr = new Uint8Array(4);
      const view = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "createView"
      ])(arr);
      const u = new Uint8Array(PRF.outputLen);
      // DK = T1 + T2 +  + Tdklen/hlen
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
          // Uc = PRF(Password, Uc1)
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    async function pbkdf2Async(hash, password, salt, opts) {
      const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW; // Working copy
      const arr = new Uint8Array(4);
      const view = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "createView"
      ])(arr);
      const u = new Uint8Array(PRF.outputLen);
      // DK = T1 + T2 +  + Tdklen/hlen
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "asyncLoop"
        ])(c - 1, asyncTick, () => {
          // Uc = PRF(Password, Uc1)
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    } //# sourceMappingURL=pbkdf2.js.map
  },
  "[project]/node_modules/@noble/hashes/scrypt.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["scrypt", () => scrypt, "scryptAsync", () => scryptAsync]);
    /**
     * RFC 7914 Scrypt KDF. Can be used to create a key from password and salt.
     * @module
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$pbkdf2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/hashes/pbkdf2.js [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$sha2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/hashes/sha2.js [app-route] (ecmascript)",
      );
    // prettier-ignore
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/utils.js [app-route] (ecmascript)");
    // The main Scrypt loop: uses Salsa extensively.
    // Six versions of the function were tried, this is the fastest one.
    // prettier-ignore
    function XorAndSalsa(prev, pi, input, ii, out, oi) {
    // Based on https://cr.yp.to/salsa20.html
    // Xor blocks
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    // Save state to temporary variables (salsa)
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    // Main loop (salsa)
    for(let i = 0; i < 8; i += 2){
        x04 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x00 + x12 | 0, 7);
        x08 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x04 + x00 | 0, 9);
        x12 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x08 + x04 | 0, 13);
        x00 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x12 + x08 | 0, 18);
        x09 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x05 + x01 | 0, 7);
        x13 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x09 + x05 | 0, 9);
        x01 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x13 + x09 | 0, 13);
        x05 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x01 + x13 | 0, 18);
        x14 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x10 + x06 | 0, 7);
        x02 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x14 + x10 | 0, 9);
        x06 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x02 + x14 | 0, 13);
        x10 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x06 + x02 | 0, 18);
        x03 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x15 + x11 | 0, 7);
        x07 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x03 + x15 | 0, 9);
        x11 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x07 + x03 | 0, 13);
        x15 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x11 + x07 | 0, 18);
        x01 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x00 + x03 | 0, 7);
        x02 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x01 + x00 | 0, 9);
        x03 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x02 + x01 | 0, 13);
        x00 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x03 + x02 | 0, 18);
        x06 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x05 + x04 | 0, 7);
        x07 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x06 + x05 | 0, 9);
        x04 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x07 + x06 | 0, 13);
        x05 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x04 + x07 | 0, 18);
        x11 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x10 + x09 | 0, 7);
        x08 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x11 + x10 | 0, 9);
        x09 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x08 + x11 | 0, 13);
        x10 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x09 + x08 | 0, 18);
        x12 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x15 + x14 | 0, 7);
        x13 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x12 + x15 | 0, 9);
        x14 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x13 + x12 | 0, 13);
        x15 ^= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x14 + x13 | 0, 18);
    }
    // Write output (salsa)
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
}
    function BlockMix(input, ii, out, oi, r) {
      // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)
      let head = oi + 0;
      let tail = oi + 16 * r;
      for (let i = 0; i < 16; i++) out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]
      for (let i = 0; i < r; i++, head += 16, ii += 16) {
        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1
        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])
        if (i > 0) tail += 16; // First iteration overwrites tmp value in tail
        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])
      }
    }
    // Common prologue and epilogue for sync/async functions
    function scryptInit(password, salt, _opts) {
      // Maxmem - 1GB+1KB by default
      const opts = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "checkOpts"
      ])(
        {
          dkLen: 32,
          asyncTick: 10,
          maxmem: 1024 ** 3 + 1024,
        },
        _opts,
      );
      const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "anumber"
      ])(N, "N");
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "anumber"
      ])(r, "r");
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "anumber"
      ])(p, "p");
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "anumber"
      ])(dkLen, "dkLen");
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "anumber"
      ])(asyncTick, "asyncTick");
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "anumber"
      ])(maxmem, "maxmem");
      if (onProgress !== undefined && typeof onProgress !== "function")
        throw new Error("progressCb must be a function");
      const blockSize = 128 * r;
      const blockSize32 = blockSize / 4;
      // Max N is 2^32 (Integrify is 32-bit).
      // Real limit can be 2^22: some JS engines limit Uint8Array to 4GB.
      // Spec check `N >= 2^(blockSize / 8)` is not done for compat with popular libs,
      // which used incorrect r: 1, p: 8. Also, the check seems to be a spec error:
      // https://www.rfc-editor.org/errata_search.php?rfc=7914
      const pow32 = Math.pow(2, 32);
      if (N <= 1 || (N & (N - 1)) !== 0 || N > pow32)
        throw new Error('"N" expected a power of 2, and 2^1 <= N <= 2^32');
      if (p < 1 || p > ((pow32 - 1) * 32) / blockSize)
        throw new Error('"p" expected integer 1..((2^32 - 1) * 32) / (128 * r)');
      if (dkLen < 1 || dkLen > (pow32 - 1) * 32)
        throw new Error('"dkLen" expected integer 1..(2^32 - 1) * 32');
      const memUsed = blockSize * (N + p);
      if (memUsed > maxmem)
        throw new Error('"maxmem" limit was hit, expected 128*r*(N+p) <= "maxmem"=' + maxmem);
      // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)
      // Since it has only one iteration there is no reason to use async variant
      const B = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$pbkdf2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "pbkdf2"
      ])(
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$sha2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "sha256"
        ],
        password,
        salt,
        {
          c: 1,
          dkLen: blockSize * p,
        },
      );
      const B32 = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "u32"
      ])(B);
      // Re-used between parallel iterations. Array(iterations) of B
      const V = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "u32"
      ])(new Uint8Array(blockSize * N));
      const tmp = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "u32"
      ])(new Uint8Array(blockSize));
      let blockMixCb = () => {};
      if (onProgress) {
        const totalBlockMix = 2 * N * p;
        // Invoke callback if progress changes from 10.01 to 10.02
        // Allows to draw smooth progress bar on up to 8K screen
        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);
        let blockMixCnt = 0;
        blockMixCb = () => {
          blockMixCnt++;
          if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
            onProgress(blockMixCnt / totalBlockMix);
        };
      }
      return {
        N,
        r,
        p,
        dkLen,
        blockSize32,
        V,
        B32,
        B,
        tmp,
        blockMixCb,
        asyncTick,
      };
    }
    function scryptOutput(password, dkLen, B, V, tmp) {
      const res = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$pbkdf2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "pbkdf2"
      ])(
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$sha2$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "sha256"
        ],
        password,
        B,
        {
          c: 1,
          dkLen,
        },
      );
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "clean"
      ])(B, V, tmp);
      return res;
    }
    function scrypt(password, salt, opts) {
      const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(
        password,
        salt,
        opts,
      );
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "swap32IfBE"
      ])(B32);
      for (let pi = 0; pi < p; pi++) {
        const Pi = blockSize32 * pi;
        for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]
        for (let i = 0, pos = 0; i < N - 1; i++) {
          BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);
          blockMixCb();
        }
        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
        blockMixCb();
        for (let i = 0; i < N; i++) {
          // First u32 of the last 64-byte block (u32 is LE)
          // & (N - 1) is % N as N is a power of 2, N & (N - 1) = 0 is checked above; >>> 0 for unsigned, input fits in u32
          const j = (B32[Pi + blockSize32 - 16] & (N - 1)) >>> 0; // j = Integrify(X) % iterations
          for (let k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
          BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
          blockMixCb();
        }
      }
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "swap32IfBE"
      ])(B32);
      return scryptOutput(password, dkLen, B, V, tmp);
    }
    async function scryptAsync(password, salt, opts) {
      const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(
        password,
        salt,
        opts,
      );
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "swap32IfBE"
      ])(B32);
      for (let pi = 0; pi < p; pi++) {
        const Pi = blockSize32 * pi;
        for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]
        let pos = 0;
        await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "asyncLoop"
        ])(N - 1, asyncTick, () => {
          BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);
          blockMixCb();
        });
        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
        blockMixCb();
        await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "asyncLoop"
        ])(N, asyncTick, () => {
          // First u32 of the last 64-byte block (u32 is LE)
          // & (N - 1) is % N as N is a power of 2, N & (N - 1) = 0 is checked above; >>> 0 for unsigned, input fits in u32
          const j = (B32[Pi + blockSize32 - 16] & (N - 1)) >>> 0; // j = Integrify(X) % iterations
          for (let k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
          BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
          blockMixCb();
        });
      }
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "swap32IfBE"
      ])(B32);
      return scryptOutput(password, dkLen, B, V, tmp);
    } //# sourceMappingURL=scrypt.js.map
  },
  "[project]/node_modules/@noble/ciphers/utils.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    /**
     * Utilities for hex, bytes, CSPRNG.
     * @module
     */ /*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */ /** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ __turbopack_context__.s(
      [
        "abool",
        () => abool,
        "abytes",
        () => abytes,
        "aexists",
        () => aexists,
        "anumber",
        () => anumber,
        "aoutput",
        () => aoutput,
        "bytesToHex",
        () => bytesToHex,
        "bytesToNumberBE",
        () => bytesToNumberBE,
        "bytesToUtf8",
        () => bytesToUtf8,
        "checkOpts",
        () => checkOpts,
        "clean",
        () => clean,
        "complexOverlapBytes",
        () => complexOverlapBytes,
        "concatBytes",
        () => concatBytes,
        "copyBytes",
        () => copyBytes,
        "createView",
        () => createView,
        "equalBytes",
        () => equalBytes,
        "getOutput",
        () => getOutput,
        "hexToBytes",
        () => hexToBytes,
        "hexToNumber",
        () => hexToNumber,
        "isAligned32",
        () => isAligned32,
        "isBytes",
        () => isBytes,
        "isLE",
        () => isLE,
        "managedNonce",
        () => managedNonce,
        "numberToBytesBE",
        () => numberToBytesBE,
        "overlapBytes",
        () => overlapBytes,
        "randomBytes",
        () => randomBytes,
        "u32",
        () => u32,
        "u64Lengths",
        () => u64Lengths,
        "u8",
        () => u8,
        "utf8ToBytes",
        () => utf8ToBytes,
        "wrapCipher",
        () => wrapCipher,
      ],
    );
    function isBytes(a) {
      return (
        a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array")
      );
    }
    function abool(b) {
      if (typeof b !== "boolean") throw new Error(`boolean expected, not ${b}`);
    }
    function anumber(n) {
      if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, got " + n);
    }
    function abytes(value, length, title = "") {
      const bytes = isBytes(value);
      const len = value?.length;
      const needsLen = length !== undefined;
      if (!bytes || (needsLen && len !== length)) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : "";
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
      }
      return value;
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed) throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes(out, undefined, "output");
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    const isLE = /* @__PURE__ */ (() =>
      new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
    // Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
    const hasHexBuiltin = /* @__PURE__ */ (() =>
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" &&
      typeof Uint8Array.fromHex === "function")();
    // Array where index 0xf0 (240) is mapped to string 'f0'
    const hexes = /* @__PURE__ */ Array.from(
      {
        length: 256,
      },
      (_, i) => i.toString(16).padStart(2, "0"),
    );
    function bytesToHex(bytes) {
      abytes(bytes);
      // @ts-ignore
      if (hasHexBuiltin) return bytes.toHex();
      // pre-caching improves the speed 6x
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    // We use optimized technique to convert hex string to byte array
    const asciis = {
      _0: 48,
      _9: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102,
    };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
      if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
      if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
      // @ts-ignore
      if (hasHexBuiltin) return Uint8Array.fromHex(hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2) throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error(
            'hex string expected, got non-hex character "' + char + '" at index ' + hi,
          );
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
      }
      return array;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : "0x" + hex); // Big Endian
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string") throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
    }
    function bytesToUtf8(bytes) {
      return new TextDecoder().decode(bytes);
    }
    function overlapBytes(a, b) {
      return (
        a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy
        a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end
        b.byteOffset < a.byteOffset + a.byteLength // b starts before a end
      );
    }
    function complexOverlapBytes(input, output) {
      // This is very cursed. It works somehow, but I'm completely unsure,
      // reasoning about overlapping aligned windows is very hard.
      if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)
        throw new Error("complex overlap of input and output is not supported");
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts == null || typeof opts !== "object") throw new Error("options must be defined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length) return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];
      return diff === 0;
    }
    const wrapCipher = (params, constructor) => {
      function wrappedCipher(key, ...args) {
        // Validate key
        abytes(key, undefined, "key");
        // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:
        if (!isLE) throw new Error("Non little-endian hardware is not yet supported");
        // Validate nonce if nonceLength is present
        if (params.nonceLength !== undefined) {
          const nonce = args[0];
          abytes(nonce, params.varSizeNonce ? undefined : params.nonceLength, "nonce");
        }
        // Validate AAD if tagLength present
        const tagl = params.tagLength;
        if (tagl && args[1] !== undefined) abytes(args[1], undefined, "AAD");
        const cipher = constructor(key, ...args);
        const checkOutput = (fnLength, output) => {
          if (output !== undefined) {
            if (fnLength !== 2) throw new Error("cipher output not supported");
            abytes(output, undefined, "output");
          }
        };
        // Create wrapped cipher with validation and single-use encryption
        let called = false;
        const wrCipher = {
          encrypt(data, output) {
            if (called) throw new Error("cannot encrypt() twice with same key + nonce");
            called = true;
            abytes(data);
            checkOutput(cipher.encrypt.length, output);
            return cipher.encrypt(data, output);
          },
          decrypt(data, output) {
            abytes(data);
            if (tagl && data.length < tagl)
              throw new Error('"ciphertext" expected length bigger than tagLength=' + tagl);
            checkOutput(cipher.decrypt.length, output);
            return cipher.decrypt(data, output);
          },
        };
        return wrCipher;
      }
      Object.assign(wrappedCipher, params);
      return wrappedCipher;
    };
    function getOutput(expectedLength, out, onlyAligned = true) {
      if (out === undefined) return new Uint8Array(expectedLength);
      if (out.length !== expectedLength)
        throw new Error(
          '"output" expected Uint8Array of length ' + expectedLength + ", got: " + out.length,
        );
      if (onlyAligned && !isAligned32(out)) throw new Error("invalid output, must be aligned");
      return out;
    }
    function u64Lengths(dataLength, aadLength, isLE) {
      abool(isLE);
      const num = new Uint8Array(16);
      const view = createView(num);
      view.setBigUint64(0, BigInt(aadLength), isLE);
      view.setBigUint64(8, BigInt(dataLength), isLE);
      return num;
    }
    function isAligned32(bytes) {
      return bytes.byteOffset % 4 === 0;
    }
    function copyBytes(bytes) {
      return Uint8Array.from(bytes);
    }
    function randomBytes(bytesLength = 32) {
      const cr = typeof globalThis === "object" ? globalThis.crypto : null;
      if (typeof cr?.getRandomValues !== "function")
        throw new Error("crypto.getRandomValues must be defined");
      return cr.getRandomValues(new Uint8Array(bytesLength));
    }
    function managedNonce(fn, randomBytes_ = randomBytes) {
      const { nonceLength } = fn;
      anumber(nonceLength);
      const addNonce = (nonce, ciphertext) => {
        const out = concatBytes(nonce, ciphertext);
        ciphertext.fill(0);
        return out;
      };
      // NOTE: we cannot support DST here, it would be mistake:
      // - we don't know how much dst length cipher requires
      // - nonce may unalign dst and break everything
      // - we create new u8a anyway (concatBytes)
      // - previously we passed all args to cipher, but that was mistake!
      return (key, ...args) => ({
        encrypt(plaintext) {
          abytes(plaintext);
          const nonce = randomBytes_(nonceLength);
          const encrypted = fn(key, nonce, ...args).encrypt(plaintext);
          // @ts-ignore
          if (encrypted instanceof Promise) return encrypted.then((ct) => addNonce(nonce, ct));
          return addNonce(nonce, encrypted);
        },
        decrypt(ciphertext) {
          abytes(ciphertext);
          const nonce = ciphertext.subarray(0, nonceLength);
          const decrypted = ciphertext.subarray(nonceLength);
          return fn(key, nonce, ...args).decrypt(decrypted);
        },
      });
    } //# sourceMappingURL=utils.js.map
  },
  "[project]/node_modules/@noble/ciphers/_arx.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "_XorStreamPRG",
      () => _XorStreamPRG,
      "createCipher",
      () => createCipher,
      "createPRG",
      () => createPRG,
      "rotl",
      () => rotl,
    ]);
    /**
 * Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.

RFC8439 requires multi-step cipher stream, where
authKey starts with counter: 0, actual msg with counter: 1.

For this, we need a way to re-use nonce / counter:

    const counter = new Uint8Array(4);
    chacha(..., counter, ...); // counter is now 1
    chacha(..., counter, ...); // counter is now 2

This is complicated:

- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB
- Original papers don't allow mutating counters
- Counter overflow is undefined [^1]
- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it
- Caveat: Cannot be re-used through all cases:
- * chacha has (counter | nonce)
- * xchacha has (nonce16 | counter | nonce16)
- Idea B: separate nonce / counter and provide separate API for counter re-use
- Caveat: there are different counter sizes depending on an algorithm.
- salsa & chacha also differ in structures of key & sigma:
  salsa20:      s[0] | k(4) | s[1] | nonce(2) | cnt(2) | s[2] | k(4) | s[3]
  chacha:       s(4) | k(8) | cnt(1) | nonce(3)
  chacha20orig: s(4) | k(8) | cnt(2) | nonce(2)
- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`
- Caveat: we can't re-use counter array

xchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal
(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).

[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/
[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2

 * @module
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/ciphers/utils.js [app-route] (ecmascript)",
      );
    // Replaces `TextEncoder`, which is not available in all environments
    const encodeStr = (str) => Uint8Array.from(str.split(""), (c) => c.charCodeAt(0));
    const sigma16 = encodeStr("expand 16-byte k");
    const sigma32 = encodeStr("expand 32-byte k");
    const sigma16_32 = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "u32"
    ])(sigma16);
    const sigma32_32 = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "u32"
    ])(sigma32);
    function rotl(a, b) {
      return (a << b) | (a >>> (32 - b));
    }
    // Is byte array aligned to 4 byte offset (u32)?
    function isAligned32(b) {
      return b.byteOffset % 4 === 0;
    }
    // Salsa and Chacha block length is always 512-bit
    const BLOCK_LEN = 64;
    const BLOCK_LEN32 = 16;
    // new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]
    // new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]
    const MAX_COUNTER = 2 ** 32 - 1;
    const U32_EMPTY = Uint32Array.of();
    function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
      const len = data.length;
      const block = new Uint8Array(BLOCK_LEN);
      const b32 = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "u32"
      ])(block);
      // Make sure that buffers aligned to 4 bytes
      const isAligned = isAligned32(data) && isAligned32(output);
      const d32 = isAligned
        ? (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "u32"
          ])(data)
        : U32_EMPTY;
      const o32 = isAligned
        ? (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "u32"
          ])(output)
        : U32_EMPTY;
      for (let pos = 0; pos < len; counter++) {
        core(sigma, key, nonce, b32, counter, rounds);
        if (counter >= MAX_COUNTER) throw new Error("arx: counter overflow");
        const take = Math.min(BLOCK_LEN, len - pos);
        // aligned to 4 bytes
        if (isAligned && take === BLOCK_LEN) {
          const pos32 = pos / 4;
          if (pos % 4 !== 0) throw new Error("arx: invalid block position");
          for (let j = 0, posj; j < BLOCK_LEN32; j++) {
            posj = pos32 + j;
            o32[posj] = d32[posj] ^ b32[j];
          }
          pos += BLOCK_LEN;
          continue;
        }
        for (let j = 0, posj; j < take; j++) {
          posj = pos + j;
          output[posj] = data[posj] ^ block[j];
        }
        pos += take;
      }
    }
    function createCipher(core, opts) {
      const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "checkOpts"
      ])(
        {
          allowShortKeys: false,
          counterLength: 8,
          counterRight: false,
          rounds: 20,
        },
        opts,
      );
      if (typeof core !== "function") throw new Error("core must be a function");
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "anumber"
      ])(counterLength);
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "anumber"
      ])(rounds);
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "abool"
      ])(counterRight);
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "abool"
      ])(allowShortKeys);
      return (key, nonce, data, output, counter = 0) => {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "abytes"
        ])(key, undefined, "key");
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "abytes"
        ])(nonce, undefined, "nonce");
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "abytes"
        ])(data, undefined, "data");
        const len = data.length;
        if (output === undefined) output = new Uint8Array(len);
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "abytes"
        ])(output, undefined, "output");
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "anumber"
        ])(counter);
        if (counter < 0 || counter >= MAX_COUNTER) throw new Error("arx: counter overflow");
        if (output.length < len)
          throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
        const toClean = [];
        // Key & sigma
        // key=16 -> sigma16, k=key|key
        // key=32 -> sigma32, k=key
        let l = key.length;
        let k;
        let sigma;
        if (l === 32) {
          toClean.push(
            (k = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "copyBytes"
            ])(key)),
          );
          sigma = sigma32_32;
        } else if (l === 16 && allowShortKeys) {
          k = new Uint8Array(32);
          k.set(key);
          k.set(key, 16);
          sigma = sigma16_32;
          toClean.push(k);
        } else {
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "abytes"
          ])(key, 32, "arx key");
          throw new Error("invalid key size");
          // throw new Error(`"arx key" expected Uint8Array of length 32, got length=${l}`);
        }
        // Nonce
        // salsa20:      8   (8-byte counter)
        // chacha20orig: 8   (8-byte counter)
        // chacha20:     12  (4-byte counter)
        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)
        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)
        // Align nonce to 4 bytes
        if (!isAligned32(nonce))
          toClean.push(
            (nonce = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "copyBytes"
            ])(nonce)),
          );
        const k32 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "u32"
        ])(k);
        // hsalsa & hchacha: handle extended nonce
        if (extendNonceFn) {
          if (nonce.length !== 24) throw new Error(`arx: extended nonce must be 24 bytes`);
          extendNonceFn(
            sigma,
            k32,
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "u32"
            ])(nonce.subarray(0, 16)),
            k32,
          );
          nonce = nonce.subarray(16);
        }
        // Handle nonce counter
        const nonceNcLen = 16 - counterLength;
        if (nonceNcLen !== nonce.length)
          throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
        // Pad counter when nonce is 64 bit
        if (nonceNcLen !== 12) {
          const nc = new Uint8Array(12);
          nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
          nonce = nc;
          toClean.push(nonce);
        }
        const n32 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "u32"
        ])(nonce);
        runCipher(core, sigma, k32, n32, data, output, counter, rounds);
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "clean"
        ])(...toClean);
        return output;
      };
    }
    class _XorStreamPRG {
      blockLen;
      keyLen;
      nonceLen;
      state;
      buf;
      key;
      nonce;
      pos;
      ctr;
      cipher;
      constructor(cipher, blockLen, keyLen, nonceLen, seed) {
        this.cipher = cipher;
        this.blockLen = blockLen;
        this.keyLen = keyLen;
        this.nonceLen = nonceLen;
        this.state = new Uint8Array(this.keyLen + this.nonceLen);
        this.reseed(seed);
        this.ctr = 0;
        this.pos = this.blockLen;
        this.buf = new Uint8Array(this.blockLen);
        this.key = this.state.subarray(0, this.keyLen);
        this.nonce = this.state.subarray(this.keyLen);
      }
      reseed(seed) {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "abytes"
        ])(seed);
        if (!seed || seed.length === 0) throw new Error("entropy required");
        for (let i = 0; i < seed.length; i++) this.state[i % this.state.length] ^= seed[i];
        this.ctr = 0;
        this.pos = this.blockLen;
      }
      addEntropy(seed) {
        this.state.set(this.randomBytes(this.state.length));
        this.reseed(seed);
      }
      randomBytes(len) {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "anumber"
        ])(len);
        if (len === 0) return new Uint8Array(0);
        const out = new Uint8Array(len);
        let outPos = 0;
        // Leftovers
        if (this.pos < this.blockLen) {
          const take = Math.min(len, this.blockLen - this.pos);
          out.set(this.buf.subarray(this.pos, this.pos + take), 0);
          this.pos += take;
          outPos += take;
          if (outPos === len) return out; // fast path
        }
        // Full blocks directly to out
        const blocks = Math.floor((len - outPos) / this.blockLen);
        if (blocks > 0) {
          const blockBytes = blocks * this.blockLen;
          const b = out.subarray(outPos, outPos + blockBytes);
          this.cipher(this.key, this.nonce, b, b, this.ctr);
          this.ctr += blocks;
          outPos += blockBytes;
        }
        // Save leftovers
        const left = len - outPos;
        if (left > 0) {
          this.buf.fill(0);
          // NOTE: cipher will handle overflow
          this.cipher(this.key, this.nonce, this.buf, this.buf, this.ctr++);
          out.set(this.buf.subarray(0, left), outPos);
          this.pos = left;
        }
        return out;
      }
      clone() {
        return new _XorStreamPRG(
          this.cipher,
          this.blockLen,
          this.keyLen,
          this.nonceLen,
          this.randomBytes(this.state.length),
        );
      }
      clean() {
        this.pos = 0;
        this.ctr = 0;
        this.buf.fill(0);
        this.state.fill(0);
      }
    }
    const createPRG = (cipher, blockLen, keyLen, nonceLen) => {
      return (
        seed = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "randomBytes"
        ])(32),
      ) => new _XorStreamPRG(cipher, blockLen, keyLen, nonceLen, seed);
    }; //# sourceMappingURL=_arx.js.map
  },
  "[project]/node_modules/@noble/ciphers/_poly1305.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "Poly1305",
      () => Poly1305,
      "poly1305",
      () => poly1305,
      "wrapConstructorWithKey",
      () => wrapConstructorWithKey,
    ]);
    /**
     * Poly1305 ([PDF](https://cr.yp.to/mac/poly1305-20050329.pdf),
     * [wiki](https://en.wikipedia.org/wiki/Poly1305))
     * is a fast and parallel secret-key message-authentication code suitable for
     * a wide variety of applications. It was standardized in
     * [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439) and is now used in TLS 1.3.
     *
     * Polynomial MACs are not perfect for every situation:
     * they lack Random Key Robustness: the MAC can be forged, and can't be used in PAKE schemes.
     * See [invisible salamanders attack](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/).
     * To combat invisible salamanders, `hash(key)` can be included in ciphertext,
     * however, this would violate ciphertext indistinguishability:
     * an attacker would know which key was used - so `HKDF(key, i)`
     * could be used instead.
     *
     * Check out [original website](https://cr.yp.to/mac.html).
     * Based on Public Domain [poly1305-donna](https://github.com/floodyberry/poly1305-donna).
     * @module
     */ // prettier-ignore
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/ciphers/utils.js [app-route] (ecmascript)");
    function u8to16(a, i) {
      return (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);
    }
    function bytesToNumberLE(bytes) {
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "hexToNumber"
      ])(
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "bytesToHex"
        ])(Uint8Array.from(bytes).reverse()),
      );
    }
    /** Small version of `poly1305` without loop unrolling. Unused, provided for auditability. */ function poly1305_small(
      msg,
      key,
    ) {
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "abytes"
      ])(msg);
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "abytes"
      ])(key, 32, "key");
      const POW_2_130_5 = BigInt(2) ** BigInt(130) - BigInt(5); // 2^130-5
      const POW_2_128_1 = BigInt(2) ** BigInt(128) - BigInt(1); // 2^128-1
      const CLAMP_R = BigInt("0x0ffffffc0ffffffc0ffffffc0fffffff");
      const r = bytesToNumberLE(key.subarray(0, 16)) & CLAMP_R;
      const s = bytesToNumberLE(key.subarray(16));
      // Process by 16 byte chunks
      let acc = BigInt(0);
      for (let i = 0; i < msg.length; i += 16) {
        const m = msg.subarray(i, i + 16);
        const n = bytesToNumberLE(m) | (BigInt(1) << BigInt(8 * m.length));
        acc = ((acc + n) * r) % POW_2_130_5;
      }
      const res = (acc + s) & POW_2_128_1;
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "numberToBytesBE"
      ])(res, 16).reverse(); // LE
    }
    // Can be used to replace `computeTag` in chacha.ts. Unused, provided for auditability.
    // @ts-expect-error
    function poly1305_computeTag_small(authKey, lengths, ciphertext, AAD) {
      const res = [];
      const updatePadded2 = (msg) => {
        res.push(msg);
        const leftover = msg.length % 16;
        if (leftover) res.push(new Uint8Array(16).slice(leftover));
      };
      if (AAD) updatePadded2(AAD);
      updatePadded2(ciphertext);
      res.push(lengths);
      return poly1305_small(
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "concatBytes"
        ])(...res),
        authKey,
      );
    }
    class Poly1305 {
      blockLen = 16;
      outputLen = 16;
      buffer = new Uint8Array(16);
      r = new Uint16Array(10);
      h = new Uint16Array(10);
      pad = new Uint16Array(8);
      pos = 0;
      finished = false;
      // Can be speed-up using BigUint64Array, at the cost of complexity
      constructor(key) {
        key = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "copyBytes"
        ])(
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "abytes"
          ])(key, 32, "key"),
        );
        const t0 = u8to16(key, 0);
        const t1 = u8to16(key, 2);
        const t2 = u8to16(key, 4);
        const t3 = u8to16(key, 6);
        const t4 = u8to16(key, 8);
        const t5 = u8to16(key, 10);
        const t6 = u8to16(key, 12);
        const t7 = u8to16(key, 14);
        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47
        this.r[0] = t0 & 0x1fff;
        this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
        this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;
        this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
        this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;
        this.r[5] = (t4 >>> 1) & 0x1ffe;
        this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
        this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;
        this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
        this.r[9] = (t7 >>> 5) & 0x007f;
        for (let i = 0; i < 8; i++) this.pad[i] = u8to16(key, 16 + 2 * i);
      }
      process(data, offset, isLast = false) {
        const hibit = isLast ? 0 : 1 << 11;
        const { h, r } = this;
        const r0 = r[0];
        const r1 = r[1];
        const r2 = r[2];
        const r3 = r[3];
        const r4 = r[4];
        const r5 = r[5];
        const r6 = r[6];
        const r7 = r[7];
        const r8 = r[8];
        const r9 = r[9];
        const t0 = u8to16(data, offset + 0);
        const t1 = u8to16(data, offset + 2);
        const t2 = u8to16(data, offset + 4);
        const t3 = u8to16(data, offset + 6);
        const t4 = u8to16(data, offset + 8);
        const t5 = u8to16(data, offset + 10);
        const t6 = u8to16(data, offset + 12);
        const t7 = u8to16(data, offset + 14);
        let h0 = h[0] + (t0 & 0x1fff);
        let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);
        let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);
        let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);
        let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);
        let h5 = h[5] + ((t4 >>> 1) & 0x1fff);
        let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);
        let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);
        let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);
        let h9 = h[9] + ((t7 >>> 5) | hibit);
        let c = 0;
        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 0x1fff;
        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 0x1fff;
        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 0x1fff;
        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 0x1fff;
        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 0x1fff;
        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 0x1fff;
        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 0x1fff;
        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 0x1fff;
        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
        c = d4 >>> 13;
        d4 &= 0x1fff;
        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 0x1fff;
        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
        c = d5 >>> 13;
        d5 &= 0x1fff;
        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 0x1fff;
        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
        c = d6 >>> 13;
        d6 &= 0x1fff;
        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 0x1fff;
        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
        c = d7 >>> 13;
        d7 &= 0x1fff;
        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 0x1fff;
        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
        c = d8 >>> 13;
        d8 &= 0x1fff;
        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 0x1fff;
        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
        c = d9 >>> 13;
        d9 &= 0x1fff;
        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
        c += d9 >>> 13;
        d9 &= 0x1fff;
        c = ((c << 2) + c) | 0;
        c = (c + d0) | 0;
        d0 = c & 0x1fff;
        c = c >>> 13;
        d1 += c;
        h[0] = d0;
        h[1] = d1;
        h[2] = d2;
        h[3] = d3;
        h[4] = d4;
        h[5] = d5;
        h[6] = d6;
        h[7] = d7;
        h[8] = d8;
        h[9] = d9;
      }
      finalize() {
        const { h, pad } = this;
        const g = new Uint16Array(10);
        let c = h[1] >>> 13;
        h[1] &= 0x1fff;
        for (let i = 2; i < 10; i++) {
          h[i] += c;
          c = h[i] >>> 13;
          h[i] &= 0x1fff;
        }
        h[0] += c * 5;
        c = h[0] >>> 13;
        h[0] &= 0x1fff;
        h[1] += c;
        c = h[1] >>> 13;
        h[1] &= 0x1fff;
        h[2] += c;
        g[0] = h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;
        for (let i = 1; i < 10; i++) {
          g[i] = h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 0x1fff;
        }
        g[9] -= 1 << 13;
        let mask = (c ^ 1) - 1;
        for (let i = 0; i < 10; i++) g[i] &= mask;
        mask = ~mask;
        for (let i = 0; i < 10; i++) h[i] = (h[i] & mask) | g[i];
        h[0] = (h[0] | (h[1] << 13)) & 0xffff;
        h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;
        h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;
        h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;
        h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;
        h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;
        h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;
        h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;
        let f = h[0] + pad[0];
        h[0] = f & 0xffff;
        for (let i = 1; i < 8; i++) {
          f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;
          h[i] = f & 0xffff;
        }
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "clean"
        ])(g);
      }
      update(data) {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "aexists"
        ])(this);
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "abytes"
        ])(data);
        data = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "copyBytes"
        ])(data);
        const { buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          // Fast path: we have at least one block in input
          if (take === blockLen) {
            for (; blockLen <= len - pos; pos += blockLen) this.process(data, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(buffer, 0, false);
            this.pos = 0;
          }
        }
        return this;
      }
      destroy() {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "clean"
        ])(this.h, this.r, this.buffer, this.pad);
      }
      digestInto(out) {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "aexists"
        ])(this);
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "aoutput"
        ])(out, this);
        this.finished = true;
        const { buffer, h } = this;
        let { pos } = this;
        if (pos) {
          buffer[pos++] = 1;
          for (; pos < 16; pos++) buffer[pos] = 0;
          this.process(buffer, 0, true);
        }
        this.finalize();
        let opos = 0;
        for (let i = 0; i < 8; i++) {
          out[opos++] = h[i] >>> 0;
          out[opos++] = h[i] >>> 8;
        }
        return out;
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
    }
    function wrapConstructorWithKey(hashCons) {
      const hashC = (msg, key) => hashCons(key).update(msg).digest();
      const tmp = hashCons(new Uint8Array(32)); // tmp array, used just once below
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (key) => hashCons(key);
      return hashC;
    }
    const poly1305 = /** @__PURE__ */ (() => wrapConstructorWithKey((key) => new Poly1305(key)))(); //# sourceMappingURL=_poly1305.js.map
  },
  "[project]/node_modules/@noble/ciphers/chacha.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "_poly1305_aead",
      () => _poly1305_aead,
      "chacha12",
      () => chacha12,
      "chacha20",
      () => chacha20,
      "chacha20orig",
      () => chacha20orig,
      "chacha20poly1305",
      () => chacha20poly1305,
      "chacha8",
      () => chacha8,
      "hchacha",
      () => hchacha,
      "rngChacha20",
      () => rngChacha20,
      "rngChacha8",
      () => rngChacha8,
      "xchacha20",
      () => xchacha20,
      "xchacha20poly1305",
      () => xchacha20poly1305,
    ]);
    /**
     * ChaCha stream cipher, released
     * in 2008. Developed after Salsa20, ChaCha aims to increase diffusion per round.
     * It was standardized in [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439) and
     * is now used in TLS 1.3.
     *
     * [XChaCha20](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha)
     * extended-nonce variant is also provided. Similar to XSalsa, it's safe to use with
     * randomly-generated nonces.
     *
     * Check out [PDF](http://cr.yp.to/chacha/chacha-20080128.pdf) and
     * [wiki](https://en.wikipedia.org/wiki/Salsa20) and
     * [website](https://cr.yp.to/chacha.html).
     *
     * @module
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/ciphers/_arx.js [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_poly1305$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/ciphers/_poly1305.js [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@noble/ciphers/utils.js [app-route] (ecmascript)",
      );
    /**
     * ChaCha core function. It is implemented twice:
     * 1. Simple loop (chachaCore_small, hchacha_small)
     * 2. Unrolled loop (chachaCore, hchacha) - 4x faster, but larger & harder to read
     * The specific implementation is selected in `createCipher` below.
     */ /** quarter-round */ // prettier-ignore
    function chachaQR(x, a, b, c, d) {
    x[a] = x[a] + x[b] | 0;
    x[d] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x[d] ^ x[a], 16);
    x[c] = x[c] + x[d] | 0;
    x[b] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x[b] ^ x[c], 12);
    x[a] = x[a] + x[b] | 0;
    x[d] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x[d] ^ x[a], 8);
    x[c] = x[c] + x[d] | 0;
    x[b] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x[b] ^ x[c], 7);
}
    /** single round */ function chachaRound(x, rounds = 20) {
      for (let r = 0; r < rounds; r += 2) {
        chachaQR(x, 0, 4, 8, 12);
        chachaQR(x, 1, 5, 9, 13);
        chachaQR(x, 2, 6, 10, 14);
        chachaQR(x, 3, 7, 11, 15);
        chachaQR(x, 0, 5, 10, 15);
        chachaQR(x, 1, 6, 11, 12);
        chachaQR(x, 2, 7, 8, 13);
        chachaQR(x, 3, 4, 9, 14);
      }
    }
    const ctmp = /* @__PURE__ */ new Uint32Array(16);
    /** Small version of chacha without loop unrolling. Unused, provided for auditability. */ // prettier-ignore
    function chacha(s, k, i, out, isHChacha = true, rounds = 20) {
    // Create initial array using common pattern
    const y = Uint32Array.from([
        s[0],
        s[1],
        s[2],
        s[3],
        k[0],
        k[1],
        k[2],
        k[3],
        k[4],
        k[5],
        k[6],
        k[7],
        i[0],
        i[1],
        i[2],
        i[3]
    ]);
    const x = ctmp;
    x.set(y);
    chachaRound(x, rounds);
    // hchacha extracts 8 specific bytes, chacha adds orig to result
    if (isHChacha) {
        const xindexes = [
            0,
            1,
            2,
            3,
            12,
            13,
            14,
            15
        ];
        for(let i = 0; i < 8; i++)out[i] = x[xindexes[i]];
    } else {
        for(let i = 0; i < 16; i++)out[i] = y[i] + x[i] | 0;
    }
}
    /** Identical to `chachaCore`. Unused. */ // @ts-ignore
    const chachaCore_small = (s, k, n, out, cnt, rounds) =>
      chacha(s, k, Uint32Array.from([n[0], n[1], cnt, 0]), out, false, rounds);
    /** Identical to `hchacha`. Unused. */ // @ts-ignore
    const hchacha_small = chacha;
    /** Identical to `chachaCore_small`. Unused. */ // prettier-ignore
    function chachaCore(s, k, n, out, cnt, rounds = 20) {
    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter	Nonce   Nonce
    // Save state to temporary variables
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for(let r = 0; r < rounds; r += 2){
        x00 = x00 + x04 | 0;
        x12 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["rotl"])(x04 ^ x09, 7);
    }
    // Write output
    let oi = 0;
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
}
    function hchacha(s, k, i, out) {
      let x00 = s[0],
        x01 = s[1],
        x02 = s[2],
        x03 = s[3],
        x04 = k[0],
        x05 = k[1],
        x06 = k[2],
        x07 = k[3],
        x08 = k[4],
        x09 = k[5],
        x10 = k[6],
        x11 = k[7],
        x12 = i[0],
        x13 = i[1],
        x14 = i[2],
        x15 = i[3];
      for (let r = 0; r < 20; r += 2) {
        x00 = (x00 + x04) | 0;
        x12 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x12 ^ x00, 16);
        x08 = (x08 + x12) | 0;
        x04 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x04 ^ x08, 12);
        x00 = (x00 + x04) | 0;
        x12 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x12 ^ x00, 8);
        x08 = (x08 + x12) | 0;
        x04 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x04 ^ x08, 7);
        x01 = (x01 + x05) | 0;
        x13 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x13 ^ x01, 16);
        x09 = (x09 + x13) | 0;
        x05 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x05 ^ x09, 12);
        x01 = (x01 + x05) | 0;
        x13 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x13 ^ x01, 8);
        x09 = (x09 + x13) | 0;
        x05 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x05 ^ x09, 7);
        x02 = (x02 + x06) | 0;
        x14 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x14 ^ x02, 16);
        x10 = (x10 + x14) | 0;
        x06 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x06 ^ x10, 12);
        x02 = (x02 + x06) | 0;
        x14 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x14 ^ x02, 8);
        x10 = (x10 + x14) | 0;
        x06 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x06 ^ x10, 7);
        x03 = (x03 + x07) | 0;
        x15 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x15 ^ x03, 16);
        x11 = (x11 + x15) | 0;
        x07 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x07 ^ x11, 12);
        x03 = (x03 + x07) | 0;
        x15 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x15 ^ x03, 8);
        x11 = (x11 + x15) | 0;
        x07 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x07 ^ x11, 7);
        x00 = (x00 + x05) | 0;
        x15 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x15 ^ x00, 16);
        x10 = (x10 + x15) | 0;
        x05 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x05 ^ x10, 12);
        x00 = (x00 + x05) | 0;
        x15 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x15 ^ x00, 8);
        x10 = (x10 + x15) | 0;
        x05 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x05 ^ x10, 7);
        x01 = (x01 + x06) | 0;
        x12 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x12 ^ x01, 16);
        x11 = (x11 + x12) | 0;
        x06 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x06 ^ x11, 12);
        x01 = (x01 + x06) | 0;
        x12 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x12 ^ x01, 8);
        x11 = (x11 + x12) | 0;
        x06 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x06 ^ x11, 7);
        x02 = (x02 + x07) | 0;
        x13 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x13 ^ x02, 16);
        x08 = (x08 + x13) | 0;
        x07 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x07 ^ x08, 12);
        x02 = (x02 + x07) | 0;
        x13 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x13 ^ x02, 8);
        x08 = (x08 + x13) | 0;
        x07 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x07 ^ x08, 7);
        x03 = (x03 + x04) | 0;
        x14 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x14 ^ x03, 16);
        x09 = (x09 + x14) | 0;
        x04 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x04 ^ x09, 12);
        x03 = (x03 + x04) | 0;
        x14 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x14 ^ x03, 8);
        x09 = (x09 + x14) | 0;
        x04 = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "rotl"
        ])(x04 ^ x09, 7);
      }
      let oi = 0;
      out[oi++] = x00;
      out[oi++] = x01;
      out[oi++] = x02;
      out[oi++] = x03;
      out[oi++] = x12;
      out[oi++] = x13;
      out[oi++] = x14;
      out[oi++] = x15;
    }
    const chacha20orig = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createCipher"
    ])(chachaCore, {
      counterRight: false,
      counterLength: 8,
      allowShortKeys: true,
    });
    const chacha20 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createCipher"
    ])(chachaCore, {
      counterRight: false,
      counterLength: 4,
      allowShortKeys: false,
    });
    const xchacha20 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createCipher"
    ])(chachaCore, {
      counterRight: false,
      counterLength: 8,
      extendNonceFn: hchacha,
      allowShortKeys: false,
    });
    const chacha8 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createCipher"
    ])(chachaCore, {
      counterRight: false,
      counterLength: 4,
      rounds: 8,
    });
    const chacha12 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createCipher"
    ])(chachaCore, {
      counterRight: false,
      counterLength: 4,
      rounds: 12,
    });
    const ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
    // Pad to digest size with zeros
    const updatePadded = (h, msg) => {
      h.update(msg);
      const leftover = msg.length % 16;
      if (leftover) h.update(ZEROS16.subarray(leftover));
    };
    const ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
    function computeTag(fn, key, nonce, ciphertext, AAD) {
      if (AAD !== undefined)
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "abytes"
        ])(AAD, undefined, "AAD");
      const authKey = fn(key, nonce, ZEROS32);
      const lengths = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "u64Lengths"
      ])(ciphertext.length, AAD ? AAD.length : 0, true);
      // Methods below can be replaced with
      // return poly1305_computeTag_small(authKey, lengths, ciphertext, AAD)
      const h =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_poly1305$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "poly1305"
        ].create(authKey);
      if (AAD) updatePadded(h, AAD);
      updatePadded(h, ciphertext);
      h.update(lengths);
      const res = h.digest();
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "clean"
      ])(authKey, lengths);
      return res;
    }
    const _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
      const tagLength = 16;
      return {
        encrypt(plaintext, output) {
          const plength = plaintext.length;
          output = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "getOutput"
          ])(plength + tagLength, output, false);
          output.set(plaintext);
          const oPlain = output.subarray(0, -tagLength);
          // Actual encryption
          xorStream(key, nonce, oPlain, oPlain, 1);
          const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
          output.set(tag, plength); // append tag
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "clean"
          ])(tag);
          return output;
        },
        decrypt(ciphertext, output) {
          output = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "getOutput"
          ])(ciphertext.length - tagLength, output, false);
          const data = ciphertext.subarray(0, -tagLength);
          const passedTag = ciphertext.subarray(-tagLength);
          const tag = computeTag(xorStream, key, nonce, data, AAD);
          if (
            !(0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "equalBytes"
            ])(passedTag, tag)
          )
            throw new Error("invalid tag");
          output.set(ciphertext.subarray(0, -tagLength));
          // Actual decryption
          xorStream(key, nonce, output, output, 1); // start stream with i=1
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "clean"
          ])(tag);
          return output;
        },
      };
    };
    const chacha20poly1305 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "wrapCipher"
    ])(
      {
        blockSize: 64,
        nonceLength: 12,
        tagLength: 16,
      },
      _poly1305_aead(chacha20),
    );
    const xchacha20poly1305 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "wrapCipher"
    ])(
      {
        blockSize: 64,
        nonceLength: 24,
        tagLength: 16,
      },
      _poly1305_aead(xchacha20),
    );
    const rngChacha20 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createPRG"
    ])(chacha20orig, 64, 32, 8);
    const rngChacha8 = /* @__PURE__ */ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$_arx$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
      "createPRG"
    ])(chacha8, 64, 32, 12); //# sourceMappingURL=chacha.js.map
  },
  "[project]/node_modules/better-call/dist/error.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "APIError",
      () => APIError,
      "BetterCallError",
      () => BetterCallError,
      "ValidationError",
      () => ValidationError,
      "hideInternalStackFrames",
      () => hideInternalStackFrames,
      "makeErrorForHideStackFrame",
      () => makeErrorForHideStackFrame,
      "statusCodes",
      () => statusCodes,
    ]);
    //#region src/error.ts
    function isErrorStackTraceLimitWritable() {
      const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
      if (desc === void 0) return Object.isExtensible(Error);
      return Object.prototype.hasOwnProperty.call(desc, "writable")
        ? desc.writable
        : desc.set !== void 0;
    }
    /**
     * Hide internal stack frames from the error stack trace.
     */ function hideInternalStackFrames(stack) {
      const lines = stack.split("\n    at ");
      if (lines.length <= 1) return stack;
      lines.splice(1, 1);
      return lines.join("\n    at ");
    }
    /**
     * Creates a custom error class that hides stack frames.
     */ function makeErrorForHideStackFrame(Base, clazz) {
      class HideStackFramesError extends Base {
        #hiddenStack;
        constructor(...args) {
          if (isErrorStackTraceLimitWritable()) {
            const limit = Error.stackTraceLimit;
            Error.stackTraceLimit = 0;
            super(...args);
            Error.stackTraceLimit = limit;
          } else super(...args);
          const stack = /* @__PURE__ */ new Error().stack;
          if (stack)
            this.#hiddenStack = hideInternalStackFrames(stack.replace(/^Error/, this.name));
        }
        get errorStack() {
          return this.#hiddenStack;
        }
      }
      Object.defineProperty(HideStackFramesError.prototype, "constructor", {
        get() {
          return clazz;
        },
        enumerable: false,
        configurable: true,
      });
      return HideStackFramesError;
    }
    const statusCodes = {
      OK: 200,
      CREATED: 201,
      ACCEPTED: 202,
      NO_CONTENT: 204,
      MULTIPLE_CHOICES: 300,
      MOVED_PERMANENTLY: 301,
      FOUND: 302,
      SEE_OTHER: 303,
      NOT_MODIFIED: 304,
      TEMPORARY_REDIRECT: 307,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      PAYMENT_REQUIRED: 402,
      FORBIDDEN: 403,
      NOT_FOUND: 404,
      METHOD_NOT_ALLOWED: 405,
      NOT_ACCEPTABLE: 406,
      PROXY_AUTHENTICATION_REQUIRED: 407,
      REQUEST_TIMEOUT: 408,
      CONFLICT: 409,
      GONE: 410,
      LENGTH_REQUIRED: 411,
      PRECONDITION_FAILED: 412,
      PAYLOAD_TOO_LARGE: 413,
      URI_TOO_LONG: 414,
      UNSUPPORTED_MEDIA_TYPE: 415,
      RANGE_NOT_SATISFIABLE: 416,
      EXPECTATION_FAILED: 417,
      "I'M_A_TEAPOT": 418,
      MISDIRECTED_REQUEST: 421,
      UNPROCESSABLE_ENTITY: 422,
      LOCKED: 423,
      FAILED_DEPENDENCY: 424,
      TOO_EARLY: 425,
      UPGRADE_REQUIRED: 426,
      PRECONDITION_REQUIRED: 428,
      TOO_MANY_REQUESTS: 429,
      REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
      UNAVAILABLE_FOR_LEGAL_REASONS: 451,
      INTERNAL_SERVER_ERROR: 500,
      NOT_IMPLEMENTED: 501,
      BAD_GATEWAY: 502,
      SERVICE_UNAVAILABLE: 503,
      GATEWAY_TIMEOUT: 504,
      HTTP_VERSION_NOT_SUPPORTED: 505,
      VARIANT_ALSO_NEGOTIATES: 506,
      INSUFFICIENT_STORAGE: 507,
      LOOP_DETECTED: 508,
      NOT_EXTENDED: 510,
      NETWORK_AUTHENTICATION_REQUIRED: 511,
    };
    var InternalAPIError = class extends Error {
      constructor(
        status = "INTERNAL_SERVER_ERROR",
        body = void 0,
        headers = {},
        statusCode = typeof status === "number" ? status : statusCodes[status],
      ) {
        super(
          body?.message,
          body?.cause
            ? {
                cause: body.cause,
              }
            : void 0,
        );
        this.status = status;
        this.body = body;
        this.headers = headers;
        this.statusCode = statusCode;
        this.name = "APIError";
        this.status = status;
        this.headers = headers;
        this.statusCode = statusCode;
        this.body = body
          ? {
              code: body?.message
                ?.toUpperCase()
                .replace(/ /g, "_")
                .replace(/[^A-Z0-9_]/g, ""),
              ...body,
            }
          : void 0;
      }
    };
    var ValidationError = class extends InternalAPIError {
      constructor(message, issues) {
        super(400, {
          message,
          code: "VALIDATION_ERROR",
        });
        this.message = message;
        this.issues = issues;
        this.issues = issues;
      }
    };
    var BetterCallError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "BetterCallError";
      }
    };
    const APIError = makeErrorForHideStackFrame(InternalAPIError, Error);
  },
  //# sourceMappingURL=error.mjs.map
  "[project]/node_modules/better-call/dist/utils.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "getBody",
      () => getBody,
      "isAPIError",
      () => isAPIError,
      "isRequest",
      () => isRequest,
      "tryCatch",
      () => tryCatch,
      "tryDecode",
      () => tryDecode,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/error.mjs [app-route] (ecmascript)",
      );
    //#region src/utils.ts
    const jsonContentTypeRegex = /^application\/([a-z0-9.+-]*\+)?json/i;
    async function getBody(request, allowedMediaTypes) {
      const contentType = request.headers.get("content-type") || "";
      const normalizedContentType = contentType.toLowerCase();
      if (!request.body) return;
      if (allowedMediaTypes && allowedMediaTypes.length > 0) {
        if (
          !allowedMediaTypes.some((allowed) => {
            const normalizedContentTypeBase = normalizedContentType.split(";")[0].trim();
            const normalizedAllowed = allowed.toLowerCase().trim();
            return (
              normalizedContentTypeBase === normalizedAllowed ||
              normalizedContentTypeBase.includes(normalizedAllowed)
            );
          })
        ) {
          if (!normalizedContentType)
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "APIError"
            ](415, {
              message: `Content-Type is required. Allowed types: ${allowedMediaTypes.join(", ")}`,
              code: "UNSUPPORTED_MEDIA_TYPE",
            });
          throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "APIError"
          ](415, {
            message: `Content-Type "${contentType}" is not allowed. Allowed types: ${allowedMediaTypes.join(", ")}`,
            code: "UNSUPPORTED_MEDIA_TYPE",
          });
        }
      }
      if (jsonContentTypeRegex.test(normalizedContentType)) return await request.json();
      if (normalizedContentType.includes("application/x-www-form-urlencoded")) {
        const formData = await request.formData();
        const result = {};
        formData.forEach((value, key) => {
          result[key] = value.toString();
        });
        return result;
      }
      if (normalizedContentType.includes("multipart/form-data")) {
        const formData = await request.formData();
        const result = {};
        formData.forEach((value, key) => {
          result[key] = value;
        });
        return result;
      }
      if (normalizedContentType.includes("text/plain")) return await request.text();
      if (normalizedContentType.includes("application/octet-stream"))
        return await request.arrayBuffer();
      if (
        normalizedContentType.includes("application/pdf") ||
        normalizedContentType.includes("image/") ||
        normalizedContentType.includes("video/")
      )
        return await request.blob();
      if (
        normalizedContentType.includes("application/stream") ||
        request.body instanceof ReadableStream
      )
        return request.body;
      return await request.text();
    }
    function isAPIError(error) {
      return (
        error instanceof
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "APIError"
          ] || error?.name === "APIError"
      );
    }
    function tryDecode(str) {
      try {
        return str.includes("%") ? decodeURIComponent(str) : str;
      } catch {
        return str;
      }
    }
    async function tryCatch(promise) {
      try {
        return {
          data: await promise,
          error: null,
        };
      } catch (error) {
        return {
          data: null,
          error,
        };
      }
    }
    /**
     * Check if an object is a `Request`
     * - `instanceof`: works for native Request instances
     * - `toString`: handles where instanceof check fails but the object is still a valid Request
     */ function isRequest(obj) {
      return obj instanceof Request || Object.prototype.toString.call(obj) === "[object Request]";
    }
  },
  //# sourceMappingURL=utils.mjs.map
  "[project]/node_modules/better-call/dist/to-response.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["toResponse", () => toResponse]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/error.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/utils.mjs [app-route] (ecmascript)",
      );
    //#region src/to-response.ts
    function isJSONSerializable(value) {
      if (value === void 0) return false;
      const t = typeof value;
      if (t === "string" || t === "number" || t === "boolean" || t === null) return true;
      if (t !== "object") return false;
      if (Array.isArray(value)) return true;
      if (value.buffer) return false;
      return (
        (value.constructor && value.constructor.name === "Object") ||
        typeof value.toJSON === "function"
      );
    }
    function safeStringify(obj, replacer, space) {
      let id = 0;
      const seen = /* @__PURE__ */ new WeakMap();
      const safeReplacer = (key, value) => {
        if (typeof value === "bigint") return value.toString();
        if (typeof value === "object" && value !== null) {
          if (seen.has(value)) return `[Circular ref-${seen.get(value)}]`;
          seen.set(value, id++);
        }
        if (replacer) return replacer(key, value);
        return value;
      };
      return JSON.stringify(obj, safeReplacer, space);
    }
    function isJSONResponse(value) {
      if (!value || typeof value !== "object") return false;
      return "_flag" in value && value._flag === "json";
    }
    function toResponse(data, init) {
      if (data instanceof Response) {
        if (init?.headers instanceof Headers)
          init.headers.forEach((value, key) => {
            data.headers.set(key, value);
          });
        return data;
      }
      if (isJSONResponse(data)) {
        const body$1 = data.body;
        const routerResponse = data.routerResponse;
        if (routerResponse instanceof Response) return routerResponse;
        const headers$1 = new Headers();
        if (routerResponse?.headers) {
          const headers$2 = new Headers(routerResponse.headers);
          for (const [key, value] of headers$2.entries()) headers$2.set(key, value);
        }
        if (data.headers)
          for (const [key, value] of new Headers(data.headers).entries()) headers$1.set(key, value);
        if (init?.headers)
          for (const [key, value] of new Headers(init.headers).entries()) headers$1.set(key, value);
        headers$1.set("Content-Type", "application/json");
        return new Response(JSON.stringify(body$1), {
          ...routerResponse,
          headers: headers$1,
          status: data.status ?? init?.status ?? routerResponse?.status,
          statusText: init?.statusText ?? routerResponse?.statusText,
        });
      }
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "isAPIError"
        ])(data)
      )
        return toResponse(data.body, {
          status: init?.status ?? data.statusCode,
          statusText: data.status.toString(),
          headers: init?.headers || data.headers,
        });
      let body = data;
      let headers = new Headers(init?.headers);
      if (!data) {
        if (data === null) body = JSON.stringify(null);
        headers.set("content-type", "application/json");
      } else if (typeof data === "string") {
        body = data;
        headers.set("Content-Type", "text/plain");
      } else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
        body = data;
        headers.set("Content-Type", "application/octet-stream");
      } else if (data instanceof Blob) {
        body = data;
        headers.set("Content-Type", data.type || "application/octet-stream");
      } else if (data instanceof FormData) body = data;
      else if (data instanceof URLSearchParams) {
        body = data;
        headers.set("Content-Type", "application/x-www-form-urlencoded");
      } else if (data instanceof ReadableStream) {
        body = data;
        headers.set("Content-Type", "application/octet-stream");
      } else if (isJSONSerializable(data)) {
        body = safeStringify(data);
        headers.set("Content-Type", "application/json");
      }
      return new Response(body, {
        ...init,
        headers,
      });
    }
  },
  //# sourceMappingURL=to-response.mjs.map
  "[project]/node_modules/better-call/dist/crypto.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "getCryptoKey",
      () => getCryptoKey,
      "signCookieValue",
      () => signCookieValue,
      "verifySignature",
      () => verifySignature,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/utils/dist/index.mjs [app-route] (ecmascript)",
      );
    //#region src/crypto.ts
    const algorithm = {
      name: "HMAC",
      hash: "SHA-256",
    };
    const getCryptoKey = async (secret) => {
      const secretBuf = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
      return await (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "getWebcryptoSubtle"
      ])().importKey("raw", secretBuf, algorithm, false, ["sign", "verify"]);
    };
    const verifySignature = async (base64Signature, value, secret) => {
      try {
        const signatureBinStr = atob(base64Signature);
        const signature = new Uint8Array(signatureBinStr.length);
        for (let i = 0, len = signatureBinStr.length; i < len; i++)
          signature[i] = signatureBinStr.charCodeAt(i);
        return await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "getWebcryptoSubtle"
        ])().verify(algorithm, secret, signature, new TextEncoder().encode(value));
      } catch (e) {
        return false;
      }
    };
    const makeSignature = async (value, secret) => {
      const key = await getCryptoKey(secret);
      const signature = await (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "getWebcryptoSubtle"
      ])().sign(algorithm.name, key, new TextEncoder().encode(value));
      return btoa(String.fromCharCode(...new Uint8Array(signature)));
    };
    const signCookieValue = async (value, secret) => {
      const signature = await makeSignature(value, secret);
      value = `${value}.${signature}`;
      value = encodeURIComponent(value);
      return value;
    };
  },
  //# sourceMappingURL=crypto.mjs.map
  "[project]/node_modules/better-call/dist/cookies.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "getCookieKey",
      () => getCookieKey,
      "parseCookies",
      () => parseCookies,
      "serializeCookie",
      () => serializeCookie,
      "serializeSignedCookie",
      () => serializeSignedCookie,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/utils.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/crypto.mjs [app-route] (ecmascript)",
      );
    //#region src/cookies.ts
    const getCookieKey = (key, prefix) => {
      let finalKey = key;
      if (prefix)
        if (prefix === "secure") finalKey = "__Secure-" + key;
        else if (prefix === "host") finalKey = "__Host-" + key;
        else return;
      return finalKey;
    };
    /**
     * Parse an HTTP Cookie header string and returning an object of all cookie
     * name-value pairs.
     *
     * Inspired by https://github.com/unjs/cookie-es/blob/main/src/cookie/parse.ts
     *
     * @param str the string representing a `Cookie` header value
     */ function parseCookies(str) {
      if (typeof str !== "string") throw new TypeError("argument str must be a string");
      const cookies = /* @__PURE__ */ new Map();
      let index = 0;
      while (index < str.length) {
        const eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) break;
        let endIdx = str.indexOf(";", index);
        if (endIdx === -1) endIdx = str.length;
        else if (endIdx < eqIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const key = str.slice(index, eqIdx).trim();
        if (!cookies.has(key)) {
          let val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.codePointAt(0) === 34) val = val.slice(1, -1);
          cookies.set(
            key,
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "tryDecode"
            ])(val),
          );
        }
        index = endIdx + 1;
      }
      return cookies;
    }
    const _serialize = (key, value, opt = {}) => {
      let cookie;
      if (opt?.prefix === "secure") cookie = `${`__Secure-${key}`}=${value}`;
      else if (opt?.prefix === "host") cookie = `${`__Host-${key}`}=${value}`;
      else cookie = `${key}=${value}`;
      if (key.startsWith("__Secure-") && !opt.secure) opt.secure = true;
      if (key.startsWith("__Host-")) {
        if (!opt.secure) opt.secure = true;
        if (opt.path !== "/") opt.path = "/";
        if (opt.domain) opt.domain = void 0;
      }
      if (opt && typeof opt.maxAge === "number" && opt.maxAge >= 0) {
        if (opt.maxAge > 3456e4)
          throw new Error(
            "Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.",
          );
        cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;
      }
      if (opt.domain && opt.prefix !== "host") cookie += `; Domain=${opt.domain}`;
      if (opt.path) cookie += `; Path=${opt.path}`;
      if (opt.expires) {
        if (opt.expires.getTime() - Date.now() > 3456e7)
          throw new Error(
            "Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.",
          );
        cookie += `; Expires=${opt.expires.toUTCString()}`;
      }
      if (opt.httpOnly) cookie += "; HttpOnly";
      if (opt.secure) cookie += "; Secure";
      if (opt.sameSite)
        cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;
      if (opt.partitioned) {
        if (!opt.secure) opt.secure = true;
        cookie += "; Partitioned";
      }
      return cookie;
    };
    const serializeCookie = (key, value, opt) => {
      value = encodeURIComponent(value);
      return _serialize(key, value, opt);
    };
    const serializeSignedCookie = async (key, value, secret, opt) => {
      value = await (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "signCookieValue"
      ])(value, secret);
      return _serialize(key, value, opt);
    };
  },
  //# sourceMappingURL=cookies.mjs.map
  "[project]/node_modules/better-call/dist/validator.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["runValidation", () => runValidation]);
    //#region src/validator.ts
    /**
     * Runs validation on body and query
     * @returns error and data object
     */ async function runValidation(options, context = {}) {
      let request = {
        body: context.body,
        query: context.query,
      };
      if (options.body) {
        const result = await options.body["~standard"].validate(context.body);
        if (result.issues)
          return {
            data: null,
            error: fromError(result.issues, "body"),
          };
        request.body = result.value;
      }
      if (options.query) {
        const result = await options.query["~standard"].validate(context.query);
        if (result.issues)
          return {
            data: null,
            error: fromError(result.issues, "query"),
          };
        request.query = result.value;
      }
      if (options.requireHeaders && !context.headers)
        return {
          data: null,
          error: {
            message: "Headers is required",
            issues: [],
          },
        };
      if (options.requireRequest && !context.request)
        return {
          data: null,
          error: {
            message: "Request is required",
            issues: [],
          },
        };
      return {
        data: request,
        error: null,
      };
    }
    function fromError(error, validating) {
      return {
        message: error
          .map((e) => {
            return `[${e.path?.length ? `${validating}.` + e.path.map((x) => (typeof x === "object" ? x.key : x)).join(".") : validating}] ${e.message}`;
          })
          .join("; "),
        issues: error,
      };
    }
  },
  //# sourceMappingURL=validator.mjs.map
  "[project]/node_modules/better-call/dist/context.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["createInternalContext", () => createInternalContext]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/error.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/utils.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$validator$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/validator.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/crypto.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$cookies$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/cookies.mjs [app-route] (ecmascript)",
      );
    //#region src/context.ts
    const createInternalContext = async (context, { options, path }) => {
      const headers = new Headers();
      let responseStatus = void 0;
      const { data, error } = await (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$validator$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "runValidation"
      ])(options, context);
      if (error)
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "ValidationError"
        ](error.message, error.issues);
      const requestHeaders =
        "headers" in context
          ? context.headers instanceof Headers
            ? context.headers
            : new Headers(context.headers)
          : "request" in context &&
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "isRequest"
              ])(context.request)
            ? context.request.headers
            : null;
      const requestCookies = requestHeaders?.get("cookie");
      const parsedCookies = requestCookies
        ? (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$cookies$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "parseCookies"
          ])(requestCookies)
        : void 0;
      const internalContext = {
        ...context,
        body: data.body,
        query: data.query,
        path: context.path || path || "virtual:",
        context: "context" in context && context.context ? context.context : {},
        returned: void 0,
        headers: context?.headers,
        request: context?.request,
        params: "params" in context ? context.params : void 0,
        method:
          context.method ??
          (Array.isArray(options.method)
            ? options.method[0]
            : options.method === "*"
              ? "GET"
              : options.method),
        setHeader: (key, value) => {
          headers.set(key, value);
        },
        getHeader: (key) => {
          if (!requestHeaders) return null;
          return requestHeaders.get(key);
        },
        getCookie: (key, prefix) => {
          const finalKey = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$cookies$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "getCookieKey"
          ])(key, prefix);
          if (!finalKey) return null;
          return parsedCookies?.get(finalKey) || null;
        },
        getSignedCookie: async (key, secret, prefix) => {
          const finalKey = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$cookies$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "getCookieKey"
          ])(key, prefix);
          if (!finalKey) return null;
          const value = parsedCookies?.get(finalKey);
          if (!value) return null;
          const signatureStartPos = value.lastIndexOf(".");
          if (signatureStartPos < 1) return null;
          const signedValue = value.substring(0, signatureStartPos);
          const signature = value.substring(signatureStartPos + 1);
          if (signature.length !== 44 || !signature.endsWith("=")) return null;
          return (await (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "verifySignature"
          ])(
            signature,
            signedValue,
            await (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "getCryptoKey"
            ])(secret),
          ))
            ? signedValue
            : false;
        },
        setCookie: (key, value, options$1) => {
          const cookie = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$cookies$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "serializeCookie"
          ])(key, value, options$1);
          headers.append("set-cookie", cookie);
          return cookie;
        },
        setSignedCookie: async (key, value, secret, options$1) => {
          const cookie = await (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$cookies$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "serializeSignedCookie"
          ])(key, value, secret, options$1);
          headers.append("set-cookie", cookie);
          return cookie;
        },
        redirect: (url) => {
          headers.set("location", url);
          return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "APIError"
          ]("FOUND", void 0, headers);
        },
        error: (status, body, headers$1) => {
          return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "APIError"
          ](status, body, headers$1);
        },
        setStatus: (status) => {
          responseStatus = status;
        },
        json: (json, routerResponse) => {
          if (!context.asResponse) return json;
          return {
            body: routerResponse?.body || json,
            routerResponse,
            _flag: "json",
          };
        },
        responseHeaders: headers,
        get responseStatus() {
          return responseStatus;
        },
      };
      for (const middleware of options.use || []) {
        const response = await middleware({
          ...internalContext,
          returnHeaders: true,
          asResponse: false,
        });
        if (response.response) Object.assign(internalContext.context, response.response);
        /**
         * Apply headers from the middleware to the endpoint headers
         */ if (response.headers)
          response.headers.forEach((value, key) => {
            internalContext.responseHeaders.set(key, value);
          });
      }
      return internalContext;
    };
  },
  //# sourceMappingURL=context.mjs.map
  "[project]/node_modules/better-call/dist/endpoint.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["createEndpoint", () => createEndpoint]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/error.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/utils.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$to$2d$response$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/to-response.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$context$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/context.mjs [app-route] (ecmascript)",
      );
    //#region src/endpoint.ts
    function createEndpoint(pathOrOptions, handlerOrOptions, handlerOrNever) {
      const path = typeof pathOrOptions === "string" ? pathOrOptions : void 0;
      const options = typeof handlerOrOptions === "object" ? handlerOrOptions : pathOrOptions;
      const handler = typeof handlerOrOptions === "function" ? handlerOrOptions : handlerOrNever;
      if ((options.method === "GET" || options.method === "HEAD") && options.body)
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "BetterCallError"
        ]("Body is not allowed with GET or HEAD methods");
      if (path && /\/{2,}/.test(path))
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "BetterCallError"
        ]("Path cannot contain consecutive slashes");
      const internalHandler = async (...inputCtx) => {
        const context = inputCtx[0] || {};
        const { data: internalContext, error: validationError } = await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "tryCatch"
        ])(
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$context$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "createInternalContext"
          ])(context, {
            options,
            path,
          }),
        );
        if (validationError) {
          if (
            !(
              validationError instanceof
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "ValidationError"
              ]
            )
          )
            throw validationError;
          if (options.onValidationError)
            await options.onValidationError({
              message: validationError.message,
              issues: validationError.issues,
            });
          throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "APIError"
          ](400, {
            message: validationError.message,
            code: "VALIDATION_ERROR",
          });
        }
        const response = await handler(internalContext).catch(async (e) => {
          if (
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "isAPIError"
            ])(e)
          ) {
            const onAPIError = options.onAPIError;
            if (onAPIError) await onAPIError(e);
            if (context.asResponse) return e;
          }
          throw e;
        });
        const headers = internalContext.responseHeaders;
        const status = internalContext.responseStatus;
        return context.asResponse
          ? (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$to$2d$response$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "toResponse"
            ])(response, {
              headers,
              status,
            })
          : context.returnHeaders
            ? context.returnStatus
              ? {
                  headers,
                  response,
                  status,
                }
              : {
                  headers,
                  response,
                }
            : context.returnStatus
              ? {
                  response,
                  status,
                }
              : response;
      };
      internalHandler.options = options;
      internalHandler.path = path;
      return internalHandler;
    }
    createEndpoint.create = (opts) => {
      return (path, options, handler) => {
        return createEndpoint(
          path,
          {
            ...options,
            use: [...(options?.use || []), ...(opts?.use || [])],
          },
          handler,
        );
      };
    };
  },
  //# sourceMappingURL=endpoint.mjs.map
  "[project]/node_modules/better-call/dist/middleware.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["createMiddleware", () => createMiddleware]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$context$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/context.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$endpoint$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/endpoint.mjs [app-route] (ecmascript)",
      );
    //#region src/middleware.ts
    function createMiddleware(optionsOrHandler, handler) {
      const internalHandler = async (inputCtx) => {
        const context = inputCtx;
        const _handler = typeof optionsOrHandler === "function" ? optionsOrHandler : handler;
        const internalContext = await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$context$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "createInternalContext"
        ])(context, {
          options: typeof optionsOrHandler === "function" ? {} : optionsOrHandler,
          path: "/",
        });
        if (!_handler) throw new Error("handler must be defined");
        const response = await _handler(internalContext);
        const headers = internalContext.responseHeaders;
        return context.returnHeaders
          ? {
              headers,
              response,
            }
          : response;
      };
      internalHandler.options = typeof optionsOrHandler === "function" ? {} : optionsOrHandler;
      return internalHandler;
    }
    createMiddleware.create = (opts) => {
      function fn(optionsOrHandler, handler) {
        if (typeof optionsOrHandler === "function")
          return createMiddleware(
            {
              use: opts?.use,
            },
            optionsOrHandler,
          );
        if (!handler) throw new Error("Middleware handler is required");
        return createMiddleware(
          {
            ...optionsOrHandler,
            method: "*",
            use: [...(opts?.use || []), ...(optionsOrHandler.use || [])],
          },
          handler,
        );
      }
      return fn;
    };
  },
  //# sourceMappingURL=middleware.mjs.map
  "[project]/node_modules/better-call/dist/openapi.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["generator", () => generator, "getHTML", () => getHTML]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/zod/v4/classic/schemas.js [app-route] (ecmascript)",
      );
    //#region src/openapi.ts
    const paths = {};
    function getTypeFromZodType(zodType) {
      switch (zodType.constructor.name) {
        case "ZodString":
          return "string";
        case "ZodNumber":
          return "number";
        case "ZodBoolean":
          return "boolean";
        case "ZodObject":
          return "object";
        case "ZodArray":
          return "array";
        default:
          return "string";
      }
    }
    function getParameters(options) {
      const parameters = [];
      if (options.metadata?.openapi?.parameters) {
        parameters.push(...options.metadata.openapi.parameters);
        return parameters;
      }
      if (
        options.query instanceof
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "ZodObject"
        ]
      )
        Object.entries(options.query.shape).forEach(([key, value]) => {
          if (
            value instanceof
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "ZodObject"
            ]
          )
            parameters.push({
              name: key,
              in: "query",
              schema: {
                type: getTypeFromZodType(value),
                ...("minLength" in value && value.minLength
                  ? {
                      minLength: value.minLength,
                    }
                  : {}),
                description: value.description,
              },
            });
        });
      return parameters;
    }
    function getRequestBody(options) {
      if (options.metadata?.openapi?.requestBody) return options.metadata.openapi.requestBody;
      if (!options.body) return void 0;
      if (
        options.body instanceof
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "ZodObject"
          ] ||
        options.body instanceof
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "ZodOptional"
          ]
      ) {
        const shape = options.body.shape;
        if (!shape) return void 0;
        const properties = {};
        const required = [];
        Object.entries(shape).forEach(([key, value]) => {
          if (
            value instanceof
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "ZodObject"
            ]
          ) {
            properties[key] = {
              type: getTypeFromZodType(value),
              description: value.description,
            };
            if (
              !(
                value instanceof
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                  "ZodOptional"
                ]
              )
            )
              required.push(key);
          }
        });
        return {
          required:
            options.body instanceof
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "ZodOptional"
            ]
              ? false
              : options.body
                ? true
                : false,
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties,
                required,
              },
            },
          },
        };
      }
    }
    function getResponse(responses) {
      return {
        400: {
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  message: {
                    type: "string",
                  },
                },
                required: ["message"],
              },
            },
          },
          description: "Bad Request. Usually due to missing parameters, or invalid parameters.",
        },
        401: {
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  message: {
                    type: "string",
                  },
                },
                required: ["message"],
              },
            },
          },
          description: "Unauthorized. Due to missing or invalid authentication.",
        },
        403: {
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  message: {
                    type: "string",
                  },
                },
              },
            },
          },
          description:
            "Forbidden. You do not have permission to access this resource or to perform this action.",
        },
        404: {
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  message: {
                    type: "string",
                  },
                },
              },
            },
          },
          description: "Not Found. The requested resource was not found.",
        },
        429: {
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  message: {
                    type: "string",
                  },
                },
              },
            },
          },
          description: "Too Many Requests. You have exceeded the rate limit. Try again later.",
        },
        500: {
          content: {
            "application/json": {
              schema: {
                type: "object",
                properties: {
                  message: {
                    type: "string",
                  },
                },
              },
            },
          },
          description:
            "Internal Server Error. This is a problem with the server that you cannot fix.",
        },
        ...responses,
      };
    }
    async function generator(endpoints, config) {
      const components = {
        schemas: {},
      };
      Object.entries(endpoints).forEach(([_, value]) => {
        const options = value.options;
        if (!value.path || options.metadata?.SERVER_ONLY) return;
        if (options.method === "GET")
          paths[value.path] = {
            get: {
              tags: ["Default", ...(options.metadata?.openapi?.tags || [])],
              description: options.metadata?.openapi?.description,
              operationId: options.metadata?.openapi?.operationId,
              security: [
                {
                  bearerAuth: [],
                },
              ],
              parameters: getParameters(options),
              responses: getResponse(options.metadata?.openapi?.responses),
            },
          };
        if (options.method === "POST") {
          const body = getRequestBody(options);
          paths[value.path] = {
            post: {
              tags: ["Default", ...(options.metadata?.openapi?.tags || [])],
              description: options.metadata?.openapi?.description,
              operationId: options.metadata?.openapi?.operationId,
              security: [
                {
                  bearerAuth: [],
                },
              ],
              parameters: getParameters(options),
              ...(body
                ? {
                    requestBody: body,
                  }
                : {
                    requestBody: {
                      content: {
                        "application/json": {
                          schema: {
                            type: "object",
                            properties: {},
                          },
                        },
                      },
                    },
                  }),
              responses: getResponse(options.metadata?.openapi?.responses),
            },
          };
        }
      });
      return {
        openapi: "3.1.1",
        info: {
          title: "Better Auth",
          description: "API Reference for your Better Auth Instance",
          version: "1.1.0",
        },
        components,
        security: [
          {
            apiKeyCookie: [],
          },
        ],
        servers: [
          {
            url: config?.url,
          },
        ],
        tags: [
          {
            name: "Default",
            description:
              "Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin.",
          },
        ],
        paths,
      };
    }
    const getHTML = (apiReference, config) => `<!doctype html>
<html>
  <head>
    <title>Scalar API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <script
      id="api-reference"
      type="application/json">
    ${JSON.stringify(apiReference)}
    <\/script>
	 <script>
      var configuration = {
	  	favicon: ${config?.logo ? `data:image/svg+xml;utf8,${encodeURIComponent(config.logo)}` : void 0} ,
	   	theme: ${config?.theme || "saturn"},
        metaData: {
			title: ${config?.title || "Open API Reference"},
			description: ${config?.description || "Better Call Open API"},
		}
      }
      document.getElementById('api-reference').dataset.configuration =
        JSON.stringify(configuration)
    <\/script>
	  <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference"><\/script>
  </body>
</html>`;
  },
  //# sourceMappingURL=openapi.mjs.map
  "[project]/node_modules/better-call/dist/router.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["createRouter", () => createRouter$1]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/utils.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$to$2d$response$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/to-response.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$endpoint$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/endpoint.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$openapi$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/openapi.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rou3$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/rou3/dist/index.mjs [app-route] (ecmascript)",
      );
    //#region src/router.ts
    const createRouter$1 = (endpoints, config) => {
      if (!config?.openapi?.disabled) {
        const openapi = {
          path: "/api/reference",
          ...config?.openapi,
        };
        endpoints["openapi"] = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$endpoint$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "createEndpoint"
        ])(
          openapi.path,
          {
            method: "GET",
          },
          async (c) => {
            const schema = await (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$openapi$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "generator"
            ])(endpoints);
            return new Response(
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$openapi$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "getHTML"
              ])(schema, openapi.scalar),
              {
                headers: {
                  "Content-Type": "text/html",
                },
              },
            );
          },
        );
      }
      const router = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rou3$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "createRouter"
      ])();
      const middlewareRouter = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rou3$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "createRouter"
      ])();
      for (const endpoint of Object.values(endpoints)) {
        if (!endpoint.options || !endpoint.path) continue;
        if (endpoint.options?.metadata?.SERVER_ONLY) continue;
        const methods = Array.isArray(endpoint.options?.method)
          ? endpoint.options.method
          : [endpoint.options?.method];
        for (const method of methods)
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rou3$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "addRoute"
          ])(router, method, endpoint.path, endpoint);
      }
      if (config?.routerMiddleware?.length)
        for (const { path, middleware } of config.routerMiddleware)
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rou3$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "addRoute"
          ])(middlewareRouter, "*", path, middleware);
      const processRequest = async (request) => {
        const url = new URL(request.url);
        const pathname = url.pathname;
        const path =
          config?.basePath && config.basePath !== "/"
            ? pathname
                .split(config.basePath)
                .reduce((acc, curr, index) => {
                  if (index !== 0)
                    if (index > 1) acc.push(`${config.basePath}${curr}`);
                    else acc.push(curr);
                  return acc;
                }, [])
                .join("")
            : url.pathname;
        if (!path?.length)
          return new Response(null, {
            status: 404,
            statusText: "Not Found",
          });
        if (/\/{2,}/.test(path))
          return new Response(null, {
            status: 404,
            statusText: "Not Found",
          });
        const route = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rou3$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "findRoute"
        ])(router, request.method, path);
        if (path.endsWith("/") !== route?.data?.path?.endsWith("/") && !config?.skipTrailingSlashes)
          return new Response(null, {
            status: 404,
            statusText: "Not Found",
          });
        if (!route?.data)
          return new Response(null, {
            status: 404,
            statusText: "Not Found",
          });
        const query = {};
        url.searchParams.forEach((value, key) => {
          if (key in query)
            if (Array.isArray(query[key])) query[key].push(value);
            else query[key] = [query[key], value];
          else query[key] = value;
        });
        const handler = route.data;
        try {
          const allowedMediaTypes =
            handler.options.metadata?.allowedMediaTypes || config?.allowedMediaTypes;
          const context = {
            path,
            method: request.method,
            headers: request.headers,
            params: route.params ? JSON.parse(JSON.stringify(route.params)) : {},
            request,
            body: handler.options.disableBody
              ? void 0
              : await (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                  "getBody"
                ])(handler.options.cloneRequest ? request.clone() : request, allowedMediaTypes),
            query,
            _flag: "router",
            asResponse: true,
            context: config?.routerContext,
          };
          const middlewareRoutes = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rou3$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "findAllRoutes"
          ])(middlewareRouter, "*", path);
          if (middlewareRoutes?.length)
            for (const { data: middleware, params } of middlewareRoutes) {
              const res = await middleware({
                ...context,
                params,
                asResponse: false,
              });
              if (res instanceof Response) return res;
            }
          return await handler(context);
        } catch (error) {
          if (config?.onError)
            try {
              const errorResponse = await config.onError(error);
              if (errorResponse instanceof Response)
                return (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$to$2d$response$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                  "toResponse"
                ])(errorResponse);
            } catch (error$1) {
              if (
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                  "isAPIError"
                ])(error$1)
              )
                return (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$to$2d$response$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                  "toResponse"
                ])(error$1);
              throw error$1;
            }
          if (config?.throwError) throw error;
          if (
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "isAPIError"
            ])(error)
          )
            return (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$to$2d$response$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "toResponse"
            ])(error);
          console.error(`# SERVER_ERROR: `, error);
          return new Response(null, {
            status: 500,
            statusText: "Internal Server Error",
          });
        }
      };
      return {
        handler: async (request) => {
          const onReq = await config?.onRequest?.(request);
          if (onReq instanceof Response) return onReq;
          const res = await processRequest(
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$utils$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "isRequest"
            ])(onReq)
              ? onReq
              : request,
          );
          const onRes = await config?.onResponse?.(res);
          if (onRes instanceof Response) return onRes;
          return res;
        },
        endpoints,
      };
    };
  },
  //# sourceMappingURL=router.mjs.map
  "[project]/node_modules/better-call/dist/index.mjs [app-route] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/error.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$to$2d$response$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/to-response.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$cookies$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/cookies.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$context$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/context.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$endpoint$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/endpoint.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$middleware$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/middleware.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$openapi$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/openapi.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$call$2f$dist$2f$router$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-call/dist/router.mjs [app-route] (ecmascript)",
      );
  },
  "[project]/node_modules/rou3/dist/index.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "NullProtoObj",
      () => NullProtoObj,
      "addRoute",
      () => addRoute,
      "createRouter",
      () => createRouter,
      "findAllRoutes",
      () => findAllRoutes,
      "findRoute",
      () => findRoute,
      "removeRoute",
      () => removeRoute,
      "routeToRegExp",
      () => routeToRegExp,
    ]);
    const NullProtoObj = /* @__PURE__ */ (() => {
      const e = function () {};
      return ((e.prototype = Object.create(null)), Object.freeze(e.prototype), e);
    })();
    /**
     * Create a new router context.
     */ function createRouter() {
      return {
        root: {
          key: "",
        },
        static: new NullProtoObj(),
      };
    }
    function splitPath(path) {
      const [_, ...s] = path.split("/");
      return s[s.length - 1] === "" ? s.slice(0, -1) : s;
    }
    function getMatchParams(segments, paramsMap) {
      const params = new NullProtoObj();
      for (const [index, name] of paramsMap) {
        const segment = index < 0 ? segments.slice(-(index + 1)).join("/") : segments[index];
        if (typeof name === "string") params[name] = segment;
        else {
          const match = segment.match(name);
          if (match) for (const key in match.groups) params[key] = match.groups[key];
        }
      }
      return params;
    }
    /**
     * Add a route to the router context.
     */ function addRoute(ctx, method = "", path, data) {
      method = method.toUpperCase();
      if (path.charCodeAt(0) !== 47) path = `/${path}`;
      path = path.replace(/\\:/g, "%3A");
      const segments = splitPath(path);
      let node = ctx.root;
      let _unnamedParamIndex = 0;
      const paramsMap = [];
      const paramsRegexp = [];
      for (let i = 0; i < segments.length; i++) {
        let segment = segments[i];
        if (segment.startsWith("**")) {
          if (!node.wildcard)
            node.wildcard = {
              key: "**",
            };
          node = node.wildcard;
          paramsMap.push([-(i + 1), segment.split(":")[1] || "_", segment.length === 2]);
          break;
        }
        if (segment === "*" || segment.includes(":")) {
          if (!node.param)
            node.param = {
              key: "*",
            };
          node = node.param;
          if (segment === "*") paramsMap.push([i, `_${_unnamedParamIndex++}`, true]);
          else if (segment.includes(":", 1)) {
            const regexp = getParamRegexp(segment);
            paramsRegexp[i] = regexp;
            node.hasRegexParam = true;
            paramsMap.push([i, regexp, false]);
          } else paramsMap.push([i, segment.slice(1), false]);
          continue;
        }
        if (segment === "\\*") segment = segments[i] = "*";
        else if (segment === "\\*\\*") segment = segments[i] = "**";
        const child = node.static?.[segment];
        if (child) node = child;
        else {
          const staticNode = {
            key: segment,
          };
          if (!node.static) node.static = new NullProtoObj();
          node.static[segment] = staticNode;
          node = staticNode;
        }
      }
      const hasParams = paramsMap.length > 0;
      if (!node.methods) node.methods = new NullProtoObj();
      node.methods[method] ??= [];
      node.methods[method].push({
        data: data || null,
        paramsRegexp,
        paramsMap: hasParams ? paramsMap : void 0,
      });
      if (!hasParams) ctx.static["/" + segments.join("/")] = node;
    }
    function getParamRegexp(segment) {
      const regex = segment.replace(/:(\w+)/g, (_, id) => `(?<${id}>[^/]+)`).replace(/\./g, "\\.");
      return /* @__PURE__ */ new RegExp(`^${regex}$`);
    }
    /**
     * Find a route by path.
     */ function findRoute(ctx, method = "", path, opts) {
      if (path.charCodeAt(path.length - 1) === 47) path = path.slice(0, -1);
      const staticNode = ctx.static[path];
      if (staticNode && staticNode.methods) {
        const staticMatch = staticNode.methods[method] || staticNode.methods[""];
        if (staticMatch !== void 0) return staticMatch[0];
      }
      const segments = splitPath(path);
      const match = _lookupTree(ctx, ctx.root, method, segments, 0)?.[0];
      if (match === void 0) return;
      if (opts?.params === false) return match;
      return {
        data: match.data,
        params: match.paramsMap ? getMatchParams(segments, match.paramsMap) : void 0,
      };
    }
    function _lookupTree(ctx, node, method, segments, index) {
      if (index === segments.length) {
        if (node.methods) {
          const match = node.methods[method] || node.methods[""];
          if (match) return match;
        }
        if (node.param && node.param.methods) {
          const match = node.param.methods[method] || node.param.methods[""];
          if (match) {
            const pMap = match[0].paramsMap;
            if (pMap?.[pMap?.length - 1]?.[2]) return match;
          }
        }
        if (node.wildcard && node.wildcard.methods) {
          const match = node.wildcard.methods[method] || node.wildcard.methods[""];
          if (match) {
            const pMap = match[0].paramsMap;
            if (pMap?.[pMap?.length - 1]?.[2]) return match;
          }
        }
        return;
      }
      const segment = segments[index];
      if (node.static) {
        const staticChild = node.static[segment];
        if (staticChild) {
          const match = _lookupTree(ctx, staticChild, method, segments, index + 1);
          if (match) return match;
        }
      }
      if (node.param) {
        const match = _lookupTree(ctx, node.param, method, segments, index + 1);
        if (match) {
          if (node.param.hasRegexParam) {
            const exactMatch =
              match.find((m) => m.paramsRegexp[index]?.test(segment)) ||
              match.find((m) => !m.paramsRegexp[index]);
            return exactMatch ? [exactMatch] : void 0;
          }
          return match;
        }
      }
      if (node.wildcard && node.wildcard.methods)
        return node.wildcard.methods[method] || node.wildcard.methods[""];
    }
    /**
     * Remove a route from the router context.
     */ function removeRoute(ctx, method, path) {
      const segments = splitPath(path);
      return _remove(ctx.root, method || "", segments, 0);
    }
    function _remove(node, method, segments, index) {
      if (index === segments.length) {
        if (node.methods && method in node.methods) {
          delete node.methods[method];
          if (Object.keys(node.methods).length === 0) node.methods = void 0;
        }
        return;
      }
      const segment = segments[index];
      if (segment === "*") {
        if (node.param) {
          _remove(node.param, method, segments, index + 1);
          if (_isEmptyNode(node.param)) node.param = void 0;
        }
        return;
      }
      if (segment.startsWith("**")) {
        if (node.wildcard) {
          _remove(node.wildcard, method, segments, index + 1);
          if (_isEmptyNode(node.wildcard)) node.wildcard = void 0;
        }
        return;
      }
      const childNode = node.static?.[segment];
      if (childNode) {
        _remove(childNode, method, segments, index + 1);
        if (_isEmptyNode(childNode)) {
          delete node.static[segment];
          if (Object.keys(node.static).length === 0) node.static = void 0;
        }
      }
    }
    function _isEmptyNode(node) {
      return (
        node.methods === void 0 &&
        node.static === void 0 &&
        node.param === void 0 &&
        node.wildcard === void 0
      );
    }
    /**
     * Find all route patterns that match the given path.
     */ function findAllRoutes(ctx, method = "", path, opts) {
      if (path.charCodeAt(path.length - 1) === 47) path = path.slice(0, -1);
      const segments = splitPath(path);
      const matches = _findAll(ctx, ctx.root, method, segments, 0);
      if (opts?.params === false) return matches;
      return matches.map((m) => {
        return {
          data: m.data,
          params: m.paramsMap ? getMatchParams(segments, m.paramsMap) : void 0,
        };
      });
    }
    function _findAll(ctx, node, method, segments, index, matches = []) {
      const segment = segments[index];
      if (node.wildcard && node.wildcard.methods) {
        const match = node.wildcard.methods[method] || node.wildcard.methods[""];
        if (match) matches.push(...match);
      }
      if (node.param) {
        _findAll(ctx, node.param, method, segments, index + 1, matches);
        if (index === segments.length && node.param.methods) {
          const match = node.param.methods[method] || node.param.methods[""];
          if (match) {
            const pMap = match[0].paramsMap;
            if (pMap?.[pMap?.length - 1]?.[2]) matches.push(...match);
          }
        }
      }
      const staticChild = node.static?.[segment];
      if (staticChild) _findAll(ctx, staticChild, method, segments, index + 1, matches);
      if (index === segments.length && node.methods) {
        const match = node.methods[method] || node.methods[""];
        if (match) matches.push(...match);
      }
      return matches;
    }
    function routeToRegExp(route = "/") {
      const reSegments = [];
      let idCtr = 0;
      for (const segment of route.split("/")) {
        if (!segment) continue;
        if (segment === "*") reSegments.push(`(?<_${idCtr++}>[^/]*)`);
        else if (segment.startsWith("**"))
          reSegments.push(segment === "**" ? "?(?<_>.*)" : `?(?<${segment.slice(3)}>.+)`);
        else if (segment.includes(":"))
          reSegments.push(
            segment.replace(/:(\w+)/g, (_, id) => `(?<${id}>[^/]+)`).replace(/\./g, "\\."),
          );
        else reSegments.push(segment);
      }
      return /* @__PURE__ */ new RegExp(`^/${reSegments.join("/")}/?$`);
    }
  },
  "[project]/node_modules/@better-fetch/fetch/dist/index.js [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "BetterFetchError",
      () => BetterFetchError,
      "ValidationError",
      () => ValidationError,
      "applySchemaPlugin",
      () => applySchemaPlugin,
      "betterFetch",
      () => betterFetch,
      "bodyParser",
      () => bodyParser,
      "createFetch",
      () => createFetch,
      "createRetryStrategy",
      () => createRetryStrategy,
      "createSchema",
      () => createSchema,
      "detectContentType",
      () => detectContentType,
      "detectResponseType",
      () => detectResponseType,
      "getBody",
      () => getBody,
      "getFetch",
      () => getFetch,
      "getHeaders",
      () => getHeaders,
      "getMethod",
      () => getMethod,
      "getTimeout",
      () => getTimeout,
      "getURL",
      () => getURL,
      "initializePlugins",
      () => initializePlugins,
      "isFunction",
      () => isFunction,
      "isJSONParsable",
      () => isJSONParsable,
      "isJSONSerializable",
      () => isJSONSerializable,
      "isPayloadMethod",
      () => isPayloadMethod,
      "isRouteMethod",
      () => isRouteMethod,
      "jsonParse",
      () => jsonParse,
      "methods",
      () => methods,
      "parseStandardSchema",
      () => parseStandardSchema,
    ]);
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) =>
      key in obj
        ? __defProp(obj, key, {
            enumerable: true,
            configurable: true,
            writable: true,
            value,
          })
        : (obj[key] = value);
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    // src/error.ts
    var BetterFetchError = class extends Error {
      constructor(status, statusText, error) {
        super(statusText || status.toString(), {
          cause: error,
        });
        this.status = status;
        this.statusText = statusText;
        this.error = error;
        Error.captureStackTrace(this, this.constructor);
      }
    };
    // src/plugins.ts
    var initializePlugins = async (url, options) => {
      var _a, _b, _c, _d, _e, _f;
      let opts = options || {};
      const hooks = {
        onRequest: [options == null ? void 0 : options.onRequest],
        onResponse: [options == null ? void 0 : options.onResponse],
        onSuccess: [options == null ? void 0 : options.onSuccess],
        onError: [options == null ? void 0 : options.onError],
        onRetry: [options == null ? void 0 : options.onRetry],
      };
      if (!options || !(options == null ? void 0 : options.plugins)) {
        return {
          url,
          options: opts,
          hooks,
        };
      }
      for (const plugin of (options == null ? void 0 : options.plugins) || []) {
        if (plugin.init) {
          const pluginRes = await ((_a = plugin.init) == null
            ? void 0
            : _a.call(plugin, url.toString(), options));
          opts = pluginRes.options || opts;
          url = pluginRes.url;
        }
        hooks.onRequest.push((_b = plugin.hooks) == null ? void 0 : _b.onRequest);
        hooks.onResponse.push((_c = plugin.hooks) == null ? void 0 : _c.onResponse);
        hooks.onSuccess.push((_d = plugin.hooks) == null ? void 0 : _d.onSuccess);
        hooks.onError.push((_e = plugin.hooks) == null ? void 0 : _e.onError);
        hooks.onRetry.push((_f = plugin.hooks) == null ? void 0 : _f.onRetry);
      }
      return {
        url,
        options: opts,
        hooks,
      };
    };
    // src/retry.ts
    var LinearRetryStrategy = class {
      constructor(options) {
        this.options = options;
      }
      shouldAttemptRetry(attempt, response) {
        if (this.options.shouldRetry) {
          return Promise.resolve(
            attempt < this.options.attempts && this.options.shouldRetry(response),
          );
        }
        return Promise.resolve(attempt < this.options.attempts);
      }
      getDelay() {
        return this.options.delay;
      }
    };
    var ExponentialRetryStrategy = class {
      constructor(options) {
        this.options = options;
      }
      shouldAttemptRetry(attempt, response) {
        if (this.options.shouldRetry) {
          return Promise.resolve(
            attempt < this.options.attempts && this.options.shouldRetry(response),
          );
        }
        return Promise.resolve(attempt < this.options.attempts);
      }
      getDelay(attempt) {
        const delay = Math.min(this.options.maxDelay, this.options.baseDelay * 2 ** attempt);
        return delay;
      }
    };
    function createRetryStrategy(options) {
      if (typeof options === "number") {
        return new LinearRetryStrategy({
          type: "linear",
          attempts: options,
          delay: 1e3,
        });
      }
      switch (options.type) {
        case "linear":
          return new LinearRetryStrategy(options);
        case "exponential":
          return new ExponentialRetryStrategy(options);
        default:
          throw new Error("Invalid retry strategy");
      }
    }
    // src/auth.ts
    var getAuthHeader = async (options) => {
      const headers = {};
      const getValue = async (value) => (typeof value === "function" ? await value() : value);
      if (options == null ? void 0 : options.auth) {
        if (options.auth.type === "Bearer") {
          const token = await getValue(options.auth.token);
          if (!token) {
            return headers;
          }
          headers["authorization"] = `Bearer ${token}`;
        } else if (options.auth.type === "Basic") {
          const [username, password] = await Promise.all([
            getValue(options.auth.username),
            getValue(options.auth.password),
          ]);
          if (!username || !password) {
            return headers;
          }
          headers["authorization"] = `Basic ${btoa(`${username}:${password}`)}`;
        } else if (options.auth.type === "Custom") {
          const [prefix, value] = await Promise.all([
            getValue(options.auth.prefix),
            getValue(options.auth.value),
          ]);
          if (!value) {
            return headers;
          }
          headers["authorization"] = `${prefix != null ? prefix : ""} ${value}`;
        }
      }
      return headers;
    };
    // src/utils.ts
    var JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
    function detectResponseType(request) {
      const _contentType = request.headers.get("content-type");
      const textTypes = /* @__PURE__ */ new Set([
        "image/svg",
        "application/xml",
        "application/xhtml",
        "application/html",
      ]);
      if (!_contentType) {
        return "json";
      }
      const contentType = _contentType.split(";").shift() || "";
      if (JSON_RE.test(contentType)) {
        return "json";
      }
      if (textTypes.has(contentType) || contentType.startsWith("text/")) {
        return "text";
      }
      return "blob";
    }
    function isJSONParsable(value) {
      try {
        JSON.parse(value);
        return true;
      } catch (error) {
        return false;
      }
    }
    function isJSONSerializable(value) {
      if (value === void 0) {
        return false;
      }
      const t = typeof value;
      if (t === "string" || t === "number" || t === "boolean" || t === null) {
        return true;
      }
      if (t !== "object") {
        return false;
      }
      if (Array.isArray(value)) {
        return true;
      }
      if (value.buffer) {
        return false;
      }
      return (
        (value.constructor && value.constructor.name === "Object") ||
        typeof value.toJSON === "function"
      );
    }
    function jsonParse(text) {
      try {
        return JSON.parse(text);
      } catch (error) {
        return text;
      }
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function getFetch(options) {
      if (options == null ? void 0 : options.customFetchImpl) {
        return options.customFetchImpl;
      }
      if (typeof globalThis !== "undefined" && isFunction(globalThis.fetch)) {
        return globalThis.fetch;
      }
      if (
        ("TURBOPACK compile-time value", "undefined") !== "undefined" &&
        isFunction(window.fetch)
      ) //TURBOPACK unreachable
      ;
      throw new Error("No fetch implementation found");
    }
    function isPayloadMethod(method) {
      if (!method) {
        return false;
      }
      const payloadMethod = ["POST", "PUT", "PATCH", "DELETE"];
      return payloadMethod.includes(method.toUpperCase());
    }
    function isRouteMethod(method) {
      const routeMethod = ["GET", "POST", "PUT", "PATCH", "DELETE"];
      if (!method) {
        return false;
      }
      return routeMethod.includes(method.toUpperCase());
    }
    async function getHeaders(opts) {
      const headers = new Headers(opts == null ? void 0 : opts.headers);
      const authHeader = await getAuthHeader(opts);
      for (const [key, value] of Object.entries(authHeader || {})) {
        headers.set(key, value);
      }
      if (!headers.has("content-type")) {
        const t = detectContentType(opts == null ? void 0 : opts.body);
        if (t) {
          headers.set("content-type", t);
        }
      }
      return headers;
    }
    function getURL(url, options) {
      if (url.startsWith("@")) {
        const m = url.toString().split("@")[1].split("/")[0];
        if (methods.includes(m)) {
          url = url.replace(`@${m}/`, "/");
        }
      }
      let _url;
      try {
        if (url.startsWith("http")) {
          _url = url;
        } else {
          let baseURL = options == null ? void 0 : options.baseURL;
          if (baseURL && !(baseURL == null ? void 0 : baseURL.endsWith("/"))) {
            baseURL = baseURL + "/";
          }
          if (url.startsWith("/")) {
            _url = new URL(url.substring(1), baseURL);
          } else {
            _url = new URL(url, options == null ? void 0 : options.baseURL);
          }
        }
      } catch (e) {
        if (e instanceof TypeError) {
          if (!(options == null ? void 0 : options.baseURL)) {
            throw TypeError(
              `Invalid URL ${url}. Are you passing in a relative url but not setting the baseURL?`,
            );
          }
          throw TypeError(
            `Invalid URL ${url}. Please validate that you are passing the correct input.`,
          );
        }
        throw e;
      }
      if (options == null ? void 0 : options.params) {
        if (Array.isArray(options == null ? void 0 : options.params)) {
          const params = (options == null ? void 0 : options.params)
            ? Array.isArray(options.params)
              ? `/${options.params.join("/")}`
              : `/${Object.values(options.params).join("/")}`
            : "";
          _url = _url.toString().split("/:")[0];
          _url = `${_url.toString()}${params}`;
        } else {
          for (const [key, value] of Object.entries(options == null ? void 0 : options.params)) {
            _url = _url.toString().replace(`:${key}`, String(value));
          }
        }
      }
      const __url = new URL(_url);
      const queryParams = options == null ? void 0 : options.query;
      if (queryParams) {
        for (const [key, value] of Object.entries(queryParams)) {
          __url.searchParams.append(key, String(value));
        }
      }
      return __url;
    }
    function detectContentType(body) {
      if (isJSONSerializable(body)) {
        return "application/json";
      }
      return null;
    }
    function getBody(options) {
      if (!(options == null ? void 0 : options.body)) {
        return null;
      }
      const headers = new Headers(options == null ? void 0 : options.headers);
      if (isJSONSerializable(options.body) && !headers.has("content-type")) {
        for (const [key, value] of Object.entries(options == null ? void 0 : options.body)) {
          if (value instanceof Date) {
            options.body[key] = value.toISOString();
          }
        }
        return JSON.stringify(options.body);
      }
      if (
        headers.has("content-type") &&
        headers.get("content-type") === "application/x-www-form-urlencoded"
      ) {
        if (isJSONSerializable(options.body)) {
          return new URLSearchParams(options.body).toString();
        }
        return options.body;
      }
      return options.body;
    }
    function getMethod(url, options) {
      var _a;
      if (options == null ? void 0 : options.method) {
        return options.method.toUpperCase();
      }
      if (url.startsWith("@")) {
        const pMethod = (_a = url.split("@")[1]) == null ? void 0 : _a.split("/")[0];
        if (!methods.includes(pMethod)) {
          return (options == null ? void 0 : options.body) ? "POST" : "GET";
        }
        return pMethod.toUpperCase();
      }
      return (options == null ? void 0 : options.body) ? "POST" : "GET";
    }
    function getTimeout(options, controller) {
      let abortTimeout;
      if (
        !(options == null ? void 0 : options.signal) &&
        (options == null ? void 0 : options.timeout)
      ) {
        abortTimeout = setTimeout(
          () => (controller == null ? void 0 : controller.abort()),
          options == null ? void 0 : options.timeout,
        );
      }
      return {
        abortTimeout,
        clearTimeout: () => {
          if (abortTimeout) {
            clearTimeout(abortTimeout);
          }
        },
      };
    }
    function bodyParser(data, responseType) {
      if (responseType === "json") {
        return JSON.parse(data);
      }
      return data;
    }
    var ValidationError = class _ValidationError extends Error {
      constructor(issues, message) {
        super(message || JSON.stringify(issues, null, 2));
        this.issues = issues;
        Object.setPrototypeOf(this, _ValidationError.prototype);
      }
    };
    async function parseStandardSchema(schema, input) {
      const result = await schema["~standard"].validate(input);
      if (result.issues) {
        throw new ValidationError(result.issues);
      }
      return result.value;
    }
    // src/create-fetch/schema.ts
    var methods = ["get", "post", "put", "patch", "delete"];
    var createSchema = (schema, config) => {
      return {
        schema,
        config,
      };
    };
    // src/create-fetch/index.ts
    var applySchemaPlugin = (config) => ({
      id: "apply-schema",
      name: "Apply Schema",
      version: "1.0.0",
      async init(url, options) {
        var _a, _b, _c, _d;
        const schema =
          ((_b =
            (_a = config.plugins) == null
              ? void 0
              : _a.find((plugin) => {
                  var _a2;
                  return ((_a2 = plugin.schema) == null ? void 0 : _a2.config)
                    ? url.startsWith(plugin.schema.config.baseURL || "") ||
                        url.startsWith(plugin.schema.config.prefix || "")
                    : false;
                })) == null
            ? void 0
            : _b.schema) || config.schema;
        if (schema) {
          let urlKey = url;
          if ((_c = schema.config) == null ? void 0 : _c.prefix) {
            if (urlKey.startsWith(schema.config.prefix)) {
              urlKey = urlKey.replace(schema.config.prefix, "");
              if (schema.config.baseURL) {
                url = url.replace(schema.config.prefix, schema.config.baseURL);
              }
            }
          }
          if ((_d = schema.config) == null ? void 0 : _d.baseURL) {
            if (urlKey.startsWith(schema.config.baseURL)) {
              urlKey = urlKey.replace(schema.config.baseURL, "");
            }
          }
          const keySchema = schema.schema[urlKey];
          if (keySchema) {
            let opts = __spreadProps(__spreadValues({}, options), {
              method: keySchema.method,
              output: keySchema.output,
            });
            if (!(options == null ? void 0 : options.disableValidation)) {
              opts = __spreadProps(__spreadValues({}, opts), {
                body: keySchema.input
                  ? await parseStandardSchema(
                      keySchema.input,
                      options == null ? void 0 : options.body,
                    )
                  : options == null
                    ? void 0
                    : options.body,
                params: keySchema.params
                  ? await parseStandardSchema(
                      keySchema.params,
                      options == null ? void 0 : options.params,
                    )
                  : options == null
                    ? void 0
                    : options.params,
                query: keySchema.query
                  ? await parseStandardSchema(
                      keySchema.query,
                      options == null ? void 0 : options.query,
                    )
                  : options == null
                    ? void 0
                    : options.query,
              });
            }
            return {
              url,
              options: opts,
            };
          }
        }
        return {
          url,
          options,
        };
      },
    });
    var createFetch = (config) => {
      async function $fetch(url, options) {
        const opts = __spreadProps(__spreadValues(__spreadValues({}, config), options), {
          plugins: [
            ...((config == null ? void 0 : config.plugins) || []),
            applySchemaPlugin(config || {}),
            ...((options == null ? void 0 : options.plugins) || []),
          ],
        });
        if (config == null ? void 0 : config.catchAllError) {
          try {
            return await betterFetch(url, opts);
          } catch (error) {
            return {
              data: null,
              error: {
                status: 500,
                statusText: "Fetch Error",
                message:
                  "Fetch related error. Captured by catchAllError option. See error property for more details.",
                error,
              },
            };
          }
        }
        return await betterFetch(url, opts);
      }
      return $fetch;
    };
    // src/url.ts
    function getURL2(url, option) {
      const { baseURL, params, query } = option || {
        query: {},
        params: {},
        baseURL: "",
      };
      let basePath = url.startsWith("http") ? url.split("/").slice(0, 3).join("/") : baseURL || "";
      if (url.startsWith("@")) {
        const m = url.toString().split("@")[1].split("/")[0];
        if (methods.includes(m)) {
          url = url.replace(`@${m}/`, "/");
        }
      }
      if (!basePath.endsWith("/")) basePath += "/";
      let [path, urlQuery] = url.replace(basePath, "").split("?");
      const queryParams = new URLSearchParams(urlQuery);
      for (const [key, value] of Object.entries(query || {})) {
        if (value == null) continue;
        let serializedValue;
        if (typeof value === "string") {
          serializedValue = value;
        } else if (Array.isArray(value)) {
          for (const val of value) {
            queryParams.append(key, val);
          }
          continue;
        } else {
          serializedValue = JSON.stringify(value);
        }
        queryParams.set(key, serializedValue);
      }
      if (params) {
        if (Array.isArray(params)) {
          const paramPaths = path.split("/").filter((p) => p.startsWith(":"));
          for (const [index, key] of paramPaths.entries()) {
            const value = params[index];
            path = path.replace(key, value);
          }
        } else {
          for (const [key, value] of Object.entries(params)) {
            path = path.replace(`:${key}`, String(value));
          }
        }
      }
      path = path.split("/").map(encodeURIComponent).join("/");
      if (path.startsWith("/")) path = path.slice(1);
      let queryParamString = queryParams.toString();
      queryParamString =
        queryParamString.length > 0 ? `?${queryParamString}`.replace(/\+/g, "%20") : "";
      if (!basePath.startsWith("http")) {
        return `${basePath}${path}${queryParamString}`;
      }
      const _url = new URL(`${path}${queryParamString}`, basePath);
      return _url;
    }
    // src/fetch.ts
    var betterFetch = async (url, options) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const { hooks, url: __url, options: opts } = await initializePlugins(url, options);
      const fetch = getFetch(opts);
      const controller = new AbortController();
      const signal = (_a = opts.signal) != null ? _a : controller.signal;
      const _url = getURL2(__url, opts);
      const body = getBody(opts);
      const headers = await getHeaders(opts);
      const method = getMethod(__url, opts);
      let context = __spreadProps(__spreadValues({}, opts), {
        url: _url,
        headers,
        body,
        method,
        signal,
      });
      for (const onRequest of hooks.onRequest) {
        if (onRequest) {
          const res = await onRequest(context);
          if (typeof res === "object" && res !== null) {
            context = res;
          }
        }
      }
      if (
        ("pipeTo" in context && typeof context.pipeTo === "function") ||
        typeof ((_b = options == null ? void 0 : options.body) == null ? void 0 : _b.pipe) ===
          "function"
      ) {
        if (!("duplex" in context)) {
          context.duplex = "half";
        }
      }
      const { clearTimeout: clearTimeout2 } = getTimeout(opts, controller);
      let response = await fetch(context.url, context);
      clearTimeout2();
      const responseContext = {
        response,
        request: context,
      };
      for (const onResponse of hooks.onResponse) {
        if (onResponse) {
          const r = await onResponse(
            __spreadProps(__spreadValues({}, responseContext), {
              response: (
                (_c = options == null ? void 0 : options.hookOptions) == null
                  ? void 0
                  : _c.cloneResponse
              )
                ? response.clone()
                : response,
            }),
          );
          if (r instanceof Response) {
            response = r;
          } else if (typeof r === "object" && r !== null) {
            response = r.response;
          }
        }
      }
      if (response.ok) {
        const hasBody = context.method !== "HEAD";
        if (!hasBody) {
          return {
            data: "",
            error: null,
          };
        }
        const responseType = detectResponseType(response);
        const successContext = {
          data: null,
          response,
          request: context,
        };
        if (responseType === "json" || responseType === "text") {
          const text = await response.text();
          const parser2 = (_d = context.jsonParser) != null ? _d : jsonParse;
          successContext.data = await parser2(text);
        } else {
          successContext.data = await response[responseType]();
        }
        if (context == null ? void 0 : context.output) {
          if (context.output && !context.disableValidation) {
            successContext.data = await parseStandardSchema(context.output, successContext.data);
          }
        }
        for (const onSuccess of hooks.onSuccess) {
          if (onSuccess) {
            await onSuccess(
              __spreadProps(__spreadValues({}, successContext), {
                response: (
                  (_e = options == null ? void 0 : options.hookOptions) == null
                    ? void 0
                    : _e.cloneResponse
                )
                  ? response.clone()
                  : response,
              }),
            );
          }
        }
        if (options == null ? void 0 : options.throw) {
          return successContext.data;
        }
        return {
          data: successContext.data,
          error: null,
        };
      }
      const parser = (_f = options == null ? void 0 : options.jsonParser) != null ? _f : jsonParse;
      const responseText = await response.text();
      const isJSONResponse = isJSONParsable(responseText);
      const errorObject = isJSONResponse ? await parser(responseText) : null;
      const errorContext = {
        response,
        responseText,
        request: context,
        error: __spreadProps(__spreadValues({}, errorObject), {
          status: response.status,
          statusText: response.statusText,
        }),
      };
      for (const onError of hooks.onError) {
        if (onError) {
          await onError(
            __spreadProps(__spreadValues({}, errorContext), {
              response: (
                (_g = options == null ? void 0 : options.hookOptions) == null
                  ? void 0
                  : _g.cloneResponse
              )
                ? response.clone()
                : response,
            }),
          );
        }
      }
      if (options == null ? void 0 : options.retry) {
        const retryStrategy = createRetryStrategy(options.retry);
        const _retryAttempt = (_h = options.retryAttempt) != null ? _h : 0;
        if (await retryStrategy.shouldAttemptRetry(_retryAttempt, response)) {
          for (const onRetry of hooks.onRetry) {
            if (onRetry) {
              await onRetry(responseContext);
            }
          }
          const delay = retryStrategy.getDelay(_retryAttempt);
          await new Promise((resolve) => setTimeout(resolve, delay));
          return await betterFetch(
            url,
            __spreadProps(__spreadValues({}, options), {
              retryAttempt: _retryAttempt + 1,
            }),
          );
        }
      }
      if (options == null ? void 0 : options.throw) {
        throw new BetterFetchError(
          response.status,
          response.statusText,
          isJSONResponse ? errorObject : responseText,
        );
      }
      return {
        data: null,
        error: __spreadProps(__spreadValues({}, errorObject), {
          status: response.status,
          statusText: response.statusText,
        }),
      };
    };
  },
  //# sourceMappingURL=index.js.map
  "[project]/node_modules/defu/dist/defu.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "createDefu",
      () => createDefu,
      "default",
      () => defu,
      "defu",
      () => defu,
      "defuArrayFn",
      () => defuArrayFn,
      "defuFn",
      () => defuFn,
    ]);
    function isPlainObject(value) {
      if (value === null || typeof value !== "object") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      if (
        prototype !== null &&
        prototype !== Object.prototype &&
        Object.getPrototypeOf(prototype) !== null
      ) {
        return false;
      }
      if (Symbol.iterator in value) {
        return false;
      }
      if (Symbol.toStringTag in value) {
        return Object.prototype.toString.call(value) === "[object Module]";
      }
      return true;
    }
    function _defu(baseObject, defaults, namespace = ".", merger) {
      if (!isPlainObject(defaults)) {
        return _defu(baseObject, {}, namespace, merger);
      }
      const object = Object.assign({}, defaults);
      for (const key in baseObject) {
        if (key === "__proto__" || key === "constructor") {
          continue;
        }
        const value = baseObject[key];
        if (value === null || value === void 0) {
          continue;
        }
        if (merger && merger(object, key, value, namespace)) {
          continue;
        }
        if (Array.isArray(value) && Array.isArray(object[key])) {
          object[key] = [...value, ...object[key]];
        } else if (isPlainObject(value) && isPlainObject(object[key])) {
          object[key] = _defu(
            value,
            object[key],
            (namespace ? `${namespace}.` : "") + key.toString(),
            merger,
          );
        } else {
          object[key] = value;
        }
      }
      return object;
    }
    function createDefu(merger) {
      return (...arguments_) =>
        // eslint-disable-next-line unicorn/no-array-reduce
        arguments_.reduce((p, c) => _defu(p, c, "", merger), {});
    }
    const defu = createDefu();
    const defuFn = createDefu((object, key, currentValue) => {
      if (object[key] !== void 0 && typeof currentValue === "function") {
        object[key] = currentValue(object[key]);
        return true;
      }
    });
    const defuArrayFn = createDefu((object, key, currentValue) => {
      if (Array.isArray(object[key]) && typeof currentValue === "function") {
        object[key] = currentValue(object[key]);
        return true;
      }
    });
  },
  "[project]/node_modules/@better-auth/telemetry/dist/index.mjs [app-route] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "createTelemetry",
      () => createTelemetry,
      "getTelemetryAuthConfig",
      () => getTelemetryAuthConfig,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/env/index.mjs [app-route] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/env/env-impl.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$logger$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/env/logger.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$fetch$2f$fetch$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-fetch/fetch/dist/index.js [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/utils/dist/base64.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hash$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/utils/dist/hash.mjs [app-route] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$random$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/utils/dist/random.mjs [app-route] (ecmascript)",
      );
    //#region src/detectors/detect-auth-config.ts
    function getTelemetryAuthConfig(options, context) {
      return {
        database: context?.database,
        adapter: context?.adapter,
        emailVerification: {
          sendVerificationEmail: !!options.emailVerification?.sendVerificationEmail,
          sendOnSignUp: !!options.emailVerification?.sendOnSignUp,
          sendOnSignIn: !!options.emailVerification?.sendOnSignIn,
          autoSignInAfterVerification: !!options.emailVerification?.autoSignInAfterVerification,
          expiresIn: options.emailVerification?.expiresIn,
          onEmailVerification: !!options.emailVerification?.onEmailVerification,
          afterEmailVerification: !!options.emailVerification?.afterEmailVerification,
        },
        emailAndPassword: {
          enabled: !!options.emailAndPassword?.enabled,
          disableSignUp: !!options.emailAndPassword?.disableSignUp,
          requireEmailVerification: !!options.emailAndPassword?.requireEmailVerification,
          maxPasswordLength: options.emailAndPassword?.maxPasswordLength,
          minPasswordLength: options.emailAndPassword?.minPasswordLength,
          sendResetPassword: !!options.emailAndPassword?.sendResetPassword,
          resetPasswordTokenExpiresIn: options.emailAndPassword?.resetPasswordTokenExpiresIn,
          onPasswordReset: !!options.emailAndPassword?.onPasswordReset,
          password: {
            hash: !!options.emailAndPassword?.password?.hash,
            verify: !!options.emailAndPassword?.password?.verify,
          },
          autoSignIn: !!options.emailAndPassword?.autoSignIn,
          revokeSessionsOnPasswordReset: !!options.emailAndPassword?.revokeSessionsOnPasswordReset,
        },
        socialProviders: Object.keys(options.socialProviders || {}).map((p) => {
          const provider = options.socialProviders?.[p];
          if (!provider) return {};
          return {
            id: p,
            mapProfileToUser: !!provider.mapProfileToUser,
            disableDefaultScope: !!provider.disableDefaultScope,
            disableIdTokenSignIn: !!provider.disableIdTokenSignIn,
            disableImplicitSignUp: provider.disableImplicitSignUp,
            disableSignUp: provider.disableSignUp,
            getUserInfo: !!provider.getUserInfo,
            overrideUserInfoOnSignIn: !!provider.overrideUserInfoOnSignIn,
            prompt: provider.prompt,
            verifyIdToken: !!provider.verifyIdToken,
            scope: provider.scope,
            refreshAccessToken: !!provider.refreshAccessToken,
          };
        }),
        plugins: options.plugins?.map((p) => p.id.toString()),
        user: {
          modelName: options.user?.modelName,
          fields: options.user?.fields,
          additionalFields: options.user?.additionalFields,
          changeEmail: {
            enabled: options.user?.changeEmail?.enabled,
            sendChangeEmailVerification: !!options.user?.changeEmail?.sendChangeEmailVerification,
          },
        },
        verification: {
          modelName: options.verification?.modelName,
          disableCleanup: options.verification?.disableCleanup,
          fields: options.verification?.fields,
        },
        session: {
          modelName: options.session?.modelName,
          additionalFields: options.session?.additionalFields,
          cookieCache: {
            enabled: options.session?.cookieCache?.enabled,
            maxAge: options.session?.cookieCache?.maxAge,
            strategy: options.session?.cookieCache?.strategy,
          },
          disableSessionRefresh: options.session?.disableSessionRefresh,
          expiresIn: options.session?.expiresIn,
          fields: options.session?.fields,
          freshAge: options.session?.freshAge,
          preserveSessionInDatabase: options.session?.preserveSessionInDatabase,
          storeSessionInDatabase: options.session?.storeSessionInDatabase,
          updateAge: options.session?.updateAge,
        },
        account: {
          modelName: options.account?.modelName,
          fields: options.account?.fields,
          encryptOAuthTokens: options.account?.encryptOAuthTokens,
          updateAccountOnSignIn: options.account?.updateAccountOnSignIn,
          accountLinking: {
            enabled: options.account?.accountLinking?.enabled,
            trustedProviders: options.account?.accountLinking?.trustedProviders,
            updateUserInfoOnLink: options.account?.accountLinking?.updateUserInfoOnLink,
            allowUnlinkingAll: options.account?.accountLinking?.allowUnlinkingAll,
          },
        },
        hooks: {
          after: !!options.hooks?.after,
          before: !!options.hooks?.before,
        },
        secondaryStorage: !!options.secondaryStorage,
        advanced: {
          cookiePrefix: !!options.advanced?.cookiePrefix,
          cookies: !!options.advanced?.cookies,
          crossSubDomainCookies: {
            domain: !!options.advanced?.crossSubDomainCookies?.domain,
            enabled: options.advanced?.crossSubDomainCookies?.enabled,
            additionalCookies: options.advanced?.crossSubDomainCookies?.additionalCookies,
          },
          database: {
            useNumberId:
              !!options.advanced?.database?.useNumberId ||
              options.advanced?.database?.generateId === "serial",
            generateId: options.advanced?.database?.generateId,
            defaultFindManyLimit: options.advanced?.database?.defaultFindManyLimit,
          },
          useSecureCookies: options.advanced?.useSecureCookies,
          ipAddress: {
            disableIpTracking: options.advanced?.ipAddress?.disableIpTracking,
            ipAddressHeaders: options.advanced?.ipAddress?.ipAddressHeaders,
          },
          disableCSRFCheck: options.advanced?.disableCSRFCheck,
          cookieAttributes: {
            expires: options.advanced?.defaultCookieAttributes?.expires,
            secure: options.advanced?.defaultCookieAttributes?.secure,
            sameSite: options.advanced?.defaultCookieAttributes?.sameSite,
            domain: !!options.advanced?.defaultCookieAttributes?.domain,
            path: options.advanced?.defaultCookieAttributes?.path,
            httpOnly: options.advanced?.defaultCookieAttributes?.httpOnly,
          },
        },
        trustedOrigins: options.trustedOrigins?.length,
        rateLimit: {
          storage: options.rateLimit?.storage,
          modelName: options.rateLimit?.modelName,
          window: options.rateLimit?.window,
          customStorage: !!options.rateLimit?.customStorage,
          enabled: options.rateLimit?.enabled,
          max: options.rateLimit?.max,
        },
        onAPIError: {
          errorURL: options.onAPIError?.errorURL,
          onError: !!options.onAPIError?.onError,
          throw: options.onAPIError?.throw,
        },
        logger: {
          disabled: options.logger?.disabled,
          level: options.logger?.level,
          log: !!options.logger?.log,
        },
        databaseHooks: {
          user: {
            create: {
              after: !!options.databaseHooks?.user?.create?.after,
              before: !!options.databaseHooks?.user?.create?.before,
            },
            update: {
              after: !!options.databaseHooks?.user?.update?.after,
              before: !!options.databaseHooks?.user?.update?.before,
            },
          },
          session: {
            create: {
              after: !!options.databaseHooks?.session?.create?.after,
              before: !!options.databaseHooks?.session?.create?.before,
            },
            update: {
              after: !!options.databaseHooks?.session?.update?.after,
              before: !!options.databaseHooks?.session?.update?.before,
            },
          },
          account: {
            create: {
              after: !!options.databaseHooks?.account?.create?.after,
              before: !!options.databaseHooks?.account?.create?.before,
            },
            update: {
              after: !!options.databaseHooks?.account?.update?.after,
              before: !!options.databaseHooks?.account?.update?.before,
            },
          },
          verification: {
            create: {
              after: !!options.databaseHooks?.verification?.create?.after,
              before: !!options.databaseHooks?.verification?.create?.before,
            },
            update: {
              after: !!options.databaseHooks?.verification?.update?.after,
              before: !!options.databaseHooks?.verification?.update?.before,
            },
          },
        },
      };
    }
    //#endregion
    //#region src/utils/package-json.ts
    let packageJSONCache;
    async function readRootPackageJson() {
      if (packageJSONCache) return packageJSONCache;
      try {
        const cwd =
          typeof process !== "undefined" && typeof process.cwd === "function" ? process.cwd() : "";
        if (!cwd) return void 0;
        const importRuntime$1 = (m) => Function("mm", "return import(mm)")(m);
        const [{ default: fs }, { default: path }] = await Promise.all([
          importRuntime$1("fs/promises"),
          importRuntime$1("path"),
        ]);
        const raw = await fs.readFile(path.join(cwd, "package.json"), "utf-8");
        packageJSONCache = JSON.parse(raw);
        return packageJSONCache;
      } catch {}
    }
    async function getPackageVersion(pkg) {
      if (packageJSONCache)
        return (
          packageJSONCache.dependencies?.[pkg] ||
          packageJSONCache.devDependencies?.[pkg] ||
          packageJSONCache.peerDependencies?.[pkg]
        );
      try {
        const cwd =
          typeof process !== "undefined" && typeof process.cwd === "function" ? process.cwd() : "";
        if (!cwd) throw new Error("no-cwd");
        const importRuntime$1 = (m) => Function("mm", "return import(mm)")(m);
        const [{ default: fs }, { default: path }] = await Promise.all([
          importRuntime$1("fs/promises"),
          importRuntime$1("path"),
        ]);
        const pkgJsonPath = path.join(cwd, "node_modules", pkg, "package.json");
        const raw = await fs.readFile(pkgJsonPath, "utf-8");
        return JSON.parse(raw).version || (await getVersionFromLocalPackageJson(pkg)) || void 0;
      } catch {}
      return await getVersionFromLocalPackageJson(pkg);
    }
    async function getVersionFromLocalPackageJson(pkg) {
      const json = await readRootPackageJson();
      if (!json) return void 0;
      return {
        ...json.dependencies,
        ...json.devDependencies,
        ...json.peerDependencies,
      }[pkg];
    }
    async function getNameFromLocalPackageJson() {
      return (await readRootPackageJson())?.name;
    }
    //#endregion
    //#region src/detectors/detect-database.ts
    const DATABASES = {
      pg: "postgresql",
      mysql: "mysql",
      mariadb: "mariadb",
      sqlite3: "sqlite",
      "better-sqlite3": "sqlite",
      "@prisma/client": "prisma",
      mongoose: "mongodb",
      mongodb: "mongodb",
      "drizzle-orm": "drizzle",
    };
    async function detectDatabase() {
      for (const [pkg, name] of Object.entries(DATABASES)) {
        const version = await getPackageVersion(pkg);
        if (version)
          return {
            name,
            version,
          };
      }
    }
    //#endregion
    //#region src/detectors/detect-framework.ts
    const FRAMEWORKS = {
      next: "next",
      nuxt: "nuxt",
      "@remix-run/server-runtime": "remix",
      astro: "astro",
      "@sveltejs/kit": "sveltekit",
      "solid-start": "solid-start",
      "tanstack-start": "tanstack-start",
      hono: "hono",
      express: "express",
      elysia: "elysia",
      expo: "expo",
    };
    async function detectFramework() {
      for (const [pkg, name] of Object.entries(FRAMEWORKS)) {
        const version = await getPackageVersion(pkg);
        if (version)
          return {
            name,
            version,
          };
      }
    }
    //#endregion
    //#region src/detectors/detect-project-info.ts
    function detectPackageManager() {
      const userAgent =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "env"
        ].npm_config_user_agent;
      if (!userAgent) return;
      const pmSpec = userAgent.split(" ")[0];
      const separatorPos = pmSpec.lastIndexOf("/");
      const name = pmSpec.substring(0, separatorPos);
      return {
        name: name === "npminstall" ? "cnpm" : name,
        version: pmSpec.substring(separatorPos + 1),
      };
    }
    //#endregion
    //#region src/utils/import-util.ts
    const importRuntime = (m) => {
      return Function("mm", "return import(mm)")(m);
    };
    //#endregion
    //#region src/detectors/detect-system-info.ts
    function getVendor() {
      const hasAny = (...keys) =>
        keys.some((k) =>
          Boolean(
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "env"
            ][k],
          ),
        );
      if (
        hasAny("CF_PAGES", "CF_PAGES_URL", "CF_ACCOUNT_ID") ||
        (typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers")
      )
        return "cloudflare";
      if (hasAny("VERCEL", "VERCEL_URL", "VERCEL_ENV")) return "vercel";
      if (hasAny("NETLIFY", "NETLIFY_URL")) return "netlify";
      if (hasAny("RENDER", "RENDER_URL", "RENDER_INTERNAL_HOSTNAME", "RENDER_SERVICE_ID"))
        return "render";
      if (hasAny("AWS_LAMBDA_FUNCTION_NAME", "AWS_EXECUTION_ENV", "LAMBDA_TASK_ROOT")) return "aws";
      if (hasAny("GOOGLE_CLOUD_FUNCTION_NAME", "GOOGLE_CLOUD_PROJECT", "GCP_PROJECT", "K_SERVICE"))
        return "gcp";
      if (
        hasAny(
          "AZURE_FUNCTION_NAME",
          "FUNCTIONS_WORKER_RUNTIME",
          "WEBSITE_INSTANCE_ID",
          "WEBSITE_SITE_NAME",
        )
      )
        return "azure";
      if (hasAny("DENO_DEPLOYMENT_ID", "DENO_REGION")) return "deno-deploy";
      if (hasAny("FLY_APP_NAME", "FLY_REGION", "FLY_ALLOC_ID")) return "fly-io";
      if (hasAny("RAILWAY_STATIC_URL", "RAILWAY_ENVIRONMENT_NAME")) return "railway";
      if (hasAny("DYNO", "HEROKU_APP_NAME")) return "heroku";
      if (hasAny("DO_DEPLOYMENT_ID", "DO_APP_NAME", "DIGITALOCEAN")) return "digitalocean";
      if (hasAny("KOYEB", "KOYEB_DEPLOYMENT_ID", "KOYEB_APP_NAME")) return "koyeb";
      return null;
    }
    async function detectSystemInfo() {
      try {
        if (getVendor() === "cloudflare") return "cloudflare";
        const os = await importRuntime("os");
        const cpus = os.cpus();
        return {
          deploymentVendor: getVendor(),
          systemPlatform: os.platform(),
          systemRelease: os.release(),
          systemArchitecture: os.arch(),
          cpuCount: cpus.length,
          cpuModel: cpus.length ? cpus[0].model : null,
          cpuSpeed: cpus.length ? cpus[0].speed : null,
          memory: os.totalmem(),
          isWSL: await isWsl(),
          isDocker: await isDocker(),
          isTTY: typeof process !== "undefined" && process.stdout ? process.stdout.isTTY : null,
        };
      } catch {
        return {
          systemPlatform: null,
          systemRelease: null,
          systemArchitecture: null,
          cpuCount: null,
          cpuModel: null,
          cpuSpeed: null,
          memory: null,
          isWSL: null,
          isDocker: null,
          isTTY: null,
        };
      }
    }
    let isDockerCached;
    async function hasDockerEnv() {
      if (getVendor() === "cloudflare") return false;
      try {
        (await importRuntime("fs")).statSync("/.dockerenv");
        return true;
      } catch {
        return false;
      }
    }
    async function hasDockerCGroup() {
      if (getVendor() === "cloudflare") return false;
      try {
        return (await importRuntime("fs"))
          .readFileSync("/proc/self/cgroup", "utf8")
          .includes("docker");
      } catch {
        return false;
      }
    }
    async function isDocker() {
      if (getVendor() === "cloudflare") return false;
      if (isDockerCached === void 0)
        isDockerCached = (await hasDockerEnv()) || (await hasDockerCGroup());
      return isDockerCached;
    }
    async function isWsl() {
      try {
        if (getVendor() === "cloudflare") return false;
        if (typeof process === "undefined" || process?.platform !== "linux") return false;
        const fs = await importRuntime("fs");
        if ((await importRuntime("os")).release().toLowerCase().includes("microsoft")) {
          if (await isInsideContainer()) return false;
          return true;
        }
        return fs.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft")
          ? !(await isInsideContainer())
          : false;
      } catch {
        return false;
      }
    }
    let isInsideContainerCached;
    const hasContainerEnv = async () => {
      if (getVendor() === "cloudflare") return false;
      try {
        (await importRuntime("fs")).statSync("/run/.containerenv");
        return true;
      } catch {
        return false;
      }
    };
    async function isInsideContainer() {
      if (isInsideContainerCached === void 0)
        isInsideContainerCached = (await hasContainerEnv()) || (await isDocker());
      return isInsideContainerCached;
    }
    function isCI() {
      return (
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "env"
        ].CI !== "false" &&
        ("BUILD_ID" in
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "env"
          ] ||
          "BUILD_NUMBER" in
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "env"
            ] ||
          "CI" in
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "env"
            ] ||
          "CI_APP_ID" in
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "env"
            ] ||
          "CI_BUILD_ID" in
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "env"
            ] ||
          "CI_BUILD_NUMBER" in
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "env"
            ] ||
          "CI_NAME" in
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "env"
            ] ||
          "CONTINUOUS_INTEGRATION" in
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "env"
            ] ||
          "RUN_ID" in
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "env"
            ])
      );
    }
    //#endregion
    //#region src/detectors/detect-runtime.ts
    function detectRuntime() {
      if (typeof Deno !== "undefined")
        return {
          name: "deno",
          version: Deno?.version?.deno ?? null,
        };
      if (typeof Bun !== "undefined")
        return {
          name: "bun",
          version: Bun?.version ?? null,
        };
      if (typeof process !== "undefined" && process?.versions?.node)
        return {
          name: "node",
          version: process.versions.node ?? null,
        };
      return {
        name: "edge",
        version: null,
      };
    }
    function detectEnvironment() {
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "getEnvVar"
      ])("NODE_ENV") === "production"
        ? "production"
        : isCI()
          ? "ci"
          : (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "isTest"
              ])()
            ? "test"
            : "development";
    }
    //#endregion
    //#region src/utils/hash.ts
    async function hashToBase64(data) {
      const buffer = await (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$hash$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "createHash"
      ])("SHA-256").digest(data);
      return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$base64$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "base64"
      ].encode(buffer);
    }
    //#endregion
    //#region src/utils/id.ts
    const generateId = (size) => {
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$random$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
        "createRandomStringGenerator"
      ])(
        "a-z",
        "A-Z",
        "0-9",
      )(size || 32);
    };
    //#endregion
    //#region src/project-id.ts
    let projectIdCached = null;
    async function getProjectId(baseUrl) {
      if (projectIdCached) return projectIdCached;
      const projectName = await getNameFromLocalPackageJson();
      if (projectName) {
        projectIdCached = await hashToBase64(baseUrl ? baseUrl + projectName : projectName);
        return projectIdCached;
      }
      if (baseUrl) {
        projectIdCached = await hashToBase64(baseUrl);
        return projectIdCached;
      }
      projectIdCached = generateId(32);
      return projectIdCached;
    }
    //#endregion
    //#region src/index.ts
    const noop = async function noop$1() {};
    async function createTelemetry(options, context) {
      const debugEnabled =
        options.telemetry?.debug ||
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "getBooleanEnvVar"
        ])("BETTER_AUTH_TELEMETRY_DEBUG", false);
      const telemetryEndpoint =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
          "ENV"
        ].BETTER_AUTH_TELEMETRY_ENDPOINT;
      if (!telemetryEndpoint && !context?.customTrack)
        return {
          publish: noop,
        };
      const track = async (event) => {
        if (context?.customTrack)
          await context
            .customTrack(event)
            .catch(
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$logger$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "logger"
              ].error,
            );
        else if (telemetryEndpoint)
          if (debugEnabled)
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$logger$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "logger"
            ].info("telemetry event", JSON.stringify(event, null, 2));
          else
            await (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$fetch$2f$fetch$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "betterFetch"
            ])(telemetryEndpoint, {
              method: "POST",
              body: event,
            }).catch(
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$logger$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
                "logger"
              ].error,
            );
      };
      const isEnabled = async () => {
        const telemetryEnabled =
          options.telemetry?.enabled !== void 0 ? options.telemetry.enabled : false;
        return (
          ((0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
            "getBooleanEnvVar"
          ])("BETTER_AUTH_TELEMETRY", false) ||
            telemetryEnabled) &&
          (context?.skipTestCheck ||
            !(0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__[
              "isTest"
            ])())
        );
      };
      const enabled = await isEnabled();
      let anonymousId;
      if (enabled) {
        anonymousId = await getProjectId(options.baseURL);
        track({
          type: "init",
          payload: {
            config: getTelemetryAuthConfig(options, context),
            runtime: detectRuntime(),
            database: await detectDatabase(),
            framework: await detectFramework(),
            environment: detectEnvironment(),
            systemInfo: await detectSystemInfo(),
            packageManager: detectPackageManager(),
          },
          anonymousId,
        });
      }
      return {
        publish: async (event) => {
          if (!enabled) return;
          if (!anonymousId) anonymousId = await getProjectId(options.baseURL);
          await track({
            type: event.type,
            payload: event.payload,
            anonymousId,
          });
        },
      };
    }
  },
  //# sourceMappingURL=index.mjs.map
];

//# sourceMappingURL=node_modules_ba340ef5._.js.map
