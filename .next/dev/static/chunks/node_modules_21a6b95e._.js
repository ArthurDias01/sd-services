(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([
  typeof document === "object" ? document.currentScript : undefined,
  "[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    /**
     * @license React
     * react-jsx-dev-runtime.development.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */ ("use strict");
    "production" !== ("TURBOPACK compile-time value", "development") &&
      (function () {
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE
              ? null
              : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
              return "Activity";
            case REACT_VIEW_TRANSITION_TYPE:
              return "ViewTransition";
          }
          if ("object" === typeof type)
            switch (
              ("number" === typeof type.tag &&
                console.error(
                  "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.",
                ),
              type.$$typeof)
            ) {
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type ||
                  ((type = innerType.displayName || innerType.name || ""),
                  (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
                return type;
              case REACT_MEMO_TYPE:
                return (
                  (innerType = type.displayName || null),
                  null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo"
                );
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x) {}
            }
          return null;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
          } catch (e) {
            JSCompiler_inline_result = !0;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 =
              ("function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag]) ||
              value.constructor.name ||
              "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0,
            );
            return testStringCoercion(value);
          }
        }
        function getTaskName(type) {
          if (type === REACT_FRAGMENT_TYPE) return "<>";
          if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
            return "<...>";
          try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
          } catch (x) {
            return "<...>";
          }
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function UnknownOwner() {
          return Error("react-stack-top-frame");
        }
        function hasValidKey(config) {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
          }
          return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown ||
              ((specialPropKeyWarningShown = !0),
              console.error(
                "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
                displayName,
              ));
          }
          warnAboutAccessingKey.isReactWarning = !0;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0,
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] ||
            ((didWarnAboutElementRef[componentName] = !0),
            console.error(
              "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.",
            ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, props, owner, debugStack, debugTask) {
          var refProp = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner,
          };
          null !== (void 0 !== refProp ? refProp : null)
            ? Object.defineProperty(type, "ref", {
                enumerable: !1,
                get: elementRefGetterWithDeprecationWarning,
              })
            : Object.defineProperty(type, "ref", {
                enumerable: !1,
                value: null,
              });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0,
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null,
          });
          Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack,
          });
          Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask,
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
          var children = config.children;
          if (void 0 !== children)
            if (isStaticChildren)
              if (isArrayImpl(children)) {
                for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                  validateChildKeys(children[isStaticChildren]);
                Object.freeze && Object.freeze(children);
              } else
                console.error(
                  "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.",
                );
            else validateChildKeys(children);
          if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function (k) {
              return "key" !== k;
            });
            isStaticChildren =
              0 < keys.length
                ? "{key: someKey, " + keys.join(": ..., ") + ": ...}"
                : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] ||
              ((keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}"),
              console.error(
                'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
                isStaticChildren,
                children,
                keys,
                children,
              ),
              (didWarnAboutKeySpread[children + isStaticChildren] = !0));
          }
          children = null;
          void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), (children = "" + maybeKey));
          hasValidKey(config) && (checkKeyStringCoercion(config.key), (children = "" + config.key));
          if ("key" in config) {
            maybeKey = {};
            for (var propName in config)
              "key" !== propName && (maybeKey[propName] = config[propName]);
          } else maybeKey = config;
          children &&
            defineKeyPropWarningGetter(
              maybeKey,
              "function" === typeof type ? type.displayName || type.name || "Unknown" : type,
            );
          return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
        }
        function validateChildKeys(node) {
          isValidElement(node)
            ? node._store && (node._store.validated = 1)
            : "object" === typeof node &&
              null !== node &&
              node.$$typeof === REACT_LAZY_TYPE &&
              ("fulfilled" === node._payload.status
                ? isValidElement(node._payload.value) &&
                  node._payload.value._store &&
                  (node._payload.value._store.validated = 1)
                : node._store && (node._store.validated = 1));
        }
        function isValidElement(object) {
          return (
            "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE
          );
        }
        var React = __turbopack_context__.r(
            "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
          ),
          REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
          REACT_PORTAL_TYPE = Symbol.for("react.portal"),
          REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
          REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
          REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
          REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
          REACT_CONTEXT_TYPE = Symbol.for("react.context"),
          REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
          REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
          REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
          REACT_MEMO_TYPE = Symbol.for("react.memo"),
          REACT_LAZY_TYPE = Symbol.for("react.lazy"),
          REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
          REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
          REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
          ReactSharedInternals =
            React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
          hasOwnProperty = Object.prototype.hasOwnProperty,
          isArrayImpl = Array.isArray,
          createTask = console.createTask
            ? console.createTask
            : function () {
                return null;
              };
        React = {
          react_stack_bottom_frame: function (callStackForError) {
            return callStackForError();
          },
        };
        var specialPropKeyWarningShown;
        var didWarnAboutElementRef = {};
        var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(React, UnknownOwner)();
        var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
        var didWarnAboutKeySpread = {};
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsxDEV = function (type, config, maybeKey, isStaticChildren) {
          var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
          if (trackActualOwner) {
            var previousStackTraceLimit = Error.stackTraceLimit;
            Error.stackTraceLimit = 10;
            var debugStackDEV = Error("react-stack-top-frame");
            Error.stackTraceLimit = previousStackTraceLimit;
          } else debugStackDEV = unknownOwnerDebugStack;
          return jsxDEVImpl(
            type,
            config,
            maybeKey,
            isStaticChildren,
            debugStackDEV,
            trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask,
          );
        };
      })();
  },
  "[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    ("use strict");
    if (("TURBOPACK compile-time falsy", 0)) //TURBOPACK unreachable
    ;
    else {
      module.exports = __turbopack_context__.r(
        "[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)",
      );
    }
  },
  "[project]/node_modules/next/dist/compiled/react/cjs/react-compiler-runtime.development.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    /**
     * @license React
     * react-compiler-runtime.development.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */ ("use strict");
    "production" !== ("TURBOPACK compile-time value", "development") &&
      (function () {
        var ReactSharedInternals = __turbopack_context__.r(
          "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
        ).__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        exports.c = function (size) {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher &&
            console.error(
              "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.",
            );
          return dispatcher.useMemoCache(size);
        };
      })();
  },
  "[project]/node_modules/next/dist/compiled/react/compiler-runtime.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */ ("use strict");
    if (("TURBOPACK compile-time falsy", 0)) //TURBOPACK unreachable
    ;
    else {
      module.exports = __turbopack_context__.r(
        "[project]/node_modules/next/dist/compiled/react/cjs/react-compiler-runtime.development.js [app-client] (ecmascript)",
      );
    }
  },
  "[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    0 &&
      (module.exports = {
        assign: null,
        searchParamsToUrlQuery: null,
        urlQueryToSearchParams: null,
      });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      assign: function () {
        return assign;
      },
      searchParamsToUrlQuery: function () {
        return searchParamsToUrlQuery;
      },
      urlQueryToSearchParams: function () {
        return urlQueryToSearchParams;
      },
    });
    function searchParamsToUrlQuery(searchParams) {
      const query = {};
      for (const [key, value] of searchParams.entries()) {
        const existing = query[key];
        if (typeof existing === "undefined") {
          query[key] = value;
        } else if (Array.isArray(existing)) {
          existing.push(value);
        } else {
          query[key] = [existing, value];
        }
      }
      return query;
    }
    function stringifyUrlQueryParam(param) {
      if (typeof param === "string") {
        return param;
      }
      if ((typeof param === "number" && !isNaN(param)) || typeof param === "boolean") {
        return String(param);
      } else {
        return "";
      }
    }
    function urlQueryToSearchParams(query) {
      const searchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(query)) {
        if (Array.isArray(value)) {
          for (const item of value) {
            searchParams.append(key, stringifyUrlQueryParam(item));
          }
        } else {
          searchParams.set(key, stringifyUrlQueryParam(value));
        }
      }
      return searchParams;
    }
    function assign(target, ...searchParamsList) {
      for (const searchParams of searchParamsList) {
        for (const key of searchParams.keys()) {
          target.delete(key);
        }
        for (const [key, value] of searchParams.entries()) {
          target.append(key, value);
        }
      }
      return target;
    } //# sourceMappingURL=querystring.js.map
  },
  "[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    // Format function modified from nodejs
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    ("use strict");
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    0 &&
      (module.exports = {
        formatUrl: null,
        formatWithValidation: null,
        urlObjectKeys: null,
      });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      formatUrl: function () {
        return formatUrl;
      },
      formatWithValidation: function () {
        return formatWithValidation;
      },
      urlObjectKeys: function () {
        return urlObjectKeys;
      },
    });
    const _interop_require_wildcard = __turbopack_context__.r(
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)",
    );
    const _querystring = /*#__PURE__*/ _interop_require_wildcard._(
      __turbopack_context__.r(
        "[project]/node_modules/next/dist/shared/lib/router/utils/querystring.js [app-client] (ecmascript)",
      ),
    );
    const slashedProtocols = /https?|ftp|gopher|file/;
    function formatUrl(urlObj) {
      let { auth, hostname } = urlObj;
      let protocol = urlObj.protocol || "";
      let pathname = urlObj.pathname || "";
      let hash = urlObj.hash || "";
      let query = urlObj.query || "";
      let host = false;
      auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ":") + "@" : "";
      if (urlObj.host) {
        host = auth + urlObj.host;
      } else if (hostname) {
        host = auth + (~hostname.indexOf(":") ? `[${hostname}]` : hostname);
        if (urlObj.port) {
          host += ":" + urlObj.port;
        }
      }
      if (query && typeof query === "object") {
        query = String(_querystring.urlQueryToSearchParams(query));
      }
      let search = urlObj.search || (query && `?${query}`) || "";
      if (protocol && !protocol.endsWith(":")) protocol += ":";
      if (urlObj.slashes || ((!protocol || slashedProtocols.test(protocol)) && host !== false)) {
        host = "//" + (host || "");
        if (pathname && pathname[0] !== "/") pathname = "/" + pathname;
      } else if (!host) {
        host = "";
      }
      if (hash && hash[0] !== "#") hash = "#" + hash;
      if (search && search[0] !== "?") search = "?" + search;
      pathname = pathname.replace(/[?#]/g, encodeURIComponent);
      search = search.replace("#", "%23");
      return `${protocol}${host}${pathname}${search}${hash}`;
    }
    const urlObjectKeys = [
      "auth",
      "hash",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "slashes",
    ];
    function formatWithValidation(url) {
      if (("TURBOPACK compile-time truthy", 1)) {
        if (url !== null && typeof url === "object") {
          Object.keys(url).forEach((key) => {
            if (!urlObjectKeys.includes(key)) {
              console.warn(`Unknown key passed via urlObject into url.format: ${key}`);
            }
          });
        }
      }
      return formatUrl(url);
    } //# sourceMappingURL=format-url.js.map
  },
  "[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    Object.defineProperty(exports, "useMergedRef", {
      enumerable: true,
      get: function () {
        return useMergedRef;
      },
    });
    const _react = __turbopack_context__.r(
      "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
    );
    function useMergedRef(refA, refB) {
      const cleanupA = (0, _react.useRef)(null);
      const cleanupB = (0, _react.useRef)(null);
      // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.
      // (this happens often if the user doesn't pass a ref to Link/Form/Image)
      // But this can cause us to leak a cleanup-ref into user code (previously via `<Link legacyBehavior>`),
      // and the user might pass that ref into ref-merging library that doesn't support cleanup refs
      // (because it hasn't been updated for React 19)
      // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.
      // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.
      return (0, _react.useCallback)(
        (current) => {
          if (current === null) {
            const cleanupFnA = cleanupA.current;
            if (cleanupFnA) {
              cleanupA.current = null;
              cleanupFnA();
            }
            const cleanupFnB = cleanupB.current;
            if (cleanupFnB) {
              cleanupB.current = null;
              cleanupFnB();
            }
          } else {
            if (refA) {
              cleanupA.current = applyRef(refA, current);
            }
            if (refB) {
              cleanupB.current = applyRef(refB, current);
            }
          }
        },
        [refA, refB],
      );
    }
    function applyRef(refA, current) {
      if (typeof refA === "function") {
        const cleanup = refA(current);
        if (typeof cleanup === "function") {
          return cleanup;
        } else {
          return () => refA(null);
        }
      } else {
        refA.current = current;
        return () => {
          refA.current = null;
        };
      }
    }
    if (
      (typeof exports.default === "function" ||
        (typeof exports.default === "object" && exports.default !== null)) &&
      typeof exports.default.__esModule === "undefined"
    ) {
      Object.defineProperty(exports.default, "__esModule", {
        value: true,
      });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    } //# sourceMappingURL=use-merged-ref.js.map
  },
  "[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    ("use strict");
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    0 &&
      (module.exports = {
        DecodeError: null,
        MiddlewareNotFoundError: null,
        MissingStaticPage: null,
        NormalizeError: null,
        PageNotFoundError: null,
        SP: null,
        ST: null,
        WEB_VITALS: null,
        execOnce: null,
        getDisplayName: null,
        getLocationOrigin: null,
        getURL: null,
        isAbsoluteUrl: null,
        isResSent: null,
        loadGetInitialProps: null,
        normalizeRepeatedSlashes: null,
        stringifyError: null,
      });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      DecodeError: function () {
        return DecodeError;
      },
      MiddlewareNotFoundError: function () {
        return MiddlewareNotFoundError;
      },
      MissingStaticPage: function () {
        return MissingStaticPage;
      },
      NormalizeError: function () {
        return NormalizeError;
      },
      PageNotFoundError: function () {
        return PageNotFoundError;
      },
      SP: function () {
        return SP;
      },
      ST: function () {
        return ST;
      },
      WEB_VITALS: function () {
        return WEB_VITALS;
      },
      execOnce: function () {
        return execOnce;
      },
      getDisplayName: function () {
        return getDisplayName;
      },
      getLocationOrigin: function () {
        return getLocationOrigin;
      },
      getURL: function () {
        return getURL;
      },
      isAbsoluteUrl: function () {
        return isAbsoluteUrl;
      },
      isResSent: function () {
        return isResSent;
      },
      loadGetInitialProps: function () {
        return loadGetInitialProps;
      },
      normalizeRepeatedSlashes: function () {
        return normalizeRepeatedSlashes;
      },
      stringifyError: function () {
        return stringifyError;
      },
    });
    const WEB_VITALS = ["CLS", "FCP", "FID", "INP", "LCP", "TTFB"];
    function execOnce(fn) {
      let used = false;
      let result;
      return (...args) => {
        if (!used) {
          used = true;
          result = fn(...args);
        }
        return result;
      };
    }
    // Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
    // Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
    const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
    const isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);
    function getLocationOrigin() {
      const { protocol, hostname, port } = window.location;
      return `${protocol}//${hostname}${port ? ":" + port : ""}`;
    }
    function getURL() {
      const { href } = window.location;
      const origin = getLocationOrigin();
      return href.substring(origin.length);
    }
    function getDisplayName(Component) {
      return typeof Component === "string"
        ? Component
        : Component.displayName || Component.name || "Unknown";
    }
    function isResSent(res) {
      return res.finished || res.headersSent;
    }
    function normalizeRepeatedSlashes(url) {
      const urlParts = url.split("?");
      const urlNoQuery = urlParts[0];
      return (
        urlNoQuery // first we replace any non-encoded backslashes with forward
          // then normalize repeated forward slashes
          .replace(/\\/g, "/")
          .replace(/\/\/+/g, "/") + (urlParts[1] ? `?${urlParts.slice(1).join("?")}` : "")
      );
    }
    async function loadGetInitialProps(App, ctx) {
      if (("TURBOPACK compile-time truthy", 1)) {
        if (App.prototype?.getInitialProps) {
          const message = `"${getDisplayName(App)}.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;
          throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true,
          });
        }
      }
      // when called from _app `ctx` is nested in `ctx`
      const res = ctx.res || (ctx.ctx && ctx.ctx.res);
      if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
          // @ts-ignore pageProps default
          return {
            pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx),
          };
        }
        return {};
      }
      const props = await App.getInitialProps(ctx);
      if (res && isResSent(res)) {
        return props;
      }
      if (!props) {
        const message = `"${getDisplayName(App)}.getInitialProps()" should resolve to an object. But found "${props}" instead.`;
        throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
          value: "E394",
          enumerable: false,
          configurable: true,
        });
      }
      if (("TURBOPACK compile-time truthy", 1)) {
        if (Object.keys(props).length === 0 && !ctx.ctx) {
          console.warn(
            `${getDisplayName(App)} returned an empty object from \`getInitialProps\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`,
          );
        }
      }
      return props;
    }
    const SP = typeof performance !== "undefined";
    const ST =
      SP &&
      ["mark", "measure", "getEntriesByName"].every(
        (method) => typeof performance[method] === "function",
      );
    class DecodeError extends Error {}
    class NormalizeError extends Error {}
    class PageNotFoundError extends Error {
      constructor(page) {
        super();
        this.code = "ENOENT";
        this.name = "PageNotFoundError";
        this.message = `Cannot find module for page: ${page}`;
      }
    }
    class MissingStaticPage extends Error {
      constructor(page, message) {
        super();
        this.message = `Failed to load static file for page: ${page} ${message}`;
      }
    }
    class MiddlewareNotFoundError extends Error {
      constructor() {
        super();
        this.code = "ENOENT";
        this.message = `Cannot find the middleware module`;
      }
    }
    function stringifyError(error) {
      return JSON.stringify({
        message: error.message,
        stack: error.stack,
      });
    } //# sourceMappingURL=utils.js.map
  },
  "[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    Object.defineProperty(exports, "isLocalURL", {
      enumerable: true,
      get: function () {
        return isLocalURL;
      },
    });
    const _utils = __turbopack_context__.r(
      "[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)",
    );
    const _hasbasepath = __turbopack_context__.r(
      "[project]/node_modules/next/dist/client/has-base-path.js [app-client] (ecmascript)",
    );
    function isLocalURL(url) {
      // prevent a hydration mismatch on href for url with anchor refs
      if (!(0, _utils.isAbsoluteUrl)(url)) return true;
      try {
        // absolute urls can be local if they are on the same origin
        const locationOrigin = (0, _utils.getLocationOrigin)();
        const resolved = new URL(url, locationOrigin);
        return (
          resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname)
        );
      } catch (_) {
        return false;
      }
    } //# sourceMappingURL=is-local-url.js.map
  },
  "[project]/node_modules/next/dist/shared/lib/utils/error-once.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    ("use strict");
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    Object.defineProperty(exports, "errorOnce", {
      enumerable: true,
      get: function () {
        return errorOnce;
      },
    });
    let errorOnce = (_) => {};
    if (("TURBOPACK compile-time truthy", 1)) {
      const errors = new Set();
      errorOnce = (msg) => {
        if (!errors.has(msg)) {
          console.error(msg);
        }
        errors.add(msg);
      };
    } //# sourceMappingURL=error-once.js.map
  },
  "[project]/node_modules/next/dist/client/app-dir/link.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    ("use client");
    ("use strict");
    Object.defineProperty(exports, "__esModule", {
      value: true,
    });
    0 &&
      (module.exports = {
        default: null,
        useLinkStatus: null,
      });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name],
        });
    }
    _export(exports, {
      /**
       * A React component that extends the HTML `<a>` element to provide
       * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)
       * and client-side navigation. This is the primary way to navigate between routes in Next.js.
       *
       * @remarks
       * - Prefetching is only enabled in production.
       *
       * @see https://nextjs.org/docs/app/api-reference/components/link
       */ default: function () {
        return LinkComponent;
      },
      useLinkStatus: function () {
        return useLinkStatus;
      },
    });
    const _interop_require_wildcard = __turbopack_context__.r(
      "[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)",
    );
    const _jsxruntime = __turbopack_context__.r(
      "[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)",
    );
    const _react = /*#__PURE__*/ _interop_require_wildcard._(
      __turbopack_context__.r(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      ),
    );
    const _formaturl = __turbopack_context__.r(
      "[project]/node_modules/next/dist/shared/lib/router/utils/format-url.js [app-client] (ecmascript)",
    );
    const _approutercontextsharedruntime = __turbopack_context__.r(
      "[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)",
    );
    const _usemergedref = __turbopack_context__.r(
      "[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)",
    );
    const _utils = __turbopack_context__.r(
      "[project]/node_modules/next/dist/shared/lib/utils.js [app-client] (ecmascript)",
    );
    const _addbasepath = __turbopack_context__.r(
      "[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)",
    );
    const _warnonce = __turbopack_context__.r(
      "[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)",
    );
    const _links = __turbopack_context__.r(
      "[project]/node_modules/next/dist/client/components/links.js [app-client] (ecmascript)",
    );
    const _islocalurl = __turbopack_context__.r(
      "[project]/node_modules/next/dist/shared/lib/router/utils/is-local-url.js [app-client] (ecmascript)",
    );
    const _types = __turbopack_context__.r(
      "[project]/node_modules/next/dist/client/components/segment-cache/types.js [app-client] (ecmascript)",
    );
    const _erroronce = __turbopack_context__.r(
      "[project]/node_modules/next/dist/shared/lib/utils/error-once.js [app-client] (ecmascript)",
    );
    function isModifiedEvent(event) {
      const eventTarget = event.currentTarget;
      const target = eventTarget.getAttribute("target");
      return (
        (target && target !== "_self") ||
        event.metaKey ||
        event.ctrlKey ||
        event.shiftKey ||
        event.altKey || // triggers resource download
        (event.nativeEvent && event.nativeEvent.which === 2)
      );
    }
    function linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate) {
      if (typeof window !== "undefined") {
        const { nodeName } = e.currentTarget;
        // anchors inside an svg have a lowercase nodeName
        const isAnchorNodeName = nodeName.toUpperCase() === "A";
        if ((isAnchorNodeName && isModifiedEvent(e)) || e.currentTarget.hasAttribute("download")) {
          // ignore click for browser’s default behavior
          return;
        }
        if (!(0, _islocalurl.isLocalURL)(href)) {
          if (replace) {
            // browser default behavior does not replace the history state
            // so we need to do it manually
            e.preventDefault();
            location.replace(href);
          }
          // ignore click for browser’s default behavior
          return;
        }
        e.preventDefault();
        if (onNavigate) {
          let isDefaultPrevented = false;
          onNavigate({
            preventDefault: () => {
              isDefaultPrevented = true;
            },
          });
          if (isDefaultPrevented) {
            return;
          }
        }
        const { dispatchNavigateAction } = __turbopack_context__.r(
          "[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)",
        );
        _react.default.startTransition(() => {
          dispatchNavigateAction(
            as || href,
            replace ? "replace" : "push",
            scroll ?? true,
            linkInstanceRef.current,
          );
        });
      }
    }
    function formatStringOrUrl(urlObjOrString) {
      if (typeof urlObjOrString === "string") {
        return urlObjOrString;
      }
      return (0, _formaturl.formatUrl)(urlObjOrString);
    }
    function LinkComponent(props) {
      const [linkStatus, setOptimisticLinkStatus] = (0, _react.useOptimistic)(
        _links.IDLE_LINK_STATUS,
      );
      let children;
      const linkInstanceRef = (0, _react.useRef)(null);
      const {
        href: hrefProp,
        as: asProp,
        children: childrenProp,
        prefetch: prefetchProp = null,
        passHref,
        replace,
        shallow,
        scroll,
        onClick,
        onMouseEnter: onMouseEnterProp,
        onTouchStart: onTouchStartProp,
        legacyBehavior = false,
        onNavigate,
        ref: forwardedRef,
        unstable_dynamicOnHover,
        ...restProps
      } = props;
      children = childrenProp;
      if (legacyBehavior && (typeof children === "string" || typeof children === "number")) {
        children = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
          children: children,
        });
      }
      const router = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);
      const prefetchEnabled = prefetchProp !== false;
      const fetchStrategy =
        prefetchProp !== false
          ? getFetchStrategyFromPrefetchProp(prefetchProp)
          : _types.FetchStrategy.PPR;
      if (("TURBOPACK compile-time truthy", 1)) {
        function createPropError(args) {
          return Object.defineProperty(
            new Error(
              `Failed prop type: The prop \`${args.key}\` expects a ${args.expected} in \`<Link>\`, but got \`${args.actual}\` instead.` +
                (typeof window !== "undefined"
                  ? "\nOpen your browser's console to view the Component stack trace."
                  : ""),
            ),
            "__NEXT_ERROR_CODE",
            {
              value: "E319",
              enumerable: false,
              configurable: true,
            },
          );
        }
        // TypeScript trick for type-guarding:
        const requiredPropsGuard = {
          href: true,
        };
        const requiredProps = Object.keys(requiredPropsGuard);
        requiredProps.forEach((key) => {
          if (key === "href") {
            if (
              props[key] == null ||
              (typeof props[key] !== "string" && typeof props[key] !== "object")
            ) {
              throw createPropError({
                key,
                expected: "`string` or `object`",
                actual: props[key] === null ? "null" : typeof props[key],
              });
            }
          } else {
            // TypeScript trick for type-guarding:
            const _ = key;
          }
        });
        // TypeScript trick for type-guarding:
        const optionalPropsGuard = {
          as: true,
          replace: true,
          scroll: true,
          shallow: true,
          passHref: true,
          prefetch: true,
          unstable_dynamicOnHover: true,
          onClick: true,
          onMouseEnter: true,
          onTouchStart: true,
          legacyBehavior: true,
          onNavigate: true,
        };
        const optionalProps = Object.keys(optionalPropsGuard);
        optionalProps.forEach((key) => {
          const valType = typeof props[key];
          if (key === "as") {
            if (props[key] && valType !== "string" && valType !== "object") {
              throw createPropError({
                key,
                expected: "`string` or `object`",
                actual: valType,
              });
            }
          } else if (
            key === "onClick" ||
            key === "onMouseEnter" ||
            key === "onTouchStart" ||
            key === "onNavigate"
          ) {
            if (props[key] && valType !== "function") {
              throw createPropError({
                key,
                expected: "`function`",
                actual: valType,
              });
            }
          } else if (
            key === "replace" ||
            key === "scroll" ||
            key === "shallow" ||
            key === "passHref" ||
            key === "legacyBehavior" ||
            key === "unstable_dynamicOnHover"
          ) {
            if (props[key] != null && valType !== "boolean") {
              throw createPropError({
                key,
                expected: "`boolean`",
                actual: valType,
              });
            }
          } else if (key === "prefetch") {
            if (props[key] != null && valType !== "boolean" && props[key] !== "auto") {
              throw createPropError({
                key,
                expected: '`boolean | "auto"`',
                actual: valType,
              });
            }
          } else {
            // TypeScript trick for type-guarding:
            const _ = key;
          }
        });
      }
      if (("TURBOPACK compile-time truthy", 1)) {
        if (props.locale) {
          (0, _warnonce.warnOnce)(
            "The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization",
          );
        }
        if (!asProp) {
          let href;
          if (typeof hrefProp === "string") {
            href = hrefProp;
          } else if (typeof hrefProp === "object" && typeof hrefProp.pathname === "string") {
            href = hrefProp.pathname;
          }
          if (href) {
            const hasDynamicSegment = href
              .split("/")
              .some((segment) => segment.startsWith("[") && segment.endsWith("]"));
            if (hasDynamicSegment) {
              throw Object.defineProperty(
                new Error(
                  `Dynamic href \`${href}\` found in <Link> while using the \`/app\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`,
                ),
                "__NEXT_ERROR_CODE",
                {
                  value: "E267",
                  enumerable: false,
                  configurable: true,
                },
              );
            }
          }
        }
      }
      const { href, as } = _react.default.useMemo(
        {
          "LinkComponent.useMemo": () => {
            const resolvedHref = formatStringOrUrl(hrefProp);
            return {
              href: resolvedHref,
              as: asProp ? formatStringOrUrl(asProp) : resolvedHref,
            };
          },
        }["LinkComponent.useMemo"],
        [hrefProp, asProp],
      );
      // This will return the first child, if multiple are provided it will throw an error
      let child;
      if (legacyBehavior) {
        if (children?.$$typeof === Symbol.for("react.lazy")) {
          throw Object.defineProperty(
            new Error(
              `\`<Link legacyBehavior>\` received a direct child that is either a Server Component, or JSX that was loaded with React.lazy(). This is not supported. Either remove legacyBehavior, or make the direct child a Client Component that renders the Link's \`<a>\` tag.`,
            ),
            "__NEXT_ERROR_CODE",
            {
              value: "E863",
              enumerable: false,
              configurable: true,
            },
          );
        }
        if (("TURBOPACK compile-time truthy", 1)) {
          if (onClick) {
            console.warn(
              `"onClick" was passed to <Link> with \`href\` of \`${hrefProp}\` but "legacyBehavior" was set. The legacy behavior requires onClick be set on the child of next/link`,
            );
          }
          if (onMouseEnterProp) {
            console.warn(
              `"onMouseEnter" was passed to <Link> with \`href\` of \`${hrefProp}\` but "legacyBehavior" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`,
            );
          }
          try {
            child = _react.default.Children.only(children);
          } catch (err) {
            if (!children) {
              throw Object.defineProperty(
                new Error(
                  `No children were passed to <Link> with \`href\` of \`${hrefProp}\` but one child is required https://nextjs.org/docs/messages/link-no-children`,
                ),
                "__NEXT_ERROR_CODE",
                {
                  value: "E320",
                  enumerable: false,
                  configurable: true,
                },
              );
            }
            throw Object.defineProperty(
              new Error(
                `Multiple children were passed to <Link> with \`href\` of \`${hrefProp}\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` +
                  (typeof window !== "undefined"
                    ? " \nOpen your browser's console to view the Component stack trace."
                    : ""),
              ),
              "__NEXT_ERROR_CODE",
              {
                value: "E266",
                enumerable: false,
                configurable: true,
              },
            );
          }
        } else //TURBOPACK unreachable
        ;
      } else {
        if (("TURBOPACK compile-time truthy", 1)) {
          if (children?.type === "a") {
            throw Object.defineProperty(
              new Error(
                "Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor",
              ),
              "__NEXT_ERROR_CODE",
              {
                value: "E209",
                enumerable: false,
                configurable: true,
              },
            );
          }
        }
      }
      const childRef = legacyBehavior
        ? child && typeof child === "object" && child.ref
        : forwardedRef;
      // Use a callback ref to attach an IntersectionObserver to the anchor tag on
      // mount. In the future we will also use this to keep track of all the
      // currently mounted <Link> instances, e.g. so we can re-prefetch them after
      // a revalidation or refresh.
      const observeLinkVisibilityOnMount = _react.default.useCallback(
        {
          "LinkComponent.useCallback[observeLinkVisibilityOnMount]": (element) => {
            if (router !== null) {
              linkInstanceRef.current = (0, _links.mountLinkInstance)(
                element,
                href,
                router,
                fetchStrategy,
                prefetchEnabled,
                setOptimisticLinkStatus,
              );
            }
            return {
              "LinkComponent.useCallback[observeLinkVisibilityOnMount]": () => {
                if (linkInstanceRef.current) {
                  (0, _links.unmountLinkForCurrentNavigation)(linkInstanceRef.current);
                  linkInstanceRef.current = null;
                }
                (0, _links.unmountPrefetchableInstance)(element);
              },
            }["LinkComponent.useCallback[observeLinkVisibilityOnMount]"];
          },
        }["LinkComponent.useCallback[observeLinkVisibilityOnMount]"],
        [prefetchEnabled, href, router, fetchStrategy, setOptimisticLinkStatus],
      );
      const mergedRef = (0, _usemergedref.useMergedRef)(observeLinkVisibilityOnMount, childRef);
      const childProps = {
        ref: mergedRef,
        onClick(e) {
          if (("TURBOPACK compile-time truthy", 1)) {
            if (!e) {
              throw Object.defineProperty(
                new Error(
                  `Component rendered inside next/link has to pass click event to "onClick" prop.`,
                ),
                "__NEXT_ERROR_CODE",
                {
                  value: "E312",
                  enumerable: false,
                  configurable: true,
                },
              );
            }
          }
          if (!legacyBehavior && typeof onClick === "function") {
            onClick(e);
          }
          if (legacyBehavior && child.props && typeof child.props.onClick === "function") {
            child.props.onClick(e);
          }
          if (!router) {
            return;
          }
          if (e.defaultPrevented) {
            return;
          }
          linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate);
        },
        onMouseEnter(e) {
          if (!legacyBehavior && typeof onMouseEnterProp === "function") {
            onMouseEnterProp(e);
          }
          if (legacyBehavior && child.props && typeof child.props.onMouseEnter === "function") {
            child.props.onMouseEnter(e);
          }
          if (!router) {
            return;
          }
          if (("TURBOPACK compile-time truthy", 1)) {
            return;
          }
          //TURBOPACK unreachable
          const upgradeToDynamicPrefetch = undefined;
        },
        onTouchStart: ("TURBOPACK compile-time falsy", 0)
          ? "TURBOPACK unreachable"
          : function onTouchStart(e) {
              if (!legacyBehavior && typeof onTouchStartProp === "function") {
                onTouchStartProp(e);
              }
              if (legacyBehavior && child.props && typeof child.props.onTouchStart === "function") {
                child.props.onTouchStart(e);
              }
              if (!router) {
                return;
              }
              if (!prefetchEnabled) {
                return;
              }
              const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true;
              (0, _links.onNavigationIntent)(e.currentTarget, upgradeToDynamicPrefetch);
            },
      };
      // If the url is absolute, we can bypass the logic to prepend the basePath.
      if ((0, _utils.isAbsoluteUrl)(as)) {
        childProps.href = as;
      } else if (!legacyBehavior || passHref || (child.type === "a" && !("href" in child.props))) {
        childProps.href = (0, _addbasepath.addBasePath)(as);
      }
      let link;
      if (legacyBehavior) {
        if (("TURBOPACK compile-time truthy", 1)) {
          (0, _erroronce.errorOnce)(
            "`legacyBehavior` is deprecated and will be removed in a future " +
              "release. A codemod is available to upgrade your components:\n\n" +
              "npx @next/codemod@latest new-link .\n\n" +
              "Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components",
          );
        }
        link = /*#__PURE__*/ _react.default.cloneElement(child, childProps);
      } else {
        link = /*#__PURE__*/ (0, _jsxruntime.jsx)("a", {
          ...restProps,
          ...childProps,
          children: children,
        });
      }
      return /*#__PURE__*/ (0, _jsxruntime.jsx)(LinkStatusContext.Provider, {
        value: linkStatus,
        children: link,
      });
    }
    const LinkStatusContext = /*#__PURE__*/ (0, _react.createContext)(_links.IDLE_LINK_STATUS);
    const useLinkStatus = () => {
      return (0, _react.useContext)(LinkStatusContext);
    };
    function getFetchStrategyFromPrefetchProp(prefetchProp) {
      if (("TURBOPACK compile-time falsy", 0)) //TURBOPACK unreachable
      ;
      else {
        return prefetchProp === null || prefetchProp === "auto"
          ? _types.FetchStrategy.PPR // (although invalid values should've been filtered out by prop validation in dev)
          : _types.FetchStrategy.Full;
      }
    }
    if (
      (typeof exports.default === "function" ||
        (typeof exports.default === "object" && exports.default !== null)) &&
      typeof exports.default.__esModule === "undefined"
    ) {
      Object.defineProperty(exports.default, "__esModule", {
        value: true,
      });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    } //# sourceMappingURL=link.js.map
  },
  "[project]/node_modules/next/navigation.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    module.exports = __turbopack_context__.r(
      "[project]/node_modules/next/dist/client/components/navigation.js [app-client] (ecmascript)",
    );
  },
  "[project]/node_modules/@better-auth/core/dist/env/env-impl.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "ENV",
      () => ENV,
      "env",
      () => env,
      "getBooleanEnvVar",
      () => getBooleanEnvVar,
      "getEnvVar",
      () => getEnvVar,
      "isDevelopment",
      () => isDevelopment,
      "isProduction",
      () => isProduction,
      "isTest",
      () => isTest,
      "nodeENV",
      () => nodeENV,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    //#region src/env/env-impl.ts
    const _envShim = Object.create(null);
    const _getEnv = (useShim) =>
      globalThis.process?.env ||
      globalThis.Deno?.env.toObject() ||
      globalThis.__env__ ||
      (useShim ? _envShim : globalThis);
    const env = new Proxy(_envShim, {
      get(_, prop) {
        return _getEnv()[prop] ?? _envShim[prop];
      },
      has(_, prop) {
        return prop in _getEnv() || prop in _envShim;
      },
      set(_, prop, value) {
        const env$1 = _getEnv(true);
        env$1[prop] = value;
        return true;
      },
      deleteProperty(_, prop) {
        if (!prop) return false;
        const env$1 = _getEnv(true);
        delete env$1[prop];
        return true;
      },
      ownKeys() {
        const env$1 = _getEnv(true);
        return Object.keys(env$1);
      },
    });
    function toBoolean(val) {
      return val ? val !== "false" : false;
    }
    const nodeENV =
      (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ] !== "undefined" &&
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].env &&
        ("TURBOPACK compile-time value", "development")) ||
      "";
    /** Detect if `NODE_ENV` environment variable is `production` */ const isProduction =
      nodeENV === "production";
    /** Detect if `NODE_ENV` environment variable is `dev` or `development` */ const isDevelopment =
      () => nodeENV === "dev" || nodeENV === "development";
    /** Detect if `NODE_ENV` environment variable is `test` */ const isTest = () =>
      nodeENV === "test" || toBoolean(env.TEST);
    /**
     * Get environment variable with fallback
     */ function getEnvVar(key, fallback) {
      if (
        typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ] !== "undefined" &&
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].env
      )
        return (
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].env[key] ?? fallback
        );
      if (typeof Deno !== "undefined") return Deno.env.get(key) ?? fallback;
      if (typeof Bun !== "undefined") return Bun.env[key] ?? fallback;
      return fallback;
    }
    /**
     * Get boolean environment variable
     */ function getBooleanEnvVar(key, fallback = true) {
      const value = getEnvVar(key);
      if (!value) return fallback;
      return value !== "0" && value.toLowerCase() !== "false" && value !== "";
    }
    /**
     * Common environment variables used in Better Auth
     */ const ENV = Object.freeze({
      get BETTER_AUTH_SECRET() {
        return getEnvVar("BETTER_AUTH_SECRET");
      },
      get AUTH_SECRET() {
        return getEnvVar("AUTH_SECRET");
      },
      get BETTER_AUTH_TELEMETRY() {
        return getEnvVar("BETTER_AUTH_TELEMETRY");
      },
      get BETTER_AUTH_TELEMETRY_ID() {
        return getEnvVar("BETTER_AUTH_TELEMETRY_ID");
      },
      get NODE_ENV() {
        return getEnvVar("NODE_ENV", "development");
      },
      get PACKAGE_VERSION() {
        return getEnvVar("PACKAGE_VERSION", "0.0.0");
      },
      get BETTER_AUTH_TELEMETRY_ENDPOINT() {
        return getEnvVar("BETTER_AUTH_TELEMETRY_ENDPOINT", "");
      },
    });
  },
  //# sourceMappingURL=env-impl.mjs.map
  "[project]/node_modules/@better-auth/core/dist/env/color-depth.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["getColorDepth", () => getColorDepth]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/env/env-impl.mjs [app-client] (ecmascript)",
      );
    //#region src/env/color-depth.ts
    const COLORS_2 = 1;
    const COLORS_16 = 4;
    const COLORS_256 = 8;
    const COLORS_16m = 24;
    const TERM_ENVS = {
      eterm: COLORS_16,
      cons25: COLORS_16,
      console: COLORS_16,
      cygwin: COLORS_16,
      dtterm: COLORS_16,
      gnome: COLORS_16,
      hurd: COLORS_16,
      jfbterm: COLORS_16,
      konsole: COLORS_16,
      kterm: COLORS_16,
      mlterm: COLORS_16,
      mosh: COLORS_16m,
      putty: COLORS_16,
      st: COLORS_16,
      "rxvt-unicode-24bit": COLORS_16m,
      terminator: COLORS_16m,
      "xterm-kitty": COLORS_16m,
    };
    const CI_ENVS_MAP = new Map(
      Object.entries({
        APPVEYOR: COLORS_256,
        BUILDKITE: COLORS_256,
        CIRCLECI: COLORS_16m,
        DRONE: COLORS_256,
        GITEA_ACTIONS: COLORS_16m,
        GITHUB_ACTIONS: COLORS_16m,
        GITLAB_CI: COLORS_256,
        TRAVIS: COLORS_256,
      }),
    );
    const TERM_ENVS_REG_EXP = [
      /ansi/,
      /color/,
      /linux/,
      /direct/,
      /^con[0-9]*x[0-9]/,
      /^rxvt/,
      /^screen/,
      /^xterm/,
      /^vt100/,
      /^vt220/,
    ];
    function getColorDepth() {
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getEnvVar"
        ])("FORCE_COLOR") !== void 0
      )
        switch (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getEnvVar"
          ])("FORCE_COLOR")
        ) {
          case "":
          case "1":
          case "true":
            return COLORS_16;
          case "2":
            return COLORS_256;
          case "3":
            return COLORS_16m;
          default:
            return COLORS_2;
        }
      if (
        ((0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getEnvVar"
        ])("NODE_DISABLE_COLORS") !== void 0 &&
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getEnvVar"
          ])("NODE_DISABLE_COLORS") !== "") ||
        ((0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getEnvVar"
        ])("NO_COLOR") !== void 0 &&
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getEnvVar"
          ])("NO_COLOR") !== "") ||
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getEnvVar"
        ])("TERM") === "dumb"
      )
        return COLORS_2;
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getEnvVar"
        ])("TMUX")
      )
        return COLORS_16m;
      if (
        "TF_BUILD" in
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "env"
          ] &&
        "AGENT_NAME" in
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "env"
          ]
      )
        return COLORS_16;
      if (
        "CI" in
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "env"
        ]
      ) {
        for (const { 0: envName, 1: colors } of CI_ENVS_MAP)
          if (
            envName in
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "env"
            ]
          )
            return colors;
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getEnvVar"
          ])("CI_NAME") === "codeship"
        )
          return COLORS_256;
        return COLORS_2;
      }
      if (
        "TEAMCITY_VERSION" in
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "env"
        ]
      )
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.exec(
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getEnvVar"
          ])("TEAMCITY_VERSION"),
        ) !== null
          ? COLORS_16
          : COLORS_2;
      switch (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getEnvVar"
        ])("TERM_PROGRAM")
      ) {
        case "iTerm.app":
          if (
            !(0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getEnvVar"
            ])("TERM_PROGRAM_VERSION") ||
            /^[0-2]\./.exec(
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "getEnvVar"
              ])("TERM_PROGRAM_VERSION"),
            ) !== null
          )
            return COLORS_256;
          return COLORS_16m;
        case "HyperTerm":
        case "MacTerm":
          return COLORS_16m;
        case "Apple_Terminal":
          return COLORS_256;
      }
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getEnvVar"
        ])("COLORTERM") === "truecolor" ||
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getEnvVar"
        ])("COLORTERM") === "24bit"
      )
        return COLORS_16m;
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getEnvVar"
        ])("TERM")
      ) {
        if (
          /truecolor/.exec(
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getEnvVar"
            ])("TERM"),
          ) !== null
        )
          return COLORS_16m;
        if (
          /^xterm-256/.exec(
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getEnvVar"
            ])("TERM"),
          ) !== null
        )
          return COLORS_256;
        const termEnv = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getEnvVar"
        ])("TERM").toLowerCase();
        if (TERM_ENVS[termEnv]) return TERM_ENVS[termEnv];
        if (TERM_ENVS_REG_EXP.some((term) => term.exec(termEnv) !== null)) return COLORS_16;
      }
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getEnvVar"
        ])("COLORTERM")
      )
        return COLORS_16;
      return COLORS_2;
    }
  },
  //# sourceMappingURL=color-depth.mjs.map
  "[project]/node_modules/@better-auth/core/dist/env/logger.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "TTY_COLORS",
      () => TTY_COLORS,
      "createLogger",
      () => createLogger,
      "levels",
      () => levels,
      "logger",
      () => logger,
      "shouldPublishLog",
      () => shouldPublishLog,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$color$2d$depth$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/env/color-depth.mjs [app-client] (ecmascript)",
      );
    //#region src/env/logger.ts
    const TTY_COLORS = {
      reset: "\x1B[0m",
      bright: "\x1B[1m",
      dim: "\x1B[2m",
      undim: "\x1B[22m",
      underscore: "\x1B[4m",
      blink: "\x1B[5m",
      reverse: "\x1B[7m",
      hidden: "\x1B[8m",
      fg: {
        black: "\x1B[30m",
        red: "\x1B[31m",
        green: "\x1B[32m",
        yellow: "\x1B[33m",
        blue: "\x1B[34m",
        magenta: "\x1B[35m",
        cyan: "\x1B[36m",
        white: "\x1B[37m",
      },
      bg: {
        black: "\x1B[40m",
        red: "\x1B[41m",
        green: "\x1B[42m",
        yellow: "\x1B[43m",
        blue: "\x1B[44m",
        magenta: "\x1B[45m",
        cyan: "\x1B[46m",
        white: "\x1B[47m",
      },
    };
    const levels = ["debug", "info", "success", "warn", "error"];
    function shouldPublishLog(currentLogLevel, logLevel) {
      return levels.indexOf(logLevel) >= levels.indexOf(currentLogLevel);
    }
    const levelColors = {
      info: TTY_COLORS.fg.blue,
      success: TTY_COLORS.fg.green,
      warn: TTY_COLORS.fg.yellow,
      error: TTY_COLORS.fg.red,
      debug: TTY_COLORS.fg.magenta,
    };
    const formatMessage = (level, message, colorsEnabled) => {
      const timestamp = /* @__PURE__ */ new Date().toISOString();
      if (colorsEnabled)
        return `${TTY_COLORS.dim}${timestamp}${TTY_COLORS.reset} ${levelColors[level]}${level.toUpperCase()}${TTY_COLORS.reset} ${TTY_COLORS.bright}[Better Auth]:${TTY_COLORS.reset} ${message}`;
      return `${timestamp} ${level.toUpperCase()} [Better Auth]: ${message}`;
    };
    const createLogger = (options) => {
      const enabled = options?.disabled !== true;
      const logLevel = options?.level ?? "warn";
      const colorsEnabled =
        options?.disableColors !== void 0
          ? !options.disableColors
          : (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$color$2d$depth$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getColorDepth"
            ])() !== 1;
      const LogFunc = (level, message, args = []) => {
        if (!enabled || !shouldPublishLog(logLevel, level)) return;
        const formattedMessage = formatMessage(level, message, colorsEnabled);
        if (!options || typeof options.log !== "function") {
          if (level === "error") console.error(formattedMessage, ...args);
          else if (level === "warn") console.warn(formattedMessage, ...args);
          else console.log(formattedMessage, ...args);
          return;
        }
        options.log(level === "success" ? "info" : level, message, ...args);
      };
      return {
        ...Object.fromEntries(
          levels.map((level) => [level, (...[message, ...args]) => LogFunc(level, message, args)]),
        ),
        get level() {
          return logLevel;
        },
      };
    };
    const logger = createLogger();
  },
  //# sourceMappingURL=logger.mjs.map
  "[project]/node_modules/@better-auth/core/dist/env/index.mjs [app-client] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/env/env-impl.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$color$2d$depth$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/env/color-depth.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$logger$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/env/logger.mjs [app-client] (ecmascript)",
      );
  },
  "[project]/node_modules/@better-auth/core/dist/utils/error-codes.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["defineErrorCodes", () => defineErrorCodes]);
    //#region src/utils/error-codes.ts
    function defineErrorCodes(codes) {
      return codes;
    }
  },
  //# sourceMappingURL=error-codes.mjs.map
  "[project]/node_modules/@better-auth/core/dist/utils/db.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["filterOutputFields", () => filterOutputFields]);
    //#region src/utils/db.ts
    /**
     * Filters output data by removing fields with the `returned: false` attribute.
     * This ensures sensitive fields are not exposed in API responses.
     */ function filterOutputFields(data, additionalFields) {
      if (!data || !additionalFields) return data;
      const returnFiltered = Object.entries(additionalFields)
        .filter(([, { returned }]) => returned === false)
        .map(([key]) => key);
      return Object.entries(structuredClone(data))
        .filter(([key]) => !returnFiltered.includes(key))
        .reduce(
          (acc, [key, value]) => ({
            ...acc,
            [key]: value,
          }),
          {},
        );
    }
  },
  //# sourceMappingURL=db.mjs.map
  "[project]/node_modules/@better-auth/core/dist/utils/deprecate.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["deprecate", () => deprecate]);
    //#region src/utils/deprecate.ts
    /**
     * Wraps a function to log a deprecation warning at once.
     */ function deprecate(fn, message, logger) {
      let warned = false;
      return function (...args) {
        if (!warned) {
          (logger?.warn ?? console.warn)(`[Deprecation] ${message}`);
          warned = true;
        }
        return fn.apply(this, args);
      };
    }
  },
  //# sourceMappingURL=deprecate.mjs.map
  "[project]/node_modules/@better-auth/core/dist/utils/id.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["generateId", () => generateId]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$random$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/utils/dist/random.mjs [app-client] (ecmascript)",
      );
    //#region src/utils/id.ts
    const generateId = (size) => {
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$utils$2f$dist$2f$random$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "createRandomStringGenerator"
      ])(
        "a-z",
        "A-Z",
        "0-9",
      )(size || 32);
    };
  },
  //# sourceMappingURL=id.mjs.map
  "[project]/node_modules/@better-auth/core/dist/utils/ip.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "createRateLimitKey",
      () => createRateLimitKey,
      "isValidIP",
      () => isValidIP,
      "normalizeIP",
      () => normalizeIP,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/zod/v4/classic/schemas.js [app-client] (ecmascript)",
      );
    //#region src/utils/ip.ts
    /**
     * Checks if an IP is valid IPv4 or IPv6
     */ function isValidIP(ip) {
      return (
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "ipv4"
        ]().safeParse(ip).success ||
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "ipv6"
        ]().safeParse(ip).success
      );
    }
    /**
     * Checks if an IP is IPv6
     */ function isIPv6(ip) {
      return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "ipv6"
      ]().safeParse(ip).success;
    }
    /**
     * Converts IPv4-mapped IPv6 address to IPv4
     * e.g., "::ffff:192.0.2.1" -> "192.0.2.1"
     */ function extractIPv4FromMapped(ipv6) {
      const lower = ipv6.toLowerCase();
      if (lower.startsWith("::ffff:")) {
        const ipv4Part = lower.substring(7);
        if (
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "ipv4"
          ]().safeParse(ipv4Part).success
        )
          return ipv4Part;
      }
      const parts = ipv6.split(":");
      if (parts.length === 7 && parts[5]?.toLowerCase() === "ffff") {
        const ipv4Part = parts[6];
        if (
          ipv4Part &&
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "ipv4"
          ]().safeParse(ipv4Part).success
        )
          return ipv4Part;
      }
      if (lower.includes("::ffff:") || lower.includes(":ffff:")) {
        const groups = expandIPv6(ipv6);
        if (
          groups.length === 8 &&
          groups[0] === "0000" &&
          groups[1] === "0000" &&
          groups[2] === "0000" &&
          groups[3] === "0000" &&
          groups[4] === "0000" &&
          groups[5] === "ffff" &&
          groups[6] &&
          groups[7]
        )
          return `${Number.parseInt(groups[6].substring(0, 2), 16)}.${Number.parseInt(groups[6].substring(2, 4), 16)}.${Number.parseInt(groups[7].substring(0, 2), 16)}.${Number.parseInt(groups[7].substring(2, 4), 16)}`;
      }
      return null;
    }
    /**
     * Expands a compressed IPv6 address to full form
     * e.g., "2001:db8::1" -> ["2001", "0db8", "0000", "0000", "0000", "0000", "0000", "0001"]
     */ function expandIPv6(ipv6) {
      if (ipv6.includes("::")) {
        const sides = ipv6.split("::");
        const left = sides[0] ? sides[0].split(":") : [];
        const right = sides[1] ? sides[1].split(":") : [];
        const missingGroups = 8 - left.length - right.length;
        const zeros = Array(missingGroups).fill("0000");
        const paddedLeft = left.map((g) => g.padStart(4, "0"));
        const paddedRight = right.map((g) => g.padStart(4, "0"));
        return [...paddedLeft, ...zeros, ...paddedRight];
      }
      return ipv6.split(":").map((g) => g.padStart(4, "0"));
    }
    /**
     * Normalizes an IPv6 address to canonical form
     * e.g., "2001:DB8::1" -> "2001:0db8:0000:0000:0000:0000:0000:0001"
     */ function normalizeIPv6(ipv6, subnetPrefix) {
      const groups = expandIPv6(ipv6);
      if (subnetPrefix && subnetPrefix < 128) {
        let bitsRemaining = subnetPrefix;
        return groups
          .map((group) => {
            if (bitsRemaining <= 0) return "0000";
            if (bitsRemaining >= 16) {
              bitsRemaining -= 16;
              return group;
            }
            const masked = Number.parseInt(group, 16) & ((65535 << (16 - bitsRemaining)) & 65535);
            bitsRemaining = 0;
            return masked.toString(16).padStart(4, "0");
          })
          .join(":")
          .toLowerCase();
      }
      return groups.join(":").toLowerCase();
    }
    /**
     * Normalizes an IP address (IPv4 or IPv6) for consistent rate limiting.
     *
     * @param ip - The IP address to normalize
     * @param options - Normalization options
     * @returns Normalized IP address
     *
     * @example
     * normalizeIP("2001:DB8::1")
     * // -> "2001:0db8:0000:0000:0000:0000:0000:0000"
     *
     * @example
     * normalizeIP("::ffff:192.0.2.1")
     * // -> "192.0.2.1" (converted to IPv4)
     *
     * @example
     * normalizeIP("2001:db8::1", { ipv6Subnet: 64 })
     * // -> "2001:0db8:0000:0000:0000:0000:0000:0000" (subnet /64)
     */ function normalizeIP(ip, options = {}) {
      if (
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "ipv4"
        ]().safeParse(ip).success
      )
        return ip.toLowerCase();
      if (!isIPv6(ip)) return ip.toLowerCase();
      const ipv4 = extractIPv4FromMapped(ip);
      if (ipv4) return ipv4.toLowerCase();
      return normalizeIPv6(ip, options.ipv6Subnet || 64);
    }
    /**
     * Creates a rate limit key from IP and path
     * Uses a separator to prevent collision attacks
     *
     * @param ip - The IP address (should be normalized)
     * @param path - The request path
     * @returns Rate limit key
     */ function createRateLimitKey(ip, path) {
      return `${ip}|${path}`;
    }
  },
  //# sourceMappingURL=ip.mjs.map
  "[project]/node_modules/@better-auth/core/dist/utils/json.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["safeJSONParse", () => safeJSONParse]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$logger$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/env/logger.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/env/index.mjs [app-client] (ecmascript) <locals>",
      );
    //#region src/utils/json.ts
    function safeJSONParse(data) {
      function reviver(_, value) {
        if (typeof value === "string") {
          if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z$/.test(value)) {
            const date = new Date(value);
            if (!isNaN(date.getTime())) return date;
          }
        }
        return value;
      }
      try {
        if (typeof data !== "string") return data;
        return JSON.parse(data, reviver);
      } catch (e) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$logger$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "logger"
        ].error("Error parsing JSON", {
          error: e,
        });
        return null;
      }
    }
  },
  //# sourceMappingURL=json.mjs.map
  "[project]/node_modules/@better-auth/core/dist/utils/string.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["capitalizeFirstLetter", () => capitalizeFirstLetter]);
    //#region src/utils/string.ts
    function capitalizeFirstLetter(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
  },
  //# sourceMappingURL=string.mjs.map
  "[project]/node_modules/@better-auth/core/dist/utils/url.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["normalizePathname", () => normalizePathname]);
    //#region src/utils/url.ts
    /**
     * Normalizes a request pathname by removing the basePath prefix and trailing slashes.
     * This is useful for matching paths against configured path lists.
     *
     * @param requestUrl - The full request URL
     * @param basePath - The base path of the auth API (e.g., "/api/auth")
     * @returns The normalized path without basePath prefix or trailing slashes,
     *          or "/" if URL parsing fails
     *
     * @example
     * normalizePathname("http://localhost:3000/api/auth/sso/saml2/callback/provider1", "/api/auth")
     * // Returns: "/sso/saml2/callback/provider1"
     *
     * normalizePathname("http://localhost:3000/sso/saml2/callback/provider1/", "/")
     * // Returns: "/sso/saml2/callback/provider1"
     */ function normalizePathname(requestUrl, basePath) {
      let pathname;
      try {
        pathname = new URL(requestUrl).pathname.replace(/\/+$/, "") || "/";
      } catch {
        return "/";
      }
      if (basePath === "/" || basePath === "") return pathname;
      if (pathname === basePath) return "/";
      if (pathname.startsWith(basePath + "/"))
        return pathname.slice(basePath.length).replace(/\/+$/, "") || "/";
      return pathname;
    }
  },
  //# sourceMappingURL=url.mjs.map
  "[project]/node_modules/@better-auth/core/dist/utils/index.mjs [app-client] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$db$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/utils/db.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$deprecate$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/utils/deprecate.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$error$2d$codes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/utils/error-codes.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$id$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/utils/id.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$ip$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/utils/ip.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$json$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/utils/json.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$string$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/utils/string.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$url$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/utils/url.mjs [app-client] (ecmascript)",
      );
  },
  "[project]/node_modules/@better-auth/core/dist/error/codes.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["BASE_ERROR_CODES", () => BASE_ERROR_CODES]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$error$2d$codes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/utils/error-codes.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/utils/index.mjs [app-client] (ecmascript) <locals>",
      );
    //#region src/error/codes.ts
    const BASE_ERROR_CODES = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$error$2d$codes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "defineErrorCodes"
    ])({
      USER_NOT_FOUND: "User not found",
      FAILED_TO_CREATE_USER: "Failed to create user",
      FAILED_TO_CREATE_SESSION: "Failed to create session",
      FAILED_TO_UPDATE_USER: "Failed to update user",
      FAILED_TO_GET_SESSION: "Failed to get session",
      INVALID_PASSWORD: "Invalid password",
      INVALID_EMAIL: "Invalid email",
      INVALID_EMAIL_OR_PASSWORD: "Invalid email or password",
      SOCIAL_ACCOUNT_ALREADY_LINKED: "Social account already linked",
      PROVIDER_NOT_FOUND: "Provider not found",
      INVALID_TOKEN: "Invalid token",
      ID_TOKEN_NOT_SUPPORTED: "id_token not supported",
      FAILED_TO_GET_USER_INFO: "Failed to get user info",
      USER_EMAIL_NOT_FOUND: "User email not found",
      EMAIL_NOT_VERIFIED: "Email not verified",
      PASSWORD_TOO_SHORT: "Password too short",
      PASSWORD_TOO_LONG: "Password too long",
      USER_ALREADY_EXISTS: "User already exists.",
      USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL: "User already exists. Use another email.",
      EMAIL_CAN_NOT_BE_UPDATED: "Email can not be updated",
      CREDENTIAL_ACCOUNT_NOT_FOUND: "Credential account not found",
      SESSION_EXPIRED: "Session expired. Re-authenticate to perform this action.",
      FAILED_TO_UNLINK_LAST_ACCOUNT: "You can't unlink your last account",
      ACCOUNT_NOT_FOUND: "Account not found",
      USER_ALREADY_HAS_PASSWORD: "User already has a password. Provide that to delete the account.",
      CROSS_SITE_NAVIGATION_LOGIN_BLOCKED:
        "Cross-site navigation login blocked. This request appears to be a CSRF attack.",
      VERIFICATION_EMAIL_NOT_ENABLED: "Verification email isn't enabled",
      EMAIL_ALREADY_VERIFIED: "Email is already verified",
      EMAIL_MISMATCH: "Email mismatch",
      SESSION_NOT_FRESH: "Session is not fresh",
      LINKED_ACCOUNT_ALREADY_EXISTS: "Linked account already exists",
      INVALID_ORIGIN: "Invalid origin",
      INVALID_CALLBACK_URL: "Invalid callbackURL",
      INVALID_REDIRECT_URL: "Invalid redirectURL",
      INVALID_ERROR_CALLBACK_URL: "Invalid errorCallbackURL",
      INVALID_NEW_USER_CALLBACK_URL: "Invalid newUserCallbackURL",
      MISSING_OR_NULL_ORIGIN: "Missing or null Origin",
      CALLBACK_URL_REQUIRED: "callbackURL is required",
      FAILED_TO_CREATE_VERIFICATION: "Unable to create verification",
      FIELD_NOT_ALLOWED: "Field not allowed to be set",
      ASYNC_VALIDATION_NOT_SUPPORTED: "Async validation is not supported",
      VALIDATION_ERROR: "Validation Error",
      MISSING_FIELD: "Field is required",
    });
  },
  //# sourceMappingURL=codes.mjs.map
  "[project]/node_modules/@better-auth/core/dist/error/index.mjs [app-client] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["BetterAuthError", () => BetterAuthError]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$error$2f$codes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/error/codes.mjs [app-client] (ecmascript)",
      );
    //#region src/error/index.ts
    var BetterAuthError = class extends Error {
      constructor(message, options) {
        super(message, options);
        this.name = "BetterAuthError";
        this.message = message;
        this.stack = "";
      }
    };
  },
  //# sourceMappingURL=index.mjs.map
  "[project]/node_modules/@better-auth/utils/dist/random.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["createRandomStringGenerator", () => createRandomStringGenerator]);
    function expandAlphabet(alphabet) {
      switch (alphabet) {
        case "a-z":
          return "abcdefghijklmnopqrstuvwxyz";
        case "A-Z":
          return "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        case "0-9":
          return "0123456789";
        case "-_":
          return "-_";
        default:
          throw new Error(`Unsupported alphabet: ${alphabet}`);
      }
    }
    function createRandomStringGenerator(...baseAlphabets) {
      const baseCharSet = baseAlphabets.map(expandAlphabet).join("");
      if (baseCharSet.length === 0) {
        throw new Error("No valid characters provided for random string generation.");
      }
      const baseCharSetLength = baseCharSet.length;
      return (length, ...alphabets) => {
        if (length <= 0) {
          throw new Error("Length must be a positive integer.");
        }
        let charSet = baseCharSet;
        let charSetLength = baseCharSetLength;
        if (alphabets.length > 0) {
          charSet = alphabets.map(expandAlphabet).join("");
          charSetLength = charSet.length;
        }
        const maxValid = Math.floor(256 / charSetLength) * charSetLength;
        const buf = new Uint8Array(length * 2);
        const bufLength = buf.length;
        let result = "";
        let bufIndex = bufLength;
        let rand;
        while (result.length < length) {
          if (bufIndex >= bufLength) {
            crypto.getRandomValues(buf);
            bufIndex = 0;
          }
          rand = buf[bufIndex++];
          if (rand < maxValid) {
            result += charSet[rand % charSetLength];
          }
        }
        return result;
      };
    }
  },
  "[project]/node_modules/better-auth/dist/utils/url.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "getBaseURL",
      () => getBaseURL,
      "getHost",
      () => getHost,
      "getOrigin",
      () => getOrigin,
      "getProtocol",
      () => getProtocol,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/env/index.mjs [app-client] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/env/env-impl.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$error$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/error/index.mjs [app-client] (ecmascript) <locals>",
      );
    //#region src/utils/url.ts
    function checkHasPath(url) {
      try {
        return (new URL(url).pathname.replace(/\/+$/, "") || "/") !== "/";
      } catch {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$error$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "BetterAuthError"
        ](`Invalid base URL: ${url}. Please provide a valid base URL.`);
      }
    }
    function assertHasProtocol(url) {
      try {
        const parsedUrl = new URL(url);
        if (parsedUrl.protocol !== "http:" && parsedUrl.protocol !== "https:")
          throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$error$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "BetterAuthError"
          ](`Invalid base URL: ${url}. URL must include 'http://' or 'https://'`);
      } catch (error) {
        if (
          error instanceof
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$error$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "BetterAuthError"
          ]
        )
          throw error;
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$error$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "BetterAuthError"
        ](`Invalid base URL: ${url}. Please provide a valid base URL.`, {
          cause: error,
        });
      }
    }
    function withPath(url, path = "/api/auth") {
      assertHasProtocol(url);
      if (checkHasPath(url)) return url;
      const trimmedUrl = url.replace(/\/+$/, "");
      if (!path || path === "/") return trimmedUrl;
      path = path.startsWith("/") ? path : `/${path}`;
      return `${trimmedUrl}${path}`;
    }
    function validateProxyHeader(header, type) {
      if (!header || header.trim() === "") return false;
      if (type === "proto") return header === "http" || header === "https";
      if (type === "host") {
        if (
          [/\.\./, /\0/, /[\s]/, /^[.]/, /[<>'"]/, /javascript:/i, /file:/i, /data:/i].some(
            (pattern) => pattern.test(header),
          )
        )
          return false;
        return (
          /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(:[0-9]{1,5})?$/.test(
            header,
          ) ||
          /^(\d{1,3}\.){3}\d{1,3}(:[0-9]{1,5})?$/.test(header) ||
          /^\[[0-9a-fA-F:]+\](:[0-9]{1,5})?$/.test(header) ||
          /^localhost(:[0-9]{1,5})?$/i.test(header)
        );
      }
      return false;
    }
    function getBaseURL(url, path, request, loadEnv, trustedProxyHeaders) {
      if (url) return withPath(url, path);
      if (loadEnv !== false) {
        const fromEnv =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "env"
          ].BETTER_AUTH_URL ||
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "env"
          ].NEXT_PUBLIC_BETTER_AUTH_URL ||
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "env"
          ].PUBLIC_BETTER_AUTH_URL ||
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "env"
          ].NUXT_PUBLIC_BETTER_AUTH_URL ||
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "env"
          ].NUXT_PUBLIC_AUTH_URL ||
          (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "env"
          ].BASE_URL !== "/"
            ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$env$2f$env$2d$impl$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "env"
              ].BASE_URL
            : void 0);
        if (fromEnv) return withPath(fromEnv, path);
      }
      const fromRequest = request?.headers.get("x-forwarded-host");
      const fromRequestProto = request?.headers.get("x-forwarded-proto");
      if (fromRequest && fromRequestProto && trustedProxyHeaders) {
        if (
          validateProxyHeader(fromRequestProto, "proto") &&
          validateProxyHeader(fromRequest, "host")
        )
          try {
            return withPath(`${fromRequestProto}://${fromRequest}`, path);
          } catch (_error) {}
      }
      if (request) {
        const url$1 = getOrigin(request.url);
        if (!url$1)
          throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$error$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "BetterAuthError"
          ]("Could not get origin from request. Please provide a valid base URL.");
        return withPath(url$1, path);
      }
      if (typeof window !== "undefined" && window.location)
        return withPath(window.location.origin, path);
    }
    function getOrigin(url) {
      try {
        const parsedUrl = new URL(url);
        return parsedUrl.origin === "null" ? null : parsedUrl.origin;
      } catch {
        return null;
      }
    }
    function getProtocol(url) {
      try {
        return new URL(url).protocol;
      } catch {
        return null;
      }
    }
    function getHost(url) {
      try {
        return new URL(url).host;
      } catch {
        return null;
      }
    }
  },
  //# sourceMappingURL=url.mjs.map
  "[project]/node_modules/better-auth/dist/client/fetch-plugins.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["redirectPlugin", () => redirectPlugin]);
    //#region src/client/fetch-plugins.ts
    const redirectPlugin = {
      id: "redirect",
      name: "Redirect",
      hooks: {
        onSuccess(context) {
          if (context.data?.url && context.data?.redirect) {
            if (typeof window !== "undefined" && window.location) {
              if (window.location)
                try {
                  window.location.href = context.data.url;
                } catch {}
            }
          }
        },
      },
    };
  },
  //# sourceMappingURL=fetch-plugins.mjs.map
  "[project]/node_modules/better-auth/dist/client/parser.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["parseJSON", () => parseJSON]);
    //#region src/client/parser.ts
    const PROTO_POLLUTION_PATTERNS = {
      proto:
        /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
      constructor:
        /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
      protoShort: /"__proto__"\s*:/,
      constructorShort: /"constructor"\s*:/,
    };
    const JSON_SIGNATURE = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
    const SPECIAL_VALUES = {
      true: true,
      false: false,
      null: null,
      undefined: void 0,
      nan: NaN,
      infinity: Number.POSITIVE_INFINITY,
      "-infinity": Number.NEGATIVE_INFINITY,
    };
    const ISO_DATE_REGEX =
      /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d{1,7}))?(?:Z|([+-])(\d{2}):(\d{2}))$/;
    function isValidDate(date) {
      return date instanceof Date && !isNaN(date.getTime());
    }
    function parseISODate(value) {
      const match = ISO_DATE_REGEX.exec(value);
      if (!match) return null;
      const [, year, month, day, hour, minute, second, ms, offsetSign, offsetHour, offsetMinute] =
        match;
      const date = new Date(
        Date.UTC(
          parseInt(year, 10),
          parseInt(month, 10) - 1,
          parseInt(day, 10),
          parseInt(hour, 10),
          parseInt(minute, 10),
          parseInt(second, 10),
          ms ? parseInt(ms.padEnd(3, "0"), 10) : 0,
        ),
      );
      if (offsetSign) {
        const offset =
          (parseInt(offsetHour, 10) * 60 + parseInt(offsetMinute, 10)) *
          (offsetSign === "+" ? -1 : 1);
        date.setUTCMinutes(date.getUTCMinutes() + offset);
      }
      return isValidDate(date) ? date : null;
    }
    function betterJSONParse(value, options = {}) {
      const { strict = false, warnings = false, reviver, parseDates = true } = options;
      if (typeof value !== "string") return value;
      const trimmed = value.trim();
      if (
        trimmed.length > 0 &&
        trimmed[0] === '"' &&
        trimmed.endsWith('"') &&
        !trimmed.slice(1, -1).includes('"')
      )
        return trimmed.slice(1, -1);
      const lowerValue = trimmed.toLowerCase();
      if (lowerValue.length <= 9 && lowerValue in SPECIAL_VALUES) return SPECIAL_VALUES[lowerValue];
      if (!JSON_SIGNATURE.test(trimmed)) {
        if (strict) throw new SyntaxError("[better-json] Invalid JSON");
        return value;
      }
      if (
        Object.entries(PROTO_POLLUTION_PATTERNS).some(([key, pattern]) => {
          const matches = pattern.test(trimmed);
          if (matches && warnings)
            console.warn(
              `[better-json] Detected potential prototype pollution attempt using ${key} pattern`,
            );
          return matches;
        }) &&
        strict
      )
        throw new Error("[better-json] Potential prototype pollution attempt detected");
      try {
        const secureReviver = (key, value$1) => {
          if (
            key === "__proto__" ||
            (key === "constructor" &&
              value$1 &&
              typeof value$1 === "object" &&
              "prototype" in value$1)
          ) {
            if (warnings)
              console.warn(`[better-json] Dropping "${key}" key to prevent prototype pollution`);
            return;
          }
          if (parseDates && typeof value$1 === "string") {
            const date = parseISODate(value$1);
            if (date) return date;
          }
          return reviver ? reviver(key, value$1) : value$1;
        };
        return JSON.parse(trimmed, secureReviver);
      } catch (error) {
        if (strict) throw error;
        return value;
      }
    }
    function parseJSON(
      value,
      options = {
        strict: true,
      },
    ) {
      return betterJSONParse(value, options);
    }
  },
  //# sourceMappingURL=parser.mjs.map
  "[project]/node_modules/better-auth/dist/client/query.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useAuthQuery", () => useAuthQuery]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$atom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/nanostores/atom/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$lifecycle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/nanostores/lifecycle/index.js [app-client] (ecmascript)",
      );
    //#region src/client/query.ts
    const isServer = () => typeof window === "undefined";
    const useAuthQuery = (initializedAtom, path, $fetch, options) => {
      const value = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$atom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "atom"
      ])({
        data: null,
        error: null,
        isPending: true,
        isRefetching: false,
        refetch: (queryParams) => fn(queryParams),
      });
      const fn = async (queryParams) => {
        return new Promise((resolve) => {
          const opts =
            typeof options === "function"
              ? options({
                  data: value.get().data,
                  error: value.get().error,
                  isPending: value.get().isPending,
                })
              : options;
          $fetch(path, {
            ...opts,
            query: {
              ...opts?.query,
              ...queryParams?.query,
            },
            async onSuccess(context) {
              value.set({
                data: context.data,
                error: null,
                isPending: false,
                isRefetching: false,
                refetch: value.value.refetch,
              });
              await opts?.onSuccess?.(context);
            },
            async onError(context) {
              const { request } = context;
              const retryAttempts =
                typeof request.retry === "number" ? request.retry : request.retry?.attempts;
              const retryAttempt = request.retryAttempt || 0;
              if (retryAttempts && retryAttempt < retryAttempts) return;
              value.set({
                error: context.error,
                data: null,
                isPending: false,
                isRefetching: false,
                refetch: value.value.refetch,
              });
              await opts?.onError?.(context);
            },
            async onRequest(context) {
              const currentValue = value.get();
              value.set({
                isPending: currentValue.data === null,
                data: currentValue.data,
                error: null,
                isRefetching: true,
                refetch: value.value.refetch,
              });
              await opts?.onRequest?.(context);
            },
          })
            .catch((error) => {
              value.set({
                error,
                data: null,
                isPending: false,
                isRefetching: false,
                refetch: value.value.refetch,
              });
            })
            .finally(() => {
              resolve(void 0);
            });
        });
      };
      initializedAtom = Array.isArray(initializedAtom) ? initializedAtom : [initializedAtom];
      let isMounted = false;
      for (const initAtom of initializedAtom)
        initAtom.subscribe(async () => {
          if (isServer()) return;
          if (isMounted) await fn();
          else
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$lifecycle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "onMount"
            ])(value, () => {
              const timeoutId = setTimeout(async () => {
                if (!isMounted) {
                  await fn();
                  isMounted = true;
                }
              }, 0);
              return () => {
                value.off();
                initAtom.off();
                clearTimeout(timeoutId);
              };
            });
        });
      return value;
    };
  },
  //# sourceMappingURL=query.mjs.map
  "[project]/node_modules/better-auth/dist/client/broadcast-channel.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "getGlobalBroadcastChannel",
      () => getGlobalBroadcastChannel,
      "kBroadcastChannel",
      () => kBroadcastChannel,
    ]);
    //#region src/client/broadcast-channel.ts
    const kBroadcastChannel = Symbol.for("better-auth:broadcast-channel");
    const now = () => Math.floor(Date.now() / 1e3);
    var WindowBroadcastChannel = class {
      listeners = /* @__PURE__ */ new Set();
      name;
      constructor(name = "better-auth.message") {
        this.name = name;
      }
      subscribe(listener) {
        this.listeners.add(listener);
        return () => {
          this.listeners.delete(listener);
        };
      }
      post(message) {
        if (typeof window === "undefined") return;
        try {
          localStorage.setItem(
            this.name,
            JSON.stringify({
              ...message,
              timestamp: now(),
            }),
          );
        } catch {}
      }
      setup() {
        if (typeof window === "undefined" || typeof window.addEventListener === "undefined")
          return () => {};
        const handler = (event) => {
          if (event.key !== this.name) return;
          const message = JSON.parse(event.newValue ?? "{}");
          if (message?.event !== "session" || !message?.data) return;
          this.listeners.forEach((listener) => listener(message));
        };
        window.addEventListener("storage", handler);
        return () => {
          window.removeEventListener("storage", handler);
        };
      }
    };
    function getGlobalBroadcastChannel(name = "better-auth.message") {
      if (!globalThis[kBroadcastChannel])
        globalThis[kBroadcastChannel] = new WindowBroadcastChannel(name);
      return globalThis[kBroadcastChannel];
    }
  },
  //# sourceMappingURL=broadcast-channel.mjs.map
  "[project]/node_modules/better-auth/dist/client/focus-manager.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "getGlobalFocusManager",
      () => getGlobalFocusManager,
      "kFocusManager",
      () => kFocusManager,
    ]);
    //#region src/client/focus-manager.ts
    const kFocusManager = Symbol.for("better-auth:focus-manager");
    var WindowFocusManager = class {
      listeners = /* @__PURE__ */ new Set();
      subscribe(listener) {
        this.listeners.add(listener);
        return () => {
          this.listeners.delete(listener);
        };
      }
      setFocused(focused) {
        this.listeners.forEach((listener) => listener(focused));
      }
      setup() {
        if (
          typeof window === "undefined" ||
          typeof document === "undefined" ||
          typeof window.addEventListener === "undefined"
        )
          return () => {};
        const visibilityHandler = () => {
          if (document.visibilityState === "visible") this.setFocused(true);
        };
        document.addEventListener("visibilitychange", visibilityHandler, false);
        return () => {
          document.removeEventListener("visibilitychange", visibilityHandler, false);
        };
      }
    };
    function getGlobalFocusManager() {
      if (!globalThis[kFocusManager]) globalThis[kFocusManager] = new WindowFocusManager();
      return globalThis[kFocusManager];
    }
  },
  //# sourceMappingURL=focus-manager.mjs.map
  "[project]/node_modules/better-auth/dist/client/online-manager.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "getGlobalOnlineManager",
      () => getGlobalOnlineManager,
      "kOnlineManager",
      () => kOnlineManager,
    ]);
    //#region src/client/online-manager.ts
    const kOnlineManager = Symbol.for("better-auth:online-manager");
    var WindowOnlineManager = class {
      listeners = /* @__PURE__ */ new Set();
      isOnline = typeof navigator !== "undefined" ? navigator.onLine : true;
      subscribe(listener) {
        this.listeners.add(listener);
        return () => {
          this.listeners.delete(listener);
        };
      }
      setOnline(online) {
        this.isOnline = online;
        this.listeners.forEach((listener) => listener(online));
      }
      setup() {
        if (typeof window === "undefined" || typeof window.addEventListener === "undefined")
          return () => {};
        const onOnline = () => this.setOnline(true);
        const onOffline = () => this.setOnline(false);
        window.addEventListener("online", onOnline, false);
        window.addEventListener("offline", onOffline, false);
        return () => {
          window.removeEventListener("online", onOnline, false);
          window.removeEventListener("offline", onOffline, false);
        };
      }
    };
    function getGlobalOnlineManager() {
      if (!globalThis[kOnlineManager]) globalThis[kOnlineManager] = new WindowOnlineManager();
      return globalThis[kOnlineManager];
    }
  },
  //# sourceMappingURL=online-manager.mjs.map
  "[project]/node_modules/better-auth/dist/client/session-refresh.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["createSessionRefreshManager", () => createSessionRefreshManager]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$broadcast$2d$channel$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/client/broadcast-channel.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$focus$2d$manager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/client/focus-manager.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$online$2d$manager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/client/online-manager.mjs [app-client] (ecmascript)",
      );
    //#region src/client/session-refresh.ts
    const now = () => Math.floor(Date.now() / 1e3);
    /**
     * Rate limit: don't refetch on focus if a session request was made within this many seconds
     */ const FOCUS_REFETCH_RATE_LIMIT_SECONDS = 5;
    function createSessionRefreshManager(opts) {
      const { sessionAtom, sessionSignal, $fetch, options = {} } = opts;
      const refetchInterval = options.sessionOptions?.refetchInterval ?? 0;
      const refetchOnWindowFocus = options.sessionOptions?.refetchOnWindowFocus ?? true;
      const refetchWhenOffline = options.sessionOptions?.refetchWhenOffline ?? false;
      const state = {
        lastSync: 0,
        lastSessionRequest: 0,
        cachedSession: void 0,
      };
      const shouldRefetch = () => {
        return (
          refetchWhenOffline ||
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$online$2d$manager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getGlobalOnlineManager"
          ])().isOnline
        );
      };
      const triggerRefetch = (event) => {
        if (!shouldRefetch()) return;
        if (event?.event === "storage") {
          state.lastSync = now();
          sessionSignal.set(!sessionSignal.get());
          return;
        }
        const currentSession = sessionAtom.get();
        if (event?.event === "poll") {
          state.lastSessionRequest = now();
          $fetch("/get-session")
            .then((res) => {
              if (res.error)
                sessionAtom.set({
                  ...currentSession,
                  data: null,
                  error: res.error,
                });
              else
                sessionAtom.set({
                  ...currentSession,
                  data: res.data,
                  error: null,
                });
              state.lastSync = now();
              sessionSignal.set(!sessionSignal.get());
            })
            .catch(() => {});
          return;
        }
        if (event?.event === "visibilitychange") {
          if (now() - state.lastSessionRequest < FOCUS_REFETCH_RATE_LIMIT_SECONDS) return;
          state.lastSessionRequest = now();
        }
        if (
          currentSession?.data === null ||
          currentSession?.data === void 0 ||
          event?.event === "visibilitychange"
        ) {
          state.lastSync = now();
          sessionSignal.set(!sessionSignal.get());
        }
      };
      const broadcastSessionUpdate = (trigger) => {
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$broadcast$2d$channel$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getGlobalBroadcastChannel"
        ])().post({
          event: "session",
          data: {
            trigger,
          },
          clientId: Math.random().toString(36).substring(7),
        });
      };
      const setupPolling = () => {
        if (refetchInterval && refetchInterval > 0)
          state.pollInterval = setInterval(() => {
            if (sessionAtom.get()?.data)
              triggerRefetch({
                event: "poll",
              });
          }, refetchInterval * 1e3);
      };
      const setupBroadcast = () => {
        state.unsubscribeBroadcast = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$broadcast$2d$channel$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getGlobalBroadcastChannel"
        ])().subscribe(() => {
          triggerRefetch({
            event: "storage",
          });
        });
      };
      const setupFocusRefetch = () => {
        if (!refetchOnWindowFocus) return;
        state.unsubscribeFocus = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$focus$2d$manager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getGlobalFocusManager"
        ])().subscribe(() => {
          triggerRefetch({
            event: "visibilitychange",
          });
        });
      };
      const setupOnlineRefetch = () => {
        state.unsubscribeOnline = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$online$2d$manager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getGlobalOnlineManager"
        ])().subscribe((online) => {
          if (online)
            triggerRefetch({
              event: "visibilitychange",
            });
        });
      };
      const init = () => {
        setupPolling();
        setupBroadcast();
        setupFocusRefetch();
        setupOnlineRefetch();
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$broadcast$2d$channel$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getGlobalBroadcastChannel"
        ])().setup();
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$focus$2d$manager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getGlobalFocusManager"
        ])().setup();
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$online$2d$manager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getGlobalOnlineManager"
        ])().setup();
      };
      const cleanup = () => {
        if (state.pollInterval) {
          clearInterval(state.pollInterval);
          state.pollInterval = void 0;
        }
        if (state.unsubscribeBroadcast) {
          state.unsubscribeBroadcast();
          state.unsubscribeBroadcast = void 0;
        }
        if (state.unsubscribeFocus) {
          state.unsubscribeFocus();
          state.unsubscribeFocus = void 0;
        }
        if (state.unsubscribeOnline) {
          state.unsubscribeOnline();
          state.unsubscribeOnline = void 0;
        }
        state.lastSync = 0;
        state.lastSessionRequest = 0;
        state.cachedSession = void 0;
      };
      return {
        init,
        cleanup,
        triggerRefetch,
        broadcastSessionUpdate,
      };
    }
  },
  //# sourceMappingURL=session-refresh.mjs.map
  "[project]/node_modules/better-auth/dist/client/session-atom.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["getSessionAtom", () => getSessionAtom]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$query$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/client/query.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$session$2d$refresh$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/client/session-refresh.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$atom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/nanostores/atom/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$lifecycle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/nanostores/lifecycle/index.js [app-client] (ecmascript)",
      );
    //#region src/client/session-atom.ts
    function getSessionAtom($fetch, options) {
      const $signal = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$atom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "atom"
      ])(false);
      const session = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$query$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useAuthQuery"
      ])($signal, "/get-session", $fetch, {
        method: "GET",
      });
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$lifecycle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "onMount"
      ])(session, () => {
        const refreshManager = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$session$2d$refresh$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "createSessionRefreshManager"
        ])({
          sessionAtom: session,
          sessionSignal: $signal,
          $fetch,
          options,
        });
        refreshManager.init();
        return () => {
          refreshManager.cleanup();
        };
      });
      return {
        session,
        $sessionSignal: $signal,
      };
    }
  },
  //# sourceMappingURL=session-atom.mjs.map
  "[project]/node_modules/better-auth/dist/client/config.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["getClientConfig", () => getClientConfig]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$utils$2f$url$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/utils/url.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$fetch$2d$plugins$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/client/fetch-plugins.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$parser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/client/parser.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$session$2d$atom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/client/session-atom.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$defu$2f$dist$2f$defu$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/defu/dist/defu.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$fetch$2f$fetch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-fetch/fetch/dist/index.js [app-client] (ecmascript)",
      );
    //#region src/client/config.ts
    const getClientConfig = (options, loadEnv) => {
      const isCredentialsSupported = "credentials" in Request.prototype;
      const baseURL =
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$utils$2f$url$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getBaseURL"
        ])(options?.baseURL, options?.basePath, void 0, loadEnv) ?? "/api/auth";
      const pluginsFetchPlugins =
        options?.plugins?.flatMap((plugin) => plugin.fetchPlugins).filter((pl) => pl !== void 0) ||
        [];
      const lifeCyclePlugin = {
        id: "lifecycle-hooks",
        name: "lifecycle-hooks",
        hooks: {
          onSuccess: options?.fetchOptions?.onSuccess,
          onError: options?.fetchOptions?.onError,
          onRequest: options?.fetchOptions?.onRequest,
          onResponse: options?.fetchOptions?.onResponse,
        },
      };
      const {
        onSuccess: _onSuccess,
        onError: _onError,
        onRequest: _onRequest,
        onResponse: _onResponse,
        ...restOfFetchOptions
      } = options?.fetchOptions || {};
      const $fetch = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$fetch$2f$fetch$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "createFetch"
      ])({
        baseURL,
        ...(isCredentialsSupported
          ? {
              credentials: "include",
            }
          : {}),
        method: "GET",
        jsonParser(text) {
          if (!text) return null;
          return (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$parser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "parseJSON"
          ])(text, {
            strict: false,
          });
        },
        customFetchImpl: fetch,
        ...restOfFetchOptions,
        plugins: [
          lifeCyclePlugin,
          ...(restOfFetchOptions.plugins || []),
          ...(options?.disableDefaultFetchPlugins
            ? []
            : [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$fetch$2d$plugins$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "redirectPlugin"
                ],
              ]),
          ...pluginsFetchPlugins,
        ],
      });
      const { $sessionSignal, session } = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$session$2d$atom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getSessionAtom"
      ])($fetch, options);
      const plugins = options?.plugins || [];
      let pluginsActions = {};
      const pluginsAtoms = {
        $sessionSignal,
        session,
      };
      const pluginPathMethods = {
        "/sign-out": "POST",
        "/revoke-sessions": "POST",
        "/revoke-other-sessions": "POST",
        "/delete-user": "POST",
      };
      const atomListeners = [
        {
          signal: "$sessionSignal",
          matcher(path) {
            return (
              path === "/sign-out" ||
              path === "/update-user" ||
              path === "/sign-up/email" ||
              path === "/sign-in/email" ||
              path === "/delete-user" ||
              path === "/verify-email" ||
              path === "/revoke-sessions" ||
              path === "/revoke-session" ||
              path === "/change-email"
            );
          },
        },
      ];
      for (const plugin of plugins) {
        if (plugin.getAtoms) Object.assign(pluginsAtoms, plugin.getAtoms?.($fetch));
        if (plugin.pathMethods) Object.assign(pluginPathMethods, plugin.pathMethods);
        if (plugin.atomListeners) atomListeners.push(...plugin.atomListeners);
      }
      const $store = {
        notify: (signal) => {
          pluginsAtoms[signal].set(!pluginsAtoms[signal].get());
        },
        listen: (signal, listener) => {
          pluginsAtoms[signal].subscribe(listener);
        },
        atoms: pluginsAtoms,
      };
      for (const plugin of plugins)
        if (plugin.getActions)
          pluginsActions = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$defu$2f$dist$2f$defu$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "defu"
          ])(plugin.getActions?.($fetch, $store, options) ?? {}, pluginsActions);
      return {
        get baseURL() {
          return baseURL;
        },
        pluginsActions,
        pluginsAtoms,
        pluginPathMethods,
        atomListeners,
        $fetch,
        $store,
      };
    };
  },
  //# sourceMappingURL=config.mjs.map
  "[project]/node_modules/better-auth/dist/utils/is-atom.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["isAtom", () => isAtom]);
    //#region src/utils/is-atom.ts
    function isAtom(value) {
      return (
        typeof value === "object" &&
        value !== null &&
        "get" in value &&
        typeof value.get === "function" &&
        "lc" in value &&
        typeof value.lc === "number"
      );
    }
  },
  //# sourceMappingURL=is-atom.mjs.map
  "[project]/node_modules/better-auth/dist/client/proxy.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["createDynamicPathProxy", () => createDynamicPathProxy]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$utils$2f$is$2d$atom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/utils/is-atom.mjs [app-client] (ecmascript)",
      );
    //#region src/client/proxy.ts
    function getMethod(path, knownPathMethods, args) {
      const method = knownPathMethods[path];
      const { fetchOptions, query: _query, ...body } = args || {};
      if (method) return method;
      if (fetchOptions?.method) return fetchOptions.method;
      if (body && Object.keys(body).length > 0) return "POST";
      return "GET";
    }
    function createDynamicPathProxy(routes, client, knownPathMethods, atoms, atomListeners) {
      function createProxy(path = []) {
        return new Proxy(function () {}, {
          get(_, prop) {
            if (typeof prop !== "string") return;
            if (prop === "then" || prop === "catch" || prop === "finally") return;
            const fullPath = [...path, prop];
            let current = routes;
            for (const segment of fullPath)
              if (current && typeof current === "object" && segment in current)
                current = current[segment];
              else {
                current = void 0;
                break;
              }
            if (typeof current === "function") return current;
            if (
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$utils$2f$is$2d$atom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "isAtom"
              ])(current)
            )
              return current;
            return createProxy(fullPath);
          },
          apply: async (_, __, args) => {
            const routePath =
              "/" +
              path
                .map((segment) => segment.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`))
                .join("/");
            const arg = args[0] || {};
            const fetchOptions = args[1] || {};
            const { query, fetchOptions: argFetchOptions, ...body } = arg;
            const options = {
              ...fetchOptions,
              ...argFetchOptions,
            };
            const method = getMethod(routePath, knownPathMethods, arg);
            return await client(routePath, {
              ...options,
              body:
                method === "GET"
                  ? void 0
                  : {
                      ...body,
                      ...(options?.body || {}),
                    },
              query: query || options?.query,
              method,
              async onSuccess(context) {
                await options?.onSuccess?.(context);
                if (!atomListeners || options.disableSignal) return;
                /**
                 * We trigger listeners
                 */ const matches = atomListeners.filter((s) => s.matcher(routePath));
                if (!matches.length) return;
                const visited = /* @__PURE__ */ new Set();
                for (const match of matches) {
                  const signal = atoms[match.signal];
                  if (!signal) return;
                  if (visited.has(match.signal)) continue;
                  visited.add(match.signal);
                  /**
                   * To avoid race conditions we set the signal in a setTimeout
                   */ const val = signal.get();
                  setTimeout(() => {
                    signal.set(!val);
                  }, 10);
                }
              },
            });
          },
        });
      }
      return createProxy();
    }
  },
  //# sourceMappingURL=proxy.mjs.map
  "[project]/node_modules/better-auth/dist/client/react/react-store.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useStore", () => useStore]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$listen$2d$keys$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/nanostores/listen-keys/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    //#region src/client/react/react-store.ts
    /**
     * Subscribe to store changes and get store's value.
     *
     * Can be used with store builder too.
     *
     * ```js
     * import { useStore } from 'nanostores/react'
     *
     * import { router } from '../store/router'
     *
     * export const Layout = () => {
     *   let page = useStore(router)
     *   if (page.route === 'home') {
     *     return <HomePage />
     *   } else {
     *     return <Error404 />
     *   }
     * }
     * ```
     *
     * @param store Store instance.
     * @returns Store value.
     */ function useStore(store, options = {}) {
      const snapshotRef = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useRef"
      ])(store.get());
      const { keys, deps = [store, keys] } = options;
      const subscribe = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useCallback"
      ])(
        {
          "useStore.useCallback[subscribe]": (onChange) => {
            const emitChange = {
              "useStore.useCallback[subscribe].emitChange": (value) => {
                if (snapshotRef.current === value) return;
                snapshotRef.current = value;
                onChange();
              },
            }["useStore.useCallback[subscribe].emitChange"];
            emitChange(store.value);
            if (keys?.length)
              return (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$listen$2d$keys$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "listenKeys"
              ])(store, keys, emitChange);
            return store.listen(emitChange);
          },
        }["useStore.useCallback[subscribe]"],
        deps,
      );
      const get = () => snapshotRef.current;
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useSyncExternalStore"
      ])(subscribe, get, get);
    }
  },
  //# sourceMappingURL=react-store.mjs.map
  "[project]/node_modules/better-auth/dist/client/react/index.mjs [app-client] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["createAuthClient", () => createAuthClient]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$config$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/client/config.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$proxy$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/client/proxy.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$react$2f$react$2d$store$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/better-auth/dist/client/react/react-store.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/utils/index.mjs [app-client] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$string$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@better-auth/core/dist/utils/string.mjs [app-client] (ecmascript)",
      );
    //#region src/client/react/index.ts
    function getAtomKey(str) {
      return `use${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$better$2d$auth$2f$core$2f$dist$2f$utils$2f$string$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["capitalizeFirstLetter"])(str)}`;
    }
    function createAuthClient(options) {
      const { pluginPathMethods, pluginsActions, pluginsAtoms, $fetch, $store, atomListeners } = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$config$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getClientConfig"
      ])(options);
      const resolvedHooks = {};
      for (const [key, value] of Object.entries(pluginsAtoms))
        resolvedHooks[getAtomKey(key)] = () =>
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$react$2f$react$2d$store$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "useStore"
          ])(value);
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$proxy$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "createDynamicPathProxy"
      ])(
        {
          ...pluginsActions,
          ...resolvedHooks,
          $fetch,
          $store,
        },
        $fetch,
        pluginPathMethods,
        pluginsAtoms,
        atomListeners,
      );
    }
  },
  //# sourceMappingURL=index.mjs.map
  "[project]/node_modules/nanostores/task/index.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "allTasks",
      () => allTasks,
      "cleanTasks",
      () => cleanTasks,
      "startTask",
      () => startTask,
      "task",
      () => task,
    ]);
    let tasks = 0;
    let resolves = [];
    function startTask() {
      tasks += 1;
      return () => {
        tasks -= 1;
        if (tasks === 0) {
          let prevResolves = resolves;
          resolves = [];
          for (let i of prevResolves) i();
        }
      };
    }
    function task(cb) {
      let endTask = startTask();
      let promise = cb().finally(endTask);
      promise.t = true;
      return promise;
    }
    function allTasks() {
      if (tasks === 0) {
        return Promise.resolve();
      } else {
        return new Promise((resolve) => {
          resolves.push(resolve);
        });
      }
    }
    function cleanTasks() {
      tasks = 0;
    }
  },
  "[project]/node_modules/nanostores/clean-stores/index.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["clean", () => clean, "cleanStores", () => cleanStores]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$task$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/nanostores/task/index.js [app-client] (ecmascript)",
      );
    let clean = Symbol("clean");
    let cleanStores = (...stores) => {
      if (("TURBOPACK compile-time falsy", 0)) //TURBOPACK unreachable
      ;
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$task$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "cleanTasks"
      ])();
      for (let $store of stores) {
        if ($store) {
          if ($store.mocked) delete $store.mocked;
          if ($store[clean]) $store[clean]();
        }
      }
    };
  },
  "[project]/node_modules/nanostores/atom/index.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "atom",
      () => atom,
      "epoch",
      () => epoch,
      "readonlyType",
      () => readonlyType,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$clean$2d$stores$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/nanostores/clean-stores/index.js [app-client] (ecmascript)",
      );
    let listenerQueue = [];
    let lqIndex = 0;
    const QUEUE_ITEMS_PER_LISTENER = 4;
    let epoch = 0;
    const atom = (initialValue) => {
      let listeners = [];
      let $atom = {
        get() {
          if (!$atom.lc) {
            $atom.listen(() => {})();
          }
          return $atom.value;
        },
        lc: 0,
        listen(listener) {
          $atom.lc = listeners.push(listener);
          return () => {
            for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length; ) {
              if (listenerQueue[i] === listener) {
                listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);
              } else {
                i += QUEUE_ITEMS_PER_LISTENER;
              }
            }
            let index = listeners.indexOf(listener);
            if (~index) {
              listeners.splice(index, 1);
              if (!--$atom.lc) $atom.off();
            }
          };
        },
        notify(oldValue, changedKey) {
          epoch++;
          let runListenerQueue = !listenerQueue.length;
          for (let listener of listeners) {
            listenerQueue.push(listener, $atom.value, oldValue, changedKey);
          }
          if (runListenerQueue) {
            for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {
              listenerQueue[lqIndex](
                listenerQueue[lqIndex + 1],
                listenerQueue[lqIndex + 2],
                listenerQueue[lqIndex + 3],
              );
            }
            listenerQueue.length = 0;
          }
        },
        /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */ off() {},
        set(newValue) {
          let oldValue = $atom.value;
          if (oldValue !== newValue) {
            $atom.value = newValue;
            $atom.notify(oldValue);
          }
        },
        subscribe(listener) {
          let unbind = $atom.listen(listener);
          listener($atom.value);
          return unbind;
        },
        value: initialValue,
      };
      if (("TURBOPACK compile-time truthy", 1)) {
        $atom[
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$clean$2d$stores$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "clean"
          ]
        ] = () => {
          listeners = [];
          $atom.lc = 0;
          $atom.off();
        };
      }
      return $atom;
    };
    const readonlyType = (store) => store;
  },
  "[project]/node_modules/nanostores/lifecycle/index.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "STORE_UNMOUNT_DELAY",
      () => STORE_UNMOUNT_DELAY,
      "on",
      () => on,
      "onMount",
      () => onMount,
      "onNotify",
      () => onNotify,
      "onSet",
      () => onSet,
      "onStart",
      () => onStart,
      "onStop",
      () => onStop,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$clean$2d$stores$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/nanostores/clean-stores/index.js [app-client] (ecmascript)",
      );
    const START = 0;
    const STOP = 1;
    const SET = 2;
    const NOTIFY = 3;
    const MOUNT = 5;
    const UNMOUNT = 6;
    const REVERT_MUTATION = 10;
    let on = (object, listener, eventKey, mutateStore) => {
      object.events = object.events || {};
      if (!object.events[eventKey + REVERT_MUTATION]) {
        object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
          // eslint-disable-next-line no-sequences
          object.events[eventKey].reduceRight((event, l) => (l(event), event), {
            shared: {},
            ...eventProps,
          });
        });
      }
      object.events[eventKey] = object.events[eventKey] || [];
      object.events[eventKey].push(listener);
      return () => {
        let currentListeners = object.events[eventKey];
        let index = currentListeners.indexOf(listener);
        currentListeners.splice(index, 1);
        if (!currentListeners.length) {
          delete object.events[eventKey];
          object.events[eventKey + REVERT_MUTATION]();
          delete object.events[eventKey + REVERT_MUTATION];
        }
      };
    };
    let onStart = ($store, listener) =>
      on($store, listener, START, (runListeners) => {
        let originListen = $store.listen;
        $store.listen = (arg) => {
          if (!$store.lc && !$store.starting) {
            $store.starting = true;
            runListeners();
            delete $store.starting;
          }
          return originListen(arg);
        };
        return () => {
          $store.listen = originListen;
        };
      });
    let onStop = ($store, listener) =>
      on($store, listener, STOP, (runListeners) => {
        let originOff = $store.off;
        $store.off = () => {
          runListeners();
          originOff();
        };
        return () => {
          $store.off = originOff;
        };
      });
    let onSet = ($store, listener) =>
      on($store, listener, SET, (runListeners) => {
        let originSet = $store.set;
        let originSetKey = $store.setKey;
        if ($store.setKey) {
          $store.setKey = (changed, changedValue) => {
            let isAborted;
            let abort = () => {
              isAborted = true;
            };
            runListeners({
              abort,
              changed,
              newValue: {
                ...$store.value,
                [changed]: changedValue,
              },
            });
            if (!isAborted) return originSetKey(changed, changedValue);
          };
        }
        $store.set = (newValue) => {
          let isAborted;
          let abort = () => {
            isAborted = true;
          };
          runListeners({
            abort,
            newValue,
          });
          if (!isAborted) return originSet(newValue);
        };
        return () => {
          $store.set = originSet;
          $store.setKey = originSetKey;
        };
      });
    let onNotify = ($store, listener) =>
      on($store, listener, NOTIFY, (runListeners) => {
        let originNotify = $store.notify;
        $store.notify = (oldValue, changed) => {
          let isAborted;
          let abort = () => {
            isAborted = true;
          };
          runListeners({
            abort,
            changed,
            oldValue,
          });
          if (!isAborted) return originNotify(oldValue, changed);
        };
        return () => {
          $store.notify = originNotify;
        };
      });
    let STORE_UNMOUNT_DELAY = 1000;
    let onMount = ($store, initialize) => {
      let listener = (payload) => {
        let destroy = initialize(payload);
        if (destroy) $store.events[UNMOUNT].push(destroy);
      };
      return on($store, listener, MOUNT, (runListeners) => {
        let originListen = $store.listen;
        $store.listen = (...args) => {
          if (!$store.lc && !$store.active) {
            $store.active = true;
            runListeners();
          }
          return originListen(...args);
        };
        let originOff = $store.off;
        $store.events[UNMOUNT] = [];
        $store.off = () => {
          originOff();
          setTimeout(() => {
            if ($store.active && !$store.lc) {
              $store.active = false;
              for (let destroy of $store.events[UNMOUNT]) destroy();
              $store.events[UNMOUNT] = [];
            }
          }, STORE_UNMOUNT_DELAY);
        };
        if (("TURBOPACK compile-time truthy", 1)) {
          let originClean =
            $store[
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$clean$2d$stores$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "clean"
              ]
            ];
          $store[
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$nanostores$2f$clean$2d$stores$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "clean"
            ]
          ] = () => {
            for (let destroy of $store.events[UNMOUNT]) destroy();
            $store.events[UNMOUNT] = [];
            $store.active = false;
            originClean();
          };
        }
        return () => {
          $store.listen = originListen;
          $store.off = originOff;
        };
      });
    };
  },
  "[project]/node_modules/nanostores/listen-keys/index.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["listenKeys", () => listenKeys, "subscribeKeys", () => subscribeKeys]);
    function listenKeys($store, keys, listener) {
      let keysSet = new Set(keys).add(undefined);
      return $store.listen((value, oldValue, changed) => {
        if (keysSet.has(changed)) {
          listener(value, oldValue, changed);
        }
      });
    }
    function subscribeKeys($store, keys, listener) {
      let unbind = listenKeys($store, keys, listener);
      listener($store.value);
      return unbind;
    }
  },
  "[project]/node_modules/defu/dist/defu.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "createDefu",
      () => createDefu,
      "default",
      () => defu,
      "defu",
      () => defu,
      "defuArrayFn",
      () => defuArrayFn,
      "defuFn",
      () => defuFn,
    ]);
    function isPlainObject(value) {
      if (value === null || typeof value !== "object") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      if (
        prototype !== null &&
        prototype !== Object.prototype &&
        Object.getPrototypeOf(prototype) !== null
      ) {
        return false;
      }
      if (Symbol.iterator in value) {
        return false;
      }
      if (Symbol.toStringTag in value) {
        return Object.prototype.toString.call(value) === "[object Module]";
      }
      return true;
    }
    function _defu(baseObject, defaults, namespace = ".", merger) {
      if (!isPlainObject(defaults)) {
        return _defu(baseObject, {}, namespace, merger);
      }
      const object = Object.assign({}, defaults);
      for (const key in baseObject) {
        if (key === "__proto__" || key === "constructor") {
          continue;
        }
        const value = baseObject[key];
        if (value === null || value === void 0) {
          continue;
        }
        if (merger && merger(object, key, value, namespace)) {
          continue;
        }
        if (Array.isArray(value) && Array.isArray(object[key])) {
          object[key] = [...value, ...object[key]];
        } else if (isPlainObject(value) && isPlainObject(object[key])) {
          object[key] = _defu(
            value,
            object[key],
            (namespace ? `${namespace}.` : "") + key.toString(),
            merger,
          );
        } else {
          object[key] = value;
        }
      }
      return object;
    }
    function createDefu(merger) {
      return (...arguments_) =>
        // eslint-disable-next-line unicorn/no-array-reduce
        arguments_.reduce((p, c) => _defu(p, c, "", merger), {});
    }
    const defu = createDefu();
    const defuFn = createDefu((object, key, currentValue) => {
      if (object[key] !== void 0 && typeof currentValue === "function") {
        object[key] = currentValue(object[key]);
        return true;
      }
    });
    const defuArrayFn = createDefu((object, key, currentValue) => {
      if (Array.isArray(object[key]) && typeof currentValue === "function") {
        object[key] = currentValue(object[key]);
        return true;
      }
    });
  },
  "[project]/node_modules/@better-fetch/fetch/dist/index.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "BetterFetchError",
      () => BetterFetchError,
      "ValidationError",
      () => ValidationError,
      "applySchemaPlugin",
      () => applySchemaPlugin,
      "betterFetch",
      () => betterFetch,
      "bodyParser",
      () => bodyParser,
      "createFetch",
      () => createFetch,
      "createRetryStrategy",
      () => createRetryStrategy,
      "createSchema",
      () => createSchema,
      "detectContentType",
      () => detectContentType,
      "detectResponseType",
      () => detectResponseType,
      "getBody",
      () => getBody,
      "getFetch",
      () => getFetch,
      "getHeaders",
      () => getHeaders,
      "getMethod",
      () => getMethod,
      "getTimeout",
      () => getTimeout,
      "getURL",
      () => getURL,
      "initializePlugins",
      () => initializePlugins,
      "isFunction",
      () => isFunction,
      "isJSONParsable",
      () => isJSONParsable,
      "isJSONSerializable",
      () => isJSONSerializable,
      "isPayloadMethod",
      () => isPayloadMethod,
      "isRouteMethod",
      () => isRouteMethod,
      "jsonParse",
      () => jsonParse,
      "methods",
      () => methods,
      "parseStandardSchema",
      () => parseStandardSchema,
    ]);
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) =>
      key in obj
        ? __defProp(obj, key, {
            enumerable: true,
            configurable: true,
            writable: true,
            value,
          })
        : (obj[key] = value);
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    // src/error.ts
    var BetterFetchError = class extends Error {
      constructor(status, statusText, error) {
        super(statusText || status.toString(), {
          cause: error,
        });
        this.status = status;
        this.statusText = statusText;
        this.error = error;
        Error.captureStackTrace(this, this.constructor);
      }
    };
    // src/plugins.ts
    var initializePlugins = async (url, options) => {
      var _a, _b, _c, _d, _e, _f;
      let opts = options || {};
      const hooks = {
        onRequest: [options == null ? void 0 : options.onRequest],
        onResponse: [options == null ? void 0 : options.onResponse],
        onSuccess: [options == null ? void 0 : options.onSuccess],
        onError: [options == null ? void 0 : options.onError],
        onRetry: [options == null ? void 0 : options.onRetry],
      };
      if (!options || !(options == null ? void 0 : options.plugins)) {
        return {
          url,
          options: opts,
          hooks,
        };
      }
      for (const plugin of (options == null ? void 0 : options.plugins) || []) {
        if (plugin.init) {
          const pluginRes = await ((_a = plugin.init) == null
            ? void 0
            : _a.call(plugin, url.toString(), options));
          opts = pluginRes.options || opts;
          url = pluginRes.url;
        }
        hooks.onRequest.push((_b = plugin.hooks) == null ? void 0 : _b.onRequest);
        hooks.onResponse.push((_c = plugin.hooks) == null ? void 0 : _c.onResponse);
        hooks.onSuccess.push((_d = plugin.hooks) == null ? void 0 : _d.onSuccess);
        hooks.onError.push((_e = plugin.hooks) == null ? void 0 : _e.onError);
        hooks.onRetry.push((_f = plugin.hooks) == null ? void 0 : _f.onRetry);
      }
      return {
        url,
        options: opts,
        hooks,
      };
    };
    // src/retry.ts
    var LinearRetryStrategy = class {
      constructor(options) {
        this.options = options;
      }
      shouldAttemptRetry(attempt, response) {
        if (this.options.shouldRetry) {
          return Promise.resolve(
            attempt < this.options.attempts && this.options.shouldRetry(response),
          );
        }
        return Promise.resolve(attempt < this.options.attempts);
      }
      getDelay() {
        return this.options.delay;
      }
    };
    var ExponentialRetryStrategy = class {
      constructor(options) {
        this.options = options;
      }
      shouldAttemptRetry(attempt, response) {
        if (this.options.shouldRetry) {
          return Promise.resolve(
            attempt < this.options.attempts && this.options.shouldRetry(response),
          );
        }
        return Promise.resolve(attempt < this.options.attempts);
      }
      getDelay(attempt) {
        const delay = Math.min(this.options.maxDelay, this.options.baseDelay * 2 ** attempt);
        return delay;
      }
    };
    function createRetryStrategy(options) {
      if (typeof options === "number") {
        return new LinearRetryStrategy({
          type: "linear",
          attempts: options,
          delay: 1e3,
        });
      }
      switch (options.type) {
        case "linear":
          return new LinearRetryStrategy(options);
        case "exponential":
          return new ExponentialRetryStrategy(options);
        default:
          throw new Error("Invalid retry strategy");
      }
    }
    // src/auth.ts
    var getAuthHeader = async (options) => {
      const headers = {};
      const getValue = async (value) => (typeof value === "function" ? await value() : value);
      if (options == null ? void 0 : options.auth) {
        if (options.auth.type === "Bearer") {
          const token = await getValue(options.auth.token);
          if (!token) {
            return headers;
          }
          headers["authorization"] = `Bearer ${token}`;
        } else if (options.auth.type === "Basic") {
          const [username, password] = await Promise.all([
            getValue(options.auth.username),
            getValue(options.auth.password),
          ]);
          if (!username || !password) {
            return headers;
          }
          headers["authorization"] = `Basic ${btoa(`${username}:${password}`)}`;
        } else if (options.auth.type === "Custom") {
          const [prefix, value] = await Promise.all([
            getValue(options.auth.prefix),
            getValue(options.auth.value),
          ]);
          if (!value) {
            return headers;
          }
          headers["authorization"] = `${prefix != null ? prefix : ""} ${value}`;
        }
      }
      return headers;
    };
    // src/utils.ts
    var JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
    function detectResponseType(request) {
      const _contentType = request.headers.get("content-type");
      const textTypes = /* @__PURE__ */ new Set([
        "image/svg",
        "application/xml",
        "application/xhtml",
        "application/html",
      ]);
      if (!_contentType) {
        return "json";
      }
      const contentType = _contentType.split(";").shift() || "";
      if (JSON_RE.test(contentType)) {
        return "json";
      }
      if (textTypes.has(contentType) || contentType.startsWith("text/")) {
        return "text";
      }
      return "blob";
    }
    function isJSONParsable(value) {
      try {
        JSON.parse(value);
        return true;
      } catch (error) {
        return false;
      }
    }
    function isJSONSerializable(value) {
      if (value === void 0) {
        return false;
      }
      const t = typeof value;
      if (t === "string" || t === "number" || t === "boolean" || t === null) {
        return true;
      }
      if (t !== "object") {
        return false;
      }
      if (Array.isArray(value)) {
        return true;
      }
      if (value.buffer) {
        return false;
      }
      return (
        (value.constructor && value.constructor.name === "Object") ||
        typeof value.toJSON === "function"
      );
    }
    function jsonParse(text) {
      try {
        return JSON.parse(text);
      } catch (error) {
        return text;
      }
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function getFetch(options) {
      if (options == null ? void 0 : options.customFetchImpl) {
        return options.customFetchImpl;
      }
      if (typeof globalThis !== "undefined" && isFunction(globalThis.fetch)) {
        return globalThis.fetch;
      }
      if (typeof window !== "undefined" && isFunction(window.fetch)) {
        return window.fetch;
      }
      throw new Error("No fetch implementation found");
    }
    function isPayloadMethod(method) {
      if (!method) {
        return false;
      }
      const payloadMethod = ["POST", "PUT", "PATCH", "DELETE"];
      return payloadMethod.includes(method.toUpperCase());
    }
    function isRouteMethod(method) {
      const routeMethod = ["GET", "POST", "PUT", "PATCH", "DELETE"];
      if (!method) {
        return false;
      }
      return routeMethod.includes(method.toUpperCase());
    }
    async function getHeaders(opts) {
      const headers = new Headers(opts == null ? void 0 : opts.headers);
      const authHeader = await getAuthHeader(opts);
      for (const [key, value] of Object.entries(authHeader || {})) {
        headers.set(key, value);
      }
      if (!headers.has("content-type")) {
        const t = detectContentType(opts == null ? void 0 : opts.body);
        if (t) {
          headers.set("content-type", t);
        }
      }
      return headers;
    }
    function getURL(url, options) {
      if (url.startsWith("@")) {
        const m = url.toString().split("@")[1].split("/")[0];
        if (methods.includes(m)) {
          url = url.replace(`@${m}/`, "/");
        }
      }
      let _url;
      try {
        if (url.startsWith("http")) {
          _url = url;
        } else {
          let baseURL = options == null ? void 0 : options.baseURL;
          if (baseURL && !(baseURL == null ? void 0 : baseURL.endsWith("/"))) {
            baseURL = baseURL + "/";
          }
          if (url.startsWith("/")) {
            _url = new URL(url.substring(1), baseURL);
          } else {
            _url = new URL(url, options == null ? void 0 : options.baseURL);
          }
        }
      } catch (e) {
        if (e instanceof TypeError) {
          if (!(options == null ? void 0 : options.baseURL)) {
            throw TypeError(
              `Invalid URL ${url}. Are you passing in a relative url but not setting the baseURL?`,
            );
          }
          throw TypeError(
            `Invalid URL ${url}. Please validate that you are passing the correct input.`,
          );
        }
        throw e;
      }
      if (options == null ? void 0 : options.params) {
        if (Array.isArray(options == null ? void 0 : options.params)) {
          const params = (options == null ? void 0 : options.params)
            ? Array.isArray(options.params)
              ? `/${options.params.join("/")}`
              : `/${Object.values(options.params).join("/")}`
            : "";
          _url = _url.toString().split("/:")[0];
          _url = `${_url.toString()}${params}`;
        } else {
          for (const [key, value] of Object.entries(options == null ? void 0 : options.params)) {
            _url = _url.toString().replace(`:${key}`, String(value));
          }
        }
      }
      const __url = new URL(_url);
      const queryParams = options == null ? void 0 : options.query;
      if (queryParams) {
        for (const [key, value] of Object.entries(queryParams)) {
          __url.searchParams.append(key, String(value));
        }
      }
      return __url;
    }
    function detectContentType(body) {
      if (isJSONSerializable(body)) {
        return "application/json";
      }
      return null;
    }
    function getBody(options) {
      if (!(options == null ? void 0 : options.body)) {
        return null;
      }
      const headers = new Headers(options == null ? void 0 : options.headers);
      if (isJSONSerializable(options.body) && !headers.has("content-type")) {
        for (const [key, value] of Object.entries(options == null ? void 0 : options.body)) {
          if (value instanceof Date) {
            options.body[key] = value.toISOString();
          }
        }
        return JSON.stringify(options.body);
      }
      if (
        headers.has("content-type") &&
        headers.get("content-type") === "application/x-www-form-urlencoded"
      ) {
        if (isJSONSerializable(options.body)) {
          return new URLSearchParams(options.body).toString();
        }
        return options.body;
      }
      return options.body;
    }
    function getMethod(url, options) {
      var _a;
      if (options == null ? void 0 : options.method) {
        return options.method.toUpperCase();
      }
      if (url.startsWith("@")) {
        const pMethod = (_a = url.split("@")[1]) == null ? void 0 : _a.split("/")[0];
        if (!methods.includes(pMethod)) {
          return (options == null ? void 0 : options.body) ? "POST" : "GET";
        }
        return pMethod.toUpperCase();
      }
      return (options == null ? void 0 : options.body) ? "POST" : "GET";
    }
    function getTimeout(options, controller) {
      let abortTimeout;
      if (
        !(options == null ? void 0 : options.signal) &&
        (options == null ? void 0 : options.timeout)
      ) {
        abortTimeout = setTimeout(
          () => (controller == null ? void 0 : controller.abort()),
          options == null ? void 0 : options.timeout,
        );
      }
      return {
        abortTimeout,
        clearTimeout: () => {
          if (abortTimeout) {
            clearTimeout(abortTimeout);
          }
        },
      };
    }
    function bodyParser(data, responseType) {
      if (responseType === "json") {
        return JSON.parse(data);
      }
      return data;
    }
    var ValidationError = class _ValidationError extends Error {
      constructor(issues, message) {
        super(message || JSON.stringify(issues, null, 2));
        this.issues = issues;
        Object.setPrototypeOf(this, _ValidationError.prototype);
      }
    };
    async function parseStandardSchema(schema, input) {
      const result = await schema["~standard"].validate(input);
      if (result.issues) {
        throw new ValidationError(result.issues);
      }
      return result.value;
    }
    // src/create-fetch/schema.ts
    var methods = ["get", "post", "put", "patch", "delete"];
    var createSchema = (schema, config) => {
      return {
        schema,
        config,
      };
    };
    // src/create-fetch/index.ts
    var applySchemaPlugin = (config) => ({
      id: "apply-schema",
      name: "Apply Schema",
      version: "1.0.0",
      async init(url, options) {
        var _a, _b, _c, _d;
        const schema =
          ((_b =
            (_a = config.plugins) == null
              ? void 0
              : _a.find((plugin) => {
                  var _a2;
                  return ((_a2 = plugin.schema) == null ? void 0 : _a2.config)
                    ? url.startsWith(plugin.schema.config.baseURL || "") ||
                        url.startsWith(plugin.schema.config.prefix || "")
                    : false;
                })) == null
            ? void 0
            : _b.schema) || config.schema;
        if (schema) {
          let urlKey = url;
          if ((_c = schema.config) == null ? void 0 : _c.prefix) {
            if (urlKey.startsWith(schema.config.prefix)) {
              urlKey = urlKey.replace(schema.config.prefix, "");
              if (schema.config.baseURL) {
                url = url.replace(schema.config.prefix, schema.config.baseURL);
              }
            }
          }
          if ((_d = schema.config) == null ? void 0 : _d.baseURL) {
            if (urlKey.startsWith(schema.config.baseURL)) {
              urlKey = urlKey.replace(schema.config.baseURL, "");
            }
          }
          const keySchema = schema.schema[urlKey];
          if (keySchema) {
            let opts = __spreadProps(__spreadValues({}, options), {
              method: keySchema.method,
              output: keySchema.output,
            });
            if (!(options == null ? void 0 : options.disableValidation)) {
              opts = __spreadProps(__spreadValues({}, opts), {
                body: keySchema.input
                  ? await parseStandardSchema(
                      keySchema.input,
                      options == null ? void 0 : options.body,
                    )
                  : options == null
                    ? void 0
                    : options.body,
                params: keySchema.params
                  ? await parseStandardSchema(
                      keySchema.params,
                      options == null ? void 0 : options.params,
                    )
                  : options == null
                    ? void 0
                    : options.params,
                query: keySchema.query
                  ? await parseStandardSchema(
                      keySchema.query,
                      options == null ? void 0 : options.query,
                    )
                  : options == null
                    ? void 0
                    : options.query,
              });
            }
            return {
              url,
              options: opts,
            };
          }
        }
        return {
          url,
          options,
        };
      },
    });
    var createFetch = (config) => {
      async function $fetch(url, options) {
        const opts = __spreadProps(__spreadValues(__spreadValues({}, config), options), {
          plugins: [
            ...((config == null ? void 0 : config.plugins) || []),
            applySchemaPlugin(config || {}),
            ...((options == null ? void 0 : options.plugins) || []),
          ],
        });
        if (config == null ? void 0 : config.catchAllError) {
          try {
            return await betterFetch(url, opts);
          } catch (error) {
            return {
              data: null,
              error: {
                status: 500,
                statusText: "Fetch Error",
                message:
                  "Fetch related error. Captured by catchAllError option. See error property for more details.",
                error,
              },
            };
          }
        }
        return await betterFetch(url, opts);
      }
      return $fetch;
    };
    // src/url.ts
    function getURL2(url, option) {
      const { baseURL, params, query } = option || {
        query: {},
        params: {},
        baseURL: "",
      };
      let basePath = url.startsWith("http") ? url.split("/").slice(0, 3).join("/") : baseURL || "";
      if (url.startsWith("@")) {
        const m = url.toString().split("@")[1].split("/")[0];
        if (methods.includes(m)) {
          url = url.replace(`@${m}/`, "/");
        }
      }
      if (!basePath.endsWith("/")) basePath += "/";
      let [path, urlQuery] = url.replace(basePath, "").split("?");
      const queryParams = new URLSearchParams(urlQuery);
      for (const [key, value] of Object.entries(query || {})) {
        if (value == null) continue;
        let serializedValue;
        if (typeof value === "string") {
          serializedValue = value;
        } else if (Array.isArray(value)) {
          for (const val of value) {
            queryParams.append(key, val);
          }
          continue;
        } else {
          serializedValue = JSON.stringify(value);
        }
        queryParams.set(key, serializedValue);
      }
      if (params) {
        if (Array.isArray(params)) {
          const paramPaths = path.split("/").filter((p) => p.startsWith(":"));
          for (const [index, key] of paramPaths.entries()) {
            const value = params[index];
            path = path.replace(key, value);
          }
        } else {
          for (const [key, value] of Object.entries(params)) {
            path = path.replace(`:${key}`, String(value));
          }
        }
      }
      path = path.split("/").map(encodeURIComponent).join("/");
      if (path.startsWith("/")) path = path.slice(1);
      let queryParamString = queryParams.toString();
      queryParamString =
        queryParamString.length > 0 ? `?${queryParamString}`.replace(/\+/g, "%20") : "";
      if (!basePath.startsWith("http")) {
        return `${basePath}${path}${queryParamString}`;
      }
      const _url = new URL(`${path}${queryParamString}`, basePath);
      return _url;
    }
    // src/fetch.ts
    var betterFetch = async (url, options) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const { hooks, url: __url, options: opts } = await initializePlugins(url, options);
      const fetch = getFetch(opts);
      const controller = new AbortController();
      const signal = (_a = opts.signal) != null ? _a : controller.signal;
      const _url = getURL2(__url, opts);
      const body = getBody(opts);
      const headers = await getHeaders(opts);
      const method = getMethod(__url, opts);
      let context = __spreadProps(__spreadValues({}, opts), {
        url: _url,
        headers,
        body,
        method,
        signal,
      });
      for (const onRequest of hooks.onRequest) {
        if (onRequest) {
          const res = await onRequest(context);
          if (typeof res === "object" && res !== null) {
            context = res;
          }
        }
      }
      if (
        ("pipeTo" in context && typeof context.pipeTo === "function") ||
        typeof ((_b = options == null ? void 0 : options.body) == null ? void 0 : _b.pipe) ===
          "function"
      ) {
        if (!("duplex" in context)) {
          context.duplex = "half";
        }
      }
      const { clearTimeout: clearTimeout2 } = getTimeout(opts, controller);
      let response = await fetch(context.url, context);
      clearTimeout2();
      const responseContext = {
        response,
        request: context,
      };
      for (const onResponse of hooks.onResponse) {
        if (onResponse) {
          const r = await onResponse(
            __spreadProps(__spreadValues({}, responseContext), {
              response: (
                (_c = options == null ? void 0 : options.hookOptions) == null
                  ? void 0
                  : _c.cloneResponse
              )
                ? response.clone()
                : response,
            }),
          );
          if (r instanceof Response) {
            response = r;
          } else if (typeof r === "object" && r !== null) {
            response = r.response;
          }
        }
      }
      if (response.ok) {
        const hasBody = context.method !== "HEAD";
        if (!hasBody) {
          return {
            data: "",
            error: null,
          };
        }
        const responseType = detectResponseType(response);
        const successContext = {
          data: null,
          response,
          request: context,
        };
        if (responseType === "json" || responseType === "text") {
          const text = await response.text();
          const parser2 = (_d = context.jsonParser) != null ? _d : jsonParse;
          successContext.data = await parser2(text);
        } else {
          successContext.data = await response[responseType]();
        }
        if (context == null ? void 0 : context.output) {
          if (context.output && !context.disableValidation) {
            successContext.data = await parseStandardSchema(context.output, successContext.data);
          }
        }
        for (const onSuccess of hooks.onSuccess) {
          if (onSuccess) {
            await onSuccess(
              __spreadProps(__spreadValues({}, successContext), {
                response: (
                  (_e = options == null ? void 0 : options.hookOptions) == null
                    ? void 0
                    : _e.cloneResponse
                )
                  ? response.clone()
                  : response,
              }),
            );
          }
        }
        if (options == null ? void 0 : options.throw) {
          return successContext.data;
        }
        return {
          data: successContext.data,
          error: null,
        };
      }
      const parser = (_f = options == null ? void 0 : options.jsonParser) != null ? _f : jsonParse;
      const responseText = await response.text();
      const isJSONResponse = isJSONParsable(responseText);
      const errorObject = isJSONResponse ? await parser(responseText) : null;
      const errorContext = {
        response,
        responseText,
        request: context,
        error: __spreadProps(__spreadValues({}, errorObject), {
          status: response.status,
          statusText: response.statusText,
        }),
      };
      for (const onError of hooks.onError) {
        if (onError) {
          await onError(
            __spreadProps(__spreadValues({}, errorContext), {
              response: (
                (_g = options == null ? void 0 : options.hookOptions) == null
                  ? void 0
                  : _g.cloneResponse
              )
                ? response.clone()
                : response,
            }),
          );
        }
      }
      if (options == null ? void 0 : options.retry) {
        const retryStrategy = createRetryStrategy(options.retry);
        const _retryAttempt = (_h = options.retryAttempt) != null ? _h : 0;
        if (await retryStrategy.shouldAttemptRetry(_retryAttempt, response)) {
          for (const onRetry of hooks.onRetry) {
            if (onRetry) {
              await onRetry(responseContext);
            }
          }
          const delay = retryStrategy.getDelay(_retryAttempt);
          await new Promise((resolve) => setTimeout(resolve, delay));
          return await betterFetch(
            url,
            __spreadProps(__spreadValues({}, options), {
              retryAttempt: _retryAttempt + 1,
            }),
          );
        }
      }
      if (options == null ? void 0 : options.throw) {
        throw new BetterFetchError(
          response.status,
          response.statusText,
          isJSONResponse ? errorObject : responseText,
        );
      }
      return {
        data: null,
        error: __spreadProps(__spreadValues({}, errorObject), {
          status: response.status,
          statusText: response.statusText,
        }),
      };
    };
  },
  //# sourceMappingURL=index.js.map
  "[project]/node_modules/clsx/dist/clsx.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["clsx", () => clsx, "default", () => __TURBOPACK__default__export__]);
    function r(e) {
      var t,
        f,
        n = "";
      if ("string" == typeof e || "number" == typeof e) n += e;
      else if ("object" == typeof e)
        if (Array.isArray(e)) {
          var o = e.length;
          for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), (n += f));
        } else for (f in e) e[f] && (n && (n += " "), (n += f));
      return n;
    }
    function clsx() {
      for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++)
        (e = arguments[f]) && (t = r(e)) && (n && (n += " "), (n += t));
      return n;
    }
    const __TURBOPACK__default__export__ = clsx;
  },
  "[project]/node_modules/@base-ui/utils/esm/useRefWithInit.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useRefWithInit", () => useRefWithInit]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    ("use client");
    const UNINITIALIZED = {};
    function useRefWithInit(init, initArg) {
      const ref =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useRef"
        ](UNINITIALIZED);
      if (ref.current === UNINITIALIZED) {
        ref.current = init(initArg);
      }
      return ref;
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/useMergedRefs.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "useMergedRefs",
      () => useMergedRefs,
      "useMergedRefsN",
      () => useMergedRefsN,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useRefWithInit.js [app-client] (ecmascript)",
      );
    function useMergedRefs(a, b, c, d) {
      const forkRef = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useRefWithInit"
      ])(createForkRef).current;
      if (didChange(forkRef, a, b, c, d)) {
        update(forkRef, [a, b, c, d]);
      }
      return forkRef.callback;
    }
    function useMergedRefsN(refs) {
      const forkRef = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useRefWithInit"
      ])(createForkRef).current;
      if (didChangeN(forkRef, refs)) {
        update(forkRef, refs);
      }
      return forkRef.callback;
    }
    function createForkRef() {
      return {
        callback: null,
        cleanup: null,
        refs: [],
      };
    }
    function didChange(forkRef, a, b, c, d) {
      // prettier-ignore
      return forkRef.refs[0] !== a || forkRef.refs[1] !== b || forkRef.refs[2] !== c || forkRef.refs[3] !== d;
    }
    function didChangeN(forkRef, newRefs) {
      return (
        forkRef.refs.length !== newRefs.length ||
        forkRef.refs.some((ref, index) => ref !== newRefs[index])
      );
    }
    function update(forkRef, refs) {
      forkRef.refs = refs;
      if (refs.every((ref) => ref == null)) {
        forkRef.callback = null;
        return;
      }
      forkRef.callback = (instance) => {
        if (forkRef.cleanup) {
          forkRef.cleanup();
          forkRef.cleanup = null;
        }
        if (instance != null) {
          const cleanupCallbacks = Array(refs.length).fill(null);
          for (let i = 0; i < refs.length; i += 1) {
            const ref = refs[i];
            if (ref == null) {
              continue;
            }
            switch (typeof ref) {
              case "function": {
                const refCleanup = ref(instance);
                if (typeof refCleanup === "function") {
                  cleanupCallbacks[i] = refCleanup;
                }
                break;
              }
              case "object": {
                ref.current = instance;
                break;
              }
              default:
            }
          }
          forkRef.cleanup = () => {
            for (let i = 0; i < refs.length; i += 1) {
              const ref = refs[i];
              if (ref == null) {
                continue;
              }
              switch (typeof ref) {
                case "function": {
                  const cleanupCallback = cleanupCallbacks[i];
                  if (typeof cleanupCallback === "function") {
                    cleanupCallback();
                  } else {
                    ref(null);
                  }
                  break;
                }
                case "object": {
                  ref.current = null;
                  break;
                }
                default:
              }
            }
          };
        }
      };
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/reactVersion.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["isReactVersionAtLeast", () => isReactVersionAtLeast]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    const majorVersion = parseInt(
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "version"
      ],
      10,
    );
    function isReactVersionAtLeast(reactVersionToCheck) {
      return majorVersion >= reactVersionToCheck;
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/getReactElementRef.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["getReactElementRef", () => getReactElementRef]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$reactVersion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/reactVersion.js [app-client] (ecmascript)",
      );
    function getReactElementRef(element) {
      if (
        !(
          /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "isValidElement"
          ](element)
        )
      ) {
        return null;
      }
      const reactElement = element;
      const propsWithRef = reactElement.props;
      return (
        ((0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$reactVersion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isReactVersionAtLeast"
        ])(19)
          ? propsWithRef?.ref
          : reactElement.ref) ?? null
      );
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/mergeObjects.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["mergeObjects", () => mergeObjects]);
    function mergeObjects(a, b) {
      if (a && !b) {
        return a;
      }
      if (!a && b) {
        return b;
      }
      if (a || b) {
        return {
          ...a,
          ...b,
        };
      }
      return undefined;
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/empty.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "EMPTY_ARRAY",
      () => EMPTY_ARRAY,
      "EMPTY_OBJECT",
      () => EMPTY_OBJECT,
      "NOOP",
      () => NOOP,
    ]);
    function NOOP() {}
    const EMPTY_ARRAY = Object.freeze([]);
    const EMPTY_OBJECT = Object.freeze({});
  },
  "[project]/node_modules/@base-ui/utils/esm/useStableCallback.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useStableCallback", () => useStableCallback]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useRefWithInit.js [app-client] (ecmascript)",
      );
    ("use client");
    // https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379
    const useInsertionEffect =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        `useInsertionEffect${Math.random().toFixed(1)}`.slice(0, -3)
      ];
    const useSafeInsertionEffect = // React 17 doesn't have useInsertionEffect.
      useInsertionEffect && // Preact replaces useInsertionEffect with useLayoutEffect and fires too late.
      useInsertionEffect !==
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.useLayoutEffect
        ? useInsertionEffect
        : (fn) => fn();
    function useStableCallback(callback) {
      const stable = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useRefWithInit"
      ])(createStableCallback).current;
      stable.next = callback;
      useSafeInsertionEffect(stable.effect);
      return stable.trampoline;
    }
    function createStableCallback() {
      const stable = {
        next: undefined,
        callback: assertNotCalled,
        trampoline: (...args) => stable.callback?.(...args),
        effect: () => {
          stable.callback = stable.next;
        },
      };
      return stable;
    }
    function assertNotCalled() {
      if (("TURBOPACK compile-time truthy", 1)) {
        throw /* minify-error-disabled */ new Error(
          "Base UI: Cannot call an event handler while rendering.",
        );
      }
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/useControlled.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useControlled", () => useControlled]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler -- process.env never changes, dependency arrays are intentionally ignored
    /* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    ("use client");
    function useControlled({ controlled, default: defaultProp, name, state = "value" }) {
      // isControlled is ignored in the hook dependency lists as it should never change.
      const { current: isControlled } =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useRef"
        ](controlled !== undefined);
      const [valueState, setValue] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useState"
        ](defaultProp);
      const value = isControlled ? controlled : valueState;
      if (("TURBOPACK compile-time truthy", 1)) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useEffect"
        ](
          {
            "useControlled.useEffect": () => {
              if (isControlled !== (controlled !== undefined)) {
                console.error(
                  [
                    `Base UI: A component is changing the ${isControlled ? "" : "un"}controlled ${state} state of ${name} to be ${isControlled ? "un" : ""}controlled.`,
                    "Elements should not switch from uncontrolled to controlled (or vice versa).",
                    `Decide between using a controlled or uncontrolled ${name} ` +
                      "element for the lifetime of the component.",
                    "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.",
                    "More info: https://fb.me/react-controlled-components",
                  ].join("\n"),
                );
              }
            },
          }["useControlled.useEffect"],
          [state, name, controlled],
        );
        const { current: defaultValue } =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "useRef"
          ](defaultProp);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useEffect"
        ](
          {
            "useControlled.useEffect": () => {
              // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is for more details.
              if (!isControlled && JSON.stringify(defaultValue) !== JSON.stringify(defaultProp)) {
                console.error(
                  [
                    `Base UI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. ` +
                      `To suppress this warning opt to use a controlled ${name}.`,
                  ].join("\n"),
                );
              }
            },
          }["useControlled.useEffect"],
          [JSON.stringify(defaultProp)],
        );
      }
      const setValueIfUncontrolled =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useCallback"
        ](
          {
            "useControlled.useCallback[setValueIfUncontrolled]": (newValue) => {
              if (!isControlled) {
                setValue(newValue);
              }
            },
          }["useControlled.useCallback[setValueIfUncontrolled]"],
          [],
        );
      return [value, setValueIfUncontrolled];
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/error.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["error", () => error, "reset", () => reset]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    let set;
    if (("TURBOPACK compile-time truthy", 1)) {
      set = new Set();
    }
    function error(...messages) {
      if (("TURBOPACK compile-time truthy", 1)) {
        const messageKey = messages.join(" ");
        if (!set.has(messageKey)) {
          set.add(messageKey);
          console.error(`Base UI: ${messageKey}`);
        }
      }
    }
    function reset() {
      set?.clear();
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/safeReact.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["SafeReact", () => SafeReact]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    const SafeReact = {
      ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    };
  },
  "[project]/node_modules/@base-ui/utils/esm/useIsoLayoutEffect.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useIsoLayoutEffect", () => useIsoLayoutEffect]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    ("use client");
    const noop = () => {};
    const useIsoLayoutEffect =
      typeof document !== "undefined"
        ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "useLayoutEffect"
          ]
        : noop;
  },
  "[project]/node_modules/@base-ui/utils/esm/useId.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useId", () => useId]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$safeReact$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/safeReact.js [app-client] (ecmascript)",
      );
    ("use client");
    let globalId = 0;
    // TODO React 17: Remove `useGlobalId` once React 17 support is removed
    function useGlobalId(idOverride, prefix = "mui") {
      const [defaultId, setDefaultId] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useState"
        ](idOverride);
      const id = idOverride || defaultId;
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "useGlobalId.useEffect": () => {
            if (defaultId == null) {
              // Fallback to this default id when possible.
              // Use the incrementing value for client-side rendering only.
              // We can't use it server-side.
              // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem
              globalId += 1;
              setDefaultId(`${prefix}-${globalId}`);
            }
          },
        }["useGlobalId.useEffect"],
        [defaultId, prefix],
      );
      return id;
    }
    const maybeReactUseId =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$safeReact$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "SafeReact"
      ].useId;
    function useId(idOverride, prefix) {
      // React.useId() is only available from React 17.0.0.
      if (maybeReactUseId !== undefined) {
        const reactId = maybeReactUseId();
        return idOverride ?? (prefix ? `${prefix}-${reactId}` : reactId);
      }
      // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler
      // eslint-disable-next-line react-hooks/rules-of-hooks -- `React.useId` is invariant at runtime.
      return useGlobalId(idOverride, prefix);
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/useOnMount.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useOnMount", () => useOnMount]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    ("use client");
    const EMPTY = [];
    function useOnMount(fn) {
      // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler -- no need to put `fn` in the dependency array
      /* eslint-disable react-hooks/exhaustive-deps */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](fn, EMPTY);
      /* eslint-enable react-hooks/exhaustive-deps */
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/useAnimationFrame.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "AnimationFrame",
      () => AnimationFrame,
      "useAnimationFrame",
      () => useAnimationFrame,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useRefWithInit.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useOnMount$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useOnMount.js [app-client] (ecmascript)",
      );
    ("use client");
    /** Unlike `setTimeout`, rAF doesn't guarantee a positive integer return value, so we can't have
     * a monomorphic `uint` type with `0` meaning empty.
     * See warning note at:
     * https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame#return_value */ const EMPTY =
      null;
    let LAST_RAF = globalThis.requestAnimationFrame;
    class Scheduler {
      /* This implementation uses an array as a backing data-structure for frame callbacks.
       * It allows `O(1)` callback cancelling by inserting a `null` in the array, though it
       * never calls the native `cancelAnimationFrame` if there are no frames left. This can
       * be much more efficient if there is a call pattern that alterns as
       * "request-cancel-request-cancel-…".
       * But in the case of "request-request-…-cancel-cancel-…", it leaves the final animation
       * frame to run anyway. We turn that frame into a `O(1)` no-op via `callbacksCount`. */ callbacks =
        [];
      callbacksCount = 0;
      nextId = 1;
      startId = 1;
      isScheduled = false;
      tick = (timestamp) => {
        this.isScheduled = false;
        const currentCallbacks = this.callbacks;
        const currentCallbacksCount = this.callbacksCount;
        // Update these before iterating, callbacks could call `requestAnimationFrame` again.
        this.callbacks = [];
        this.callbacksCount = 0;
        this.startId = this.nextId;
        if (currentCallbacksCount > 0) {
          for (let i = 0; i < currentCallbacks.length; i += 1) {
            currentCallbacks[i]?.(timestamp);
          }
        }
      };
      request(fn) {
        const id = this.nextId;
        this.nextId += 1;
        this.callbacks.push(fn);
        this.callbacksCount += 1;
        /* In a test environment with fake timers, a fake `requestAnimationFrame` can be called
         * but there's no guarantee that the animation frame will actually run before the fake
         * timers are teared, which leaves `isScheduled` set, but won't run our `tick()`. */ const didRAFChange =
          ("TURBOPACK compile-time value", "development") !== "production" &&
          LAST_RAF !== requestAnimationFrame &&
          ((LAST_RAF = requestAnimationFrame), true);
        if (!this.isScheduled || didRAFChange) {
          requestAnimationFrame(this.tick);
          this.isScheduled = true;
        }
        return id;
      }
      cancel(id) {
        const index = id - this.startId;
        if (index < 0 || index >= this.callbacks.length) {
          return;
        }
        this.callbacks[index] = null;
        this.callbacksCount -= 1;
      }
    }
    const scheduler = new Scheduler();
    class AnimationFrame {
      static create() {
        return new AnimationFrame();
      }
      static request(fn) {
        return scheduler.request(fn);
      }
      static cancel(id) {
        return scheduler.cancel(id);
      }
      currentId = EMPTY;
      /**
       * Executes `fn` after `delay`, clearing any previously scheduled call.
       */ request(fn) {
        this.cancel();
        this.currentId = scheduler.request(() => {
          this.currentId = EMPTY;
          fn();
        });
      }
      cancel = () => {
        if (this.currentId !== EMPTY) {
          scheduler.cancel(this.currentId);
          this.currentId = EMPTY;
        }
      };
      disposeEffect = () => {
        return this.cancel;
      };
    }
    function useAnimationFrame() {
      const timeout = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useRefWithInit"
      ])(AnimationFrame.create).current;
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useOnMount$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useOnMount"
      ])(timeout.disposeEffect);
      return timeout;
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/useValueAsRef.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useValueAsRef", () => useValueAsRef]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useIsoLayoutEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useIsoLayoutEffect.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useRefWithInit.js [app-client] (ecmascript)",
      );
    ("use client");
    function useValueAsRef(value) {
      const latest = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useRefWithInit"
      ])(createLatestRef, value).current;
      latest.next = value;
      // eslint-disable-next-line react-hooks/exhaustive-deps
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useIsoLayoutEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useIsoLayoutEffect"
      ])(latest.effect);
      return latest;
    }
    function createLatestRef(value) {
      const latest = {
        current: value,
        next: value,
        effect: () => {
          latest.current = latest.next;
        },
      };
      return latest;
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/visuallyHidden.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "visuallyHidden",
      () => visuallyHidden,
      "visuallyHiddenInput",
      () => visuallyHiddenInput,
    ]);
    const visuallyHiddenBase = {
      clipPath: "inset(50%)",
      overflow: "hidden",
      whiteSpace: "nowrap",
      border: 0,
      padding: 0,
      width: 1,
      height: 1,
      margin: -1,
    };
    const visuallyHidden = {
      ...visuallyHiddenBase,
      position: "fixed",
      top: 0,
      left: 0,
    };
    const visuallyHiddenInput = {
      ...visuallyHiddenBase,
      position: "absolute",
    };
  },
  "[project]/node_modules/@base-ui/utils/esm/useTimeout.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["Timeout", () => Timeout, "useTimeout", () => useTimeout]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useRefWithInit.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useOnMount$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useOnMount.js [app-client] (ecmascript)",
      );
    ("use client");
    const EMPTY = 0;
    class Timeout {
      static create() {
        return new Timeout();
      }
      currentId = EMPTY;
      /**
       * Executes `fn` after `delay`, clearing any previously scheduled call.
       */ start(delay, fn) {
        this.clear();
        this.currentId = setTimeout(() => {
          this.currentId = EMPTY;
          fn();
        }, delay); /* Node.js types are enabled in development */
      }
      isStarted() {
        return this.currentId !== EMPTY;
      }
      clear = () => {
        if (this.currentId !== EMPTY) {
          clearTimeout(this.currentId);
          this.currentId = EMPTY;
        }
      };
      disposeEffect = () => {
        return this.clear;
      };
    }
    function useTimeout() {
      const timeout = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useRefWithInit"
      ])(Timeout.create).current;
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useOnMount$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useOnMount"
      ])(timeout.disposeEffect);
      return timeout;
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/detectBrowser.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "isAndroid",
      () => isAndroid,
      "isEdge",
      () => isEdge,
      "isFirefox",
      () => isFirefox,
      "isIOS",
      () => isIOS,
      "isJSDOM",
      () => isJSDOM,
      "isMac",
      () => isMac,
      "isSafari",
      () => isSafari,
      "isWebKit",
      () => isWebKit,
    ]);
    const hasNavigator = typeof navigator !== "undefined";
    const nav = getNavigatorData();
    const platform = getPlatform();
    const userAgent = getUserAgent();
    const isWebKit =
      typeof CSS === "undefined" || !CSS.supports
        ? false
        : CSS.supports("-webkit-backdrop-filter:none");
    const isIOS = // iPads can claim to be MacIntel
      nav.platform === "MacIntel" && nav.maxTouchPoints > 1
        ? true
        : /iP(hone|ad|od)|iOS/.test(nav.platform);
    const isFirefox = hasNavigator && /firefox/i.test(userAgent);
    const isSafari = hasNavigator && /apple/i.test(navigator.vendor);
    const isEdge = hasNavigator && /Edg/i.test(userAgent);
    const isAndroid = (hasNavigator && /android/i.test(platform)) || /android/i.test(userAgent);
    const isMac =
      hasNavigator && platform.toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
    const isJSDOM = userAgent.includes("jsdom/");
    // Avoid Chrome DevTools blue warning.
    function getNavigatorData() {
      if (!hasNavigator) {
        return {
          platform: "",
          maxTouchPoints: -1,
        };
      }
      const uaData = navigator.userAgentData;
      if (uaData?.platform) {
        return {
          platform: uaData.platform,
          maxTouchPoints: navigator.maxTouchPoints,
        };
      }
      return {
        platform: navigator.platform ?? "",
        maxTouchPoints: navigator.maxTouchPoints ?? -1,
      };
    }
    function getUserAgent() {
      if (!hasNavigator) {
        return "";
      }
      const uaData = navigator.userAgentData;
      if (uaData && Array.isArray(uaData.brands)) {
        return uaData.brands.map(({ brand, version }) => `${brand}/${version}`).join(" ");
      }
      return navigator.userAgent;
    }
    function getPlatform() {
      if (!hasNavigator) {
        return "";
      }
      const uaData = navigator.userAgentData;
      if (uaData?.platform) {
        return uaData.platform;
      }
      return navigator.platform ?? "";
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/owner.js [app-client] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["ownerDocument", () => ownerDocument]);
    function ownerDocument(node) {
      return node?.ownerDocument || document;
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/inertValue.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["inertValue", () => inertValue]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$reactVersion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/reactVersion.js [app-client] (ecmascript)",
      );
    function inertValue(value) {
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$reactVersion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isReactVersionAtLeast"
        ])(19)
      ) {
        return value;
      }
      // compatibility with React < 19
      return value ? "true" : undefined;
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/store/createSelector.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "createSelector",
      () => createSelector,
      "createSelectorMemoized",
      () => createSelectorMemoized,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$reselect$2f$dist$2f$reselect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/reselect/dist/reselect.mjs [app-client] (ecmascript)",
      );
    /* eslint-disable no-underscore-dangle */ // __cacheKey__
    const reselectCreateSelector = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$reselect$2f$dist$2f$reselect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "createSelectorCreator"
    ])({
      memoize:
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$reselect$2f$dist$2f$reselect$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "lruMemoize"
        ],
      memoizeOptions: {
        maxSize: 1,
        equalityCheck: Object.is,
      },
    });
    const createSelector = (a, b, c, d, e, f, ...other) => {
      if (other.length > 0) {
        throw new Error(
          ("TURBOPACK compile-time truthy", 1)
            ? "Unsupported number of selectors"
            : "TURBOPACK unreachable",
        );
      }
      let selector;
      if (a && b && c && d && e && f) {
        selector = (state, a1, a2, a3) => {
          const va = a(state, a1, a2, a3);
          const vb = b(state, a1, a2, a3);
          const vc = c(state, a1, a2, a3);
          const vd = d(state, a1, a2, a3);
          const ve = e(state, a1, a2, a3);
          return f(va, vb, vc, vd, ve, a1, a2, a3);
        };
      } else if (a && b && c && d && e) {
        selector = (state, a1, a2, a3) => {
          const va = a(state, a1, a2, a3);
          const vb = b(state, a1, a2, a3);
          const vc = c(state, a1, a2, a3);
          const vd = d(state, a1, a2, a3);
          return e(va, vb, vc, vd, a1, a2, a3);
        };
      } else if (a && b && c && d) {
        selector = (state, a1, a2, a3) => {
          const va = a(state, a1, a2, a3);
          const vb = b(state, a1, a2, a3);
          const vc = c(state, a1, a2, a3);
          return d(va, vb, vc, a1, a2, a3);
        };
      } else if (a && b && c) {
        selector = (state, a1, a2, a3) => {
          const va = a(state, a1, a2, a3);
          const vb = b(state, a1, a2, a3);
          return c(va, vb, a1, a2, a3);
        };
      } else if (a && b) {
        selector = (state, a1, a2, a3) => {
          const va = a(state, a1, a2, a3);
          return b(va, a1, a2, a3);
        };
      } else if (a) {
        selector = a;
      } else {
        throw /* minify-error-disabled */ new Error("Missing arguments");
      }
      return selector;
    };
    const createSelectorMemoized = (...selectors) => {
      const cache = new WeakMap();
      let nextCacheId = 1;
      const combiner = selectors[selectors.length - 1];
      const nSelectors = selectors.length - 1 || 1;
      // (s1, s2, ..., sN, a1, a2, a3) => { ... }
      const argsLength = combiner.length - nSelectors;
      if (argsLength > 3) {
        throw new Error(
          ("TURBOPACK compile-time truthy", 1)
            ? "Unsupported number of arguments"
            : "TURBOPACK unreachable",
        );
      }
      const selector = (state, a1, a2, a3) => {
        let cacheKey = state.__cacheKey__;
        if (!cacheKey) {
          cacheKey = {
            id: nextCacheId,
          };
          state.__cacheKey__ = cacheKey;
          nextCacheId += 1;
        }
        let fn = cache.get(cacheKey);
        if (!fn) {
          let reselectArgs = selectors;
          const selectorArgs = [undefined, undefined, undefined];
          switch (argsLength) {
            case 0:
              break;
            case 1: {
              reselectArgs = [...selectors.slice(0, -1), () => selectorArgs[0], combiner];
              break;
            }
            case 2: {
              reselectArgs = [
                ...selectors.slice(0, -1),
                () => selectorArgs[0],
                () => selectorArgs[1],
                combiner,
              ];
              break;
            }
            case 3: {
              reselectArgs = [
                ...selectors.slice(0, -1),
                () => selectorArgs[0],
                () => selectorArgs[1],
                () => selectorArgs[2],
                combiner,
              ];
              break;
            }
            default:
              throw new Error(
                ("TURBOPACK compile-time truthy", 1)
                  ? "Unsupported number of arguments"
                  : "TURBOPACK unreachable",
              );
          }
          fn = reselectCreateSelector(...reselectArgs);
          fn.selectorArgs = selectorArgs;
          cache.set(cacheKey, fn);
        }
        fn.selectorArgs[0] = a1;
        fn.selectorArgs[1] = a2;
        fn.selectorArgs[2] = a3;
        // prettier-ignore
        switch(argsLength){
            case 0:
                return fn(state);
            case 1:
                return fn(state, a1);
            case 2:
                return fn(state, a1, a2);
            case 3:
                return fn(state, a1, a2, a3);
            default:
                throw /* minify-error-disabled */ new Error('unreachable');
        }
      };
      return selector;
    };
  },
  "[project]/node_modules/@base-ui/utils/esm/fastHooks.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "fastComponent",
      () => fastComponent,
      "fastComponentRef",
      () => fastComponentRef,
      "getInstance",
      () => getInstance,
      "register",
      () => register,
      "setInstance",
      () => setInstance,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useRefWithInit.js [app-client] (ecmascript)",
      );
    const hooks = [];
    let currentInstance = undefined;
    function getInstance() {
      return currentInstance;
    }
    function setInstance(instance) {
      currentInstance = instance;
    }
    function register(hook) {
      hooks.push(hook);
    }
    function fastComponent(fn) {
      const FastComponent = (props, forwardedRef) => {
        const instance = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useRefWithInit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useRefWithInit"
        ])(createInstance).current;
        let result;
        try {
          currentInstance = instance;
          for (const hook of hooks) {
            hook.before(instance);
          }
          result = fn(props, forwardedRef);
          for (const hook of hooks) {
            hook.after(instance);
          }
          instance.didInitialize = true;
        } finally {
          currentInstance = undefined;
        }
        return result;
      };
      FastComponent.displayName = fn.displayName || fn.name;
      return FastComponent;
    }
    function fastComponentRef(fn) {
      return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "forwardRef"
      ](fastComponent(fn));
    }
    function createInstance() {
      return {
        didInitialize: false,
      };
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/store/useStore.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useStore", () => useStore]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    /* We need to import the shim because React 17 does not support the `useSyncExternalStore` API.
     * More info: https://github.com/mui/mui-x/issues/18303#issuecomment-2958392341 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/use-sync-external-store/shim/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/use-sync-external-store/shim/with-selector.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$reactVersion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/reactVersion.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$fastHooks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/fastHooks.js [app-client] (ecmascript)",
      );
    /* Some tests fail in R18 with the raw useSyncExternalStore. It may be possible to make it work
     * but for now we only enable it for R19+. */ const canUseRawUseSyncExternalStore = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$reactVersion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "isReactVersionAtLeast"
    ])(19);
    const useStoreImplementation = canUseRawUseSyncExternalStore ? useStoreFast : useStoreLegacy;
    function useStore(store, selector, a1, a2, a3) {
      return useStoreImplementation(store, selector, a1, a2, a3);
    }
    function useStoreR19(store, selector, a1, a2, a3) {
      const getSelection =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useCallback"
        ](
          {
            "useStoreR19.useCallback[getSelection]": () =>
              selector(store.getSnapshot(), a1, a2, a3),
          }["useStoreR19.useCallback[getSelection]"],
          [store, selector, a1, a2, a3],
        );
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useSyncExternalStore"
      ])(store.subscribe, getSelection, getSelection);
    }
    (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$fastHooks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "register"
    ])({
      before(instance) {
        instance.syncIndex = 0;
        if (!instance.didInitialize) {
          instance.syncTick = 1;
          instance.syncHooks = [];
          instance.didChangeStore = true;
          instance.getSnapshot = () => {
            let didChange = false;
            for (let i = 0; i < instance.syncHooks.length; i += 1) {
              const hook = instance.syncHooks[i];
              const value = hook.selector(hook.store.state, hook.a1, hook.a2, hook.a3);
              if (hook.didChange || !Object.is(hook.value, value)) {
                didChange = true;
                hook.value = value;
                hook.didChange = false;
              }
            }
            if (didChange) {
              instance.syncTick += 1;
            }
            return instance.syncTick;
          };
        }
      },
      after(instance) {
        if (instance.syncHooks.length > 0) {
          if (instance.didChangeStore) {
            instance.didChangeStore = false;
            instance.subscribe = (onStoreChange) => {
              const stores = new Set();
              for (const hook of instance.syncHooks) {
                stores.add(hook.store);
              }
              const unsubscribes = [];
              for (const store of stores) {
                unsubscribes.push(store.subscribe(onStoreChange));
              }
              return () => {
                for (const unsubscribe of unsubscribes) {
                  unsubscribe();
                }
              };
            };
          }
          // eslint-disable-next-line react-hooks/rules-of-hooks
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "useSyncExternalStore"
          ])(instance.subscribe, instance.getSnapshot, instance.getSnapshot);
        }
      },
    });
    function useStoreFast(store, selector, a1, a2, a3) {
      const instance = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$fastHooks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getInstance"
      ])();
      if (!instance) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        return useStoreR19(store, selector, a1, a2, a3);
      }
      const index = instance.syncIndex;
      instance.syncIndex += 1;
      let hook;
      if (!instance.didInitialize) {
        hook = {
          store,
          selector,
          a1,
          a2,
          a3,
          value: selector(store.getSnapshot(), a1, a2, a3),
          didChange: false,
        };
        instance.syncHooks.push(hook);
      } else {
        hook = instance.syncHooks[index];
        if (
          hook.store !== store ||
          hook.selector !== selector ||
          !Object.is(hook.a1, a1) ||
          !Object.is(hook.a2, a2) ||
          !Object.is(hook.a3, a3)
        ) {
          if (hook.store !== store) {
            instance.didChangeStore = true;
          }
          hook.store = store;
          hook.selector = selector;
          hook.a1 = a1;
          hook.a2 = a2;
          hook.a3 = a3;
          hook.didChange = true;
        }
      }
      return hook.value;
    }
    function useStoreLegacy(store, selector, a1, a2, a3) {
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$with$2d$selector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useSyncExternalStoreWithSelector"
      ])(
        store.subscribe,
        store.getSnapshot,
        store.getSnapshot,
        {
          "useStoreLegacy.useSyncExternalStoreWithSelector": (state) => selector(state, a1, a2, a3),
        }["useStoreLegacy.useSyncExternalStoreWithSelector"],
      );
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/store/Store.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["Store", () => Store]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$store$2f$useStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/store/useStore.js [app-client] (ecmascript)",
      );
    class Store {
      /**
       * The current state of the store.
       * This property is updated immediately when the state changes as a result of calling {@link setState}, {@link update}, or {@link set}.
       * To subscribe to state changes, use the {@link useState} method. The value returned by {@link useState} is updated after the component renders (similarly to React's useState).
       * The values can be used directly (to avoid subscribing to the store) in effects or event handlers.
       *
       * Do not modify properties in state directly. Instead, use the provided methods to ensure proper state management and listener notification.
       */ // Internal state to handle recursive `setState()` calls
      constructor(state) {
        this.state = state;
        this.listeners = new Set();
        this.updateTick = 0;
      }
      /**
       * Registers a listener that will be called whenever the store's state changes.
       *
       * @param fn The listener function to be called on state changes.
       * @returns A function to unsubscribe the listener.
       */ subscribe = (fn) => {
        this.listeners.add(fn);
        return () => {
          this.listeners.delete(fn);
        };
      };
      /**
       * Returns the current state of the store.
       */ getSnapshot = () => {
        return this.state;
      };
      /**
       * Updates the entire store's state and notifies all registered listeners.
       *
       * @param newState The new state to set for the store.
       */ setState(newState) {
        if (this.state === newState) {
          return;
        }
        this.state = newState;
        this.updateTick += 1;
        const currentTick = this.updateTick;
        for (const listener of this.listeners) {
          if (currentTick !== this.updateTick) {
            // If the tick has changed, a recursive `setState` call has been made,
            // and it has already notified all listeners.
            return;
          }
          listener(newState);
        }
      }
      /**
       * Merges the provided changes into the current state and notifies listeners if there are changes.
       *
       * @param changes An object containing the changes to apply to the current state.
       */ update(changes) {
        for (const key in changes) {
          if (!Object.is(this.state[key], changes[key])) {
            this.setState({
              ...this.state,
              ...changes,
            });
            return;
          }
        }
      }
      /**
       * Sets a specific key in the store's state to a new value and notifies listeners if the value has changed.
       *
       * @param key The key in the store's state to update.
       * @param value The new value to set for the specified key.
       */ set(key, value) {
        if (!Object.is(this.state[key], value)) {
          this.setState({
            ...this.state,
            [key]: value,
          });
        }
      }
      /**
       * Gives the state a new reference and updates all registered listeners.
       */ notifyAll() {
        const newState = {
          ...this.state,
        };
        this.setState(newState);
      }
      use(selector, a1, a2, a3) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$store$2f$useStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useStore"
        ])(this, selector, a1, a2, a3);
      }
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/store/ReactStore.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["ReactStore", () => ReactStore]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$store$2f$Store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/store/Store.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$store$2f$useStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/store/useStore.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useStableCallback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useStableCallback.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useIsoLayoutEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useIsoLayoutEffect.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/empty.js [app-client] (ecmascript)",
      );
    /* False positives - ESLint thinks we're calling a hook from a class component. */ /* eslint-disable react-hooks/rules-of-hooks */ ("use client");
    class ReactStore
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$store$2f$Store$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "Store"
      ]
    {
      /**
       * Creates a new ReactStore instance.
       *
       * @param state Initial state of the store.
       * @param context Non-reactive context values.
       * @param selectors Optional selectors for use with `useState`.
       */ constructor(state, context = {}, selectors) {
        super(state);
        this.context = context;
        this.selectors = selectors;
      }
      /**
       * Non-reactive values such as refs, callbacks, etc.
       */ /**
       * Synchronizes a single external value into the store.
       *
       * Note that the while the value in `state` is updated immediately, the value returned
       * by `useState` is updated before the next render (similarly to React's `useState`).
       */ useSyncedValue(key, value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useDebugValue"
        ](key);
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useIsoLayoutEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useIsoLayoutEffect"
        ])(() => {
          if (this.state[key] !== value) {
            this.set(key, value);
          }
        }, [key, value]);
      }
      /**
       * Synchronizes a single external value into the store and
       * cleans it up (sets to `undefined`) on unmount.
       *
       * Note that the while the value in `state` is updated immediately, the value returned
       * by `useState` is updated before the next render (similarly to React's `useState`).
       */ useSyncedValueWithCleanup(key, value) {
        // eslint-disable-next-line consistent-this
        const store = this;
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useIsoLayoutEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useIsoLayoutEffect"
        ])(() => {
          if (store.state[key] !== value) {
            store.set(key, value);
          }
          return () => {
            store.set(key, undefined);
          };
        }, [store, key, value]);
      }
      /**
       * Synchronizes multiple external values into the store.
       *
       * Note that the while the values in `state` are updated immediately, the values returned
       * by `useState` are updated before the next render (similarly to React's `useState`).
       */ useSyncedValues(statePart) {
        // eslint-disable-next-line consistent-this
        const store = this;
        if (("TURBOPACK compile-time truthy", 1)) {
          // Check that an object with the same shape is passed on every render
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "useDebugValue"
          ](statePart, (p) => Object.keys(p));
          const keys =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "useRef"
            ](Object.keys(statePart)).current;
          const nextKeys = Object.keys(statePart);
          if (
            keys.length !== nextKeys.length ||
            keys.some((key, index) => key !== nextKeys[index])
          ) {
            console.error(
              "ReactStore.useSyncedValues expects the same prop keys on every render. Keys should be stable.",
            );
          }
        }
        const dependencies = Object.values(statePart);
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useIsoLayoutEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useIsoLayoutEffect"
        ])(() => {
          store.update(statePart);
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, [store, ...dependencies]);
      }
      /**
       * Registers a controllable prop pair (`controlled`, `defaultValue`) for a specific key. If `controlled`
       * is non-undefined, the store's state at `key` is updated to match `controlled`.
       */ useControlledProp(key, controlled) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useDebugValue"
        ](key);
        const isControlled = controlled !== undefined;
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useIsoLayoutEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useIsoLayoutEffect"
        ])(() => {
          if (isControlled && !Object.is(this.state[key], controlled)) {
            // Set the internal state to match the controlled value.
            super.setState({
              ...this.state,
              [key]: controlled,
            });
          }
        }, [key, controlled, isControlled]);
        if (("TURBOPACK compile-time truthy", 1)) {
          // eslint-disable-next-line
          const cache = (this.controlledValues ??= new Map());
          if (!cache.has(key)) {
            cache.set(key, isControlled);
          }
          const previouslyControlled = cache.get(key);
          if (previouslyControlled !== undefined && previouslyControlled !== isControlled) {
            console.error(
              `A component is changing the ${isControlled ? "" : "un"}controlled state of ${key.toString()} to be ${isControlled ? "un" : ""}controlled. Elements should not switch from uncontrolled to controlled (or vice versa).`,
            );
          }
        }
      }
      /** Gets the current value from the store using a selector with the provided key.
       *
       * @param key Key of the selector to use.
       */ select(key, a1, a2, a3) {
        const selector = this.selectors[key];
        return selector(this.state, a1, a2, a3);
      }
      /**
       * Returns a value from the store's state using a selector function.
       * Used to subscribe to specific parts of the state.
       * This methods causes a rerender whenever the selected state changes.
       *
       * @param key Key of the selector to use.
       */ useState(key, a1, a2, a3) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useDebugValue"
        ](key);
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$store$2f$useStore$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useStore"
        ])(this, this.selectors[key], a1, a2, a3);
      }
      /**
       * Wraps a function with `useStableCallback` to ensure it has a stable reference
       * and assigns it to the context.
       *
       * @param key Key of the event callback. Must be a function in the context.
       * @param fn Function to assign.
       */ useContextCallback(key, fn) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useDebugValue"
        ](key);
        const stableFunction = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useStableCallback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useStableCallback"
        ])(
          fn ??
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "NOOP"
            ],
        );
        this.context[key] = stableFunction;
      }
      /**
       * Returns a stable setter function for a specific key in the store's state.
       * It's commonly used to pass as a ref callback to React elements.
       *
       * @param key Key of the state to set.
       */ useStateSetter(key) {
        const ref =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "useRef"
          ](undefined);
        if (ref.current === undefined) {
          ref.current = (value) => {
            this.set(key, value);
          };
        }
        return ref.current;
      }
      /**
       * Observes changes derived from the store's selectors and calls the listener when the selected value changes.
       *
       * @param key Key of the selector to observe.
       * @param listener Listener function called when the selector result changes.
       */ observe(selector, listener) {
        let selectFn;
        if (typeof selector === "function") {
          selectFn = selector;
        } else {
          selectFn = this.selectors[selector];
        }
        let prevValue = selectFn(this.state);
        listener(prevValue, prevValue, this);
        return this.subscribe((nextState) => {
          const nextValue = selectFn(nextState);
          if (!Object.is(prevValue, nextValue)) {
            const oldValue = prevValue;
            prevValue = nextValue;
            listener(nextValue, oldValue, this);
          }
        });
      }
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/useOnFirstRender.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useOnFirstRender", () => useOnFirstRender]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    ("use client");
    function useOnFirstRender(fn) {
      const ref =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useRef"
        ](true);
      if (ref.current) {
        ref.current = false;
        fn();
      }
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/useScrollLock.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useScrollLock", () => useScrollLock]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$detectBrowser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/detectBrowser.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$owner$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/owner.js [app-client] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__getWindow__as__ownerWindow$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs [app-client] (ecmascript) <export getWindow as ownerWindow>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useIsoLayoutEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useIsoLayoutEffect.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useTimeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useTimeout.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useAnimationFrame$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/useAnimationFrame.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@base-ui/utils/esm/empty.js [app-client] (ecmascript)",
      );
    ("use client");
    let originalHtmlStyles = {};
    let originalBodyStyles = {};
    let originalHtmlScrollBehavior = "";
    function hasInsetScrollbars(referenceElement) {
      if (typeof document === "undefined") {
        return false;
      }
      const doc = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$owner$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "ownerDocument"
      ])(referenceElement);
      const win = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__getWindow__as__ownerWindow$3e$__[
        "ownerWindow"
      ])(doc);
      return win.innerWidth - doc.documentElement.clientWidth > 0;
    }
    function supportsStableScrollbarGutter(referenceElement) {
      const supported =
        typeof CSS !== "undefined" && CSS.supports && CSS.supports("scrollbar-gutter", "stable");
      if (!supported || typeof document === "undefined") {
        return false;
      }
      const doc = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$owner$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "ownerDocument"
      ])(referenceElement);
      const html = doc.documentElement;
      const body = doc.body;
      const scrollContainer = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "isOverflowElement"
      ])(html)
        ? html
        : body;
      const originalScrollContainerOverflowY = scrollContainer.style.overflowY;
      const originalHtmlStyleGutter = html.style.scrollbarGutter;
      html.style.scrollbarGutter = "stable";
      scrollContainer.style.overflowY = "scroll";
      const before = scrollContainer.offsetWidth;
      scrollContainer.style.overflowY = "hidden";
      const after = scrollContainer.offsetWidth;
      scrollContainer.style.overflowY = originalScrollContainerOverflowY;
      html.style.scrollbarGutter = originalHtmlStyleGutter;
      return before === after;
    }
    function preventScrollOverlayScrollbars(referenceElement) {
      const doc = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$owner$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "ownerDocument"
      ])(referenceElement);
      const html = doc.documentElement;
      const body = doc.body;
      // If an `overflow` style is present on <html>, we need to lock it, because a lock on <body>
      // won't have any effect.
      // But if <body> has an `overflow` style (like `overflow-x: hidden`), we need to lock it
      // instead, as sticky elements shift otherwise.
      const elementToLock = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "isOverflowElement"
      ])(html)
        ? html
        : body;
      const originalElementToLockStyles = {
        overflowY: elementToLock.style.overflowY,
        overflowX: elementToLock.style.overflowX,
      };
      Object.assign(elementToLock.style, {
        overflowY: "hidden",
        overflowX: "hidden",
      });
      return () => {
        Object.assign(elementToLock.style, originalElementToLockStyles);
      };
    }
    function preventScrollInsetScrollbars(referenceElement) {
      const doc = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$owner$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "ownerDocument"
      ])(referenceElement);
      const html = doc.documentElement;
      const body = doc.body;
      const win = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__getWindow__as__ownerWindow$3e$__[
        "ownerWindow"
      ])(html);
      let scrollTop = 0;
      let scrollLeft = 0;
      let updateGutterOnly = false;
      const resizeFrame =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useAnimationFrame$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "AnimationFrame"
        ].create();
      // Pinch-zoom in Safari causes a shift. Just don't lock scroll if there's any pinch-zoom.
      if (
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$detectBrowser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isWebKit"
        ] &&
        (win.visualViewport?.scale ?? 1) !== 1
      ) {
        return () => {};
      }
      function lockScroll() {
        /* DOM reads: */ const htmlStyles = win.getComputedStyle(html);
        const bodyStyles = win.getComputedStyle(body);
        const htmlScrollbarGutterValue = htmlStyles.scrollbarGutter || "";
        const hasBothEdges = htmlScrollbarGutterValue.includes("both-edges");
        const scrollbarGutterValue = hasBothEdges ? "stable both-edges" : "stable";
        scrollTop = html.scrollTop;
        scrollLeft = html.scrollLeft;
        originalHtmlStyles = {
          scrollbarGutter: html.style.scrollbarGutter,
          overflowY: html.style.overflowY,
          overflowX: html.style.overflowX,
        };
        originalHtmlScrollBehavior = html.style.scrollBehavior;
        originalBodyStyles = {
          position: body.style.position,
          height: body.style.height,
          width: body.style.width,
          boxSizing: body.style.boxSizing,
          overflowY: body.style.overflowY,
          overflowX: body.style.overflowX,
          scrollBehavior: body.style.scrollBehavior,
        };
        const isScrollableY = html.scrollHeight > html.clientHeight;
        const isScrollableX = html.scrollWidth > html.clientWidth;
        const hasConstantOverflowY =
          htmlStyles.overflowY === "scroll" || bodyStyles.overflowY === "scroll";
        const hasConstantOverflowX =
          htmlStyles.overflowX === "scroll" || bodyStyles.overflowX === "scroll";
        // Values can be negative in Firefox
        const scrollbarWidth = Math.max(0, win.innerWidth - body.clientWidth);
        const scrollbarHeight = Math.max(0, win.innerHeight - body.clientHeight);
        // Avoid shift due to the default <body> margin. This does cause elements to be clipped
        // with whitespace. Warn if <body> has margins?
        const marginY = parseFloat(bodyStyles.marginTop) + parseFloat(bodyStyles.marginBottom);
        const marginX = parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight);
        const elementToLock = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isOverflowElement"
        ])(html)
          ? html
          : body;
        updateGutterOnly = supportsStableScrollbarGutter(referenceElement);
        /*
         * DOM writes:
         * Do not read the DOM past this point!
         */ if (updateGutterOnly) {
          html.style.scrollbarGutter = scrollbarGutterValue;
          elementToLock.style.overflowY = "hidden";
          elementToLock.style.overflowX = "hidden";
          return;
        }
        Object.assign(html.style, {
          scrollbarGutter: scrollbarGutterValue,
          overflowY: "hidden",
          overflowX: "hidden",
        });
        if (isScrollableY || hasConstantOverflowY) {
          html.style.overflowY = "scroll";
        }
        if (isScrollableX || hasConstantOverflowX) {
          html.style.overflowX = "scroll";
        }
        Object.assign(body.style, {
          position: "relative",
          height:
            marginY || scrollbarHeight ? `calc(100dvh - ${marginY + scrollbarHeight}px)` : "100dvh",
          width:
            marginX || scrollbarWidth ? `calc(100vw - ${marginX + scrollbarWidth}px)` : "100vw",
          boxSizing: "border-box",
          overflow: "hidden",
          scrollBehavior: "unset",
        });
        body.scrollTop = scrollTop;
        body.scrollLeft = scrollLeft;
        html.setAttribute("data-base-ui-scroll-locked", "");
        html.style.scrollBehavior = "unset";
      }
      function cleanup() {
        Object.assign(html.style, originalHtmlStyles);
        Object.assign(body.style, originalBodyStyles);
        if (!updateGutterOnly) {
          html.scrollTop = scrollTop;
          html.scrollLeft = scrollLeft;
          html.removeAttribute("data-base-ui-scroll-locked");
          html.style.scrollBehavior = originalHtmlScrollBehavior;
        }
      }
      function handleResize() {
        cleanup();
        resizeFrame.request(lockScroll);
      }
      lockScroll();
      win.addEventListener("resize", handleResize);
      return () => {
        resizeFrame.cancel();
        cleanup();
        // Sometimes this cleanup can be run after test teardown
        // because it is called in a `setTimeout(fn, 0)`,
        // in which case `removeEventListener` wouldn't be available,
        // so we check for it to avoid test failures.
        if (typeof win.removeEventListener === "function") {
          win.removeEventListener("resize", handleResize);
        }
      };
    }
    class ScrollLocker {
      lockCount = 0;
      restore = null;
      timeoutLock =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useTimeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "Timeout"
        ].create();
      timeoutUnlock =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useTimeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "Timeout"
        ].create();
      acquire(referenceElement) {
        this.lockCount += 1;
        if (this.lockCount === 1 && this.restore === null) {
          this.timeoutLock.start(0, () => this.lock(referenceElement));
        }
        return this.release;
      }
      release = () => {
        this.lockCount -= 1;
        if (this.lockCount === 0 && this.restore) {
          this.timeoutUnlock.start(0, this.unlock);
        }
      };
      unlock = () => {
        if (this.lockCount === 0 && this.restore) {
          this.restore?.();
          this.restore = null;
        }
      };
      lock(referenceElement) {
        if (this.lockCount === 0 || this.restore !== null) {
          return;
        }
        const doc = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$owner$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "ownerDocument"
        ])(referenceElement);
        const html = doc.documentElement;
        const htmlOverflowY = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__getWindow__as__ownerWindow$3e$__[
          "ownerWindow"
        ])(html).getComputedStyle(html).overflowY;
        // If the site author already hid overflow on <html>, respect it and bail out.
        if (htmlOverflowY === "hidden" || htmlOverflowY === "clip") {
          this.restore =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$empty$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "NOOP"
            ];
          return;
        }
        const hasOverlayScrollbars =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$detectBrowser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "isIOS"
          ] || !hasInsetScrollbars(referenceElement);
        // On iOS, scroll locking does not work if the navbar is collapsed. Due to numerous
        // side effects and bugs that arise on iOS, it must be researched extensively before
        // being enabled to ensure it doesn't cause the following issues:
        // - Textboxes must scroll into view when focused, nor cause a glitchy scroll animation.
        // - The navbar must not force itself into view and cause layout shift.
        // - Scroll containers must not flicker upon closing a popup when it has an exit animation.
        this.restore = hasOverlayScrollbars
          ? preventScrollOverlayScrollbars(referenceElement)
          : preventScrollInsetScrollbars(referenceElement);
      }
    }
    const SCROLL_LOCKER = new ScrollLocker();
    function useScrollLock(enabled = true, referenceElement = null) {
      (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$base$2d$ui$2f$utils$2f$esm$2f$useIsoLayoutEffect$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useIsoLayoutEffect"
      ])(
        {
          "useScrollLock.useIsoLayoutEffect": () => {
            if (!enabled) {
              return undefined;
            }
            return SCROLL_LOCKER.acquire(referenceElement);
          },
        }["useScrollLock.useIsoLayoutEffect"],
        [enabled, referenceElement],
      );
    }
  },
  "[project]/node_modules/@base-ui/utils/esm/useEnhancedClickHandler.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["useEnhancedClickHandler", () => useEnhancedClickHandler]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    ("use client");
    function useEnhancedClickHandler(handler) {
      const lastClickInteractionTypeRef =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useRef"
        ]("");
      const handlePointerDown =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useCallback"
        ](
          {
            "useEnhancedClickHandler.useCallback[handlePointerDown]": (event) => {
              if (event.defaultPrevented) {
                return;
              }
              lastClickInteractionTypeRef.current = event.pointerType;
              handler(event, event.pointerType);
            },
          }["useEnhancedClickHandler.useCallback[handlePointerDown]"],
          [handler],
        );
      const handleClick =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useCallback"
        ](
          {
            "useEnhancedClickHandler.useCallback[handleClick]": (event) => {
              // event.detail has the number of clicks performed on the element. 0 means it was triggered by the keyboard.
              if (event.detail === 0) {
                handler(event, "keyboard");
                return;
              }
              if ("pointerType" in event) {
                // Chrome and Edge correctly use PointerEvent
                handler(event, event.pointerType);
              } else {
                handler(event, lastClickInteractionTypeRef.current);
              }
              lastClickInteractionTypeRef.current = "";
            },
          }["useEnhancedClickHandler.useCallback[handleClick]"],
          [handler],
        );
      return {
        onClick: handleClick,
        onPointerDown: handlePointerDown,
      };
    }
  },
  "[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "getComputedStyle",
      () => getComputedStyle,
      "getContainingBlock",
      () => getContainingBlock,
      "getDocumentElement",
      () => getDocumentElement,
      "getFrameElement",
      () => getFrameElement,
      "getNearestOverflowAncestor",
      () => getNearestOverflowAncestor,
      "getNodeName",
      () => getNodeName,
      "getNodeScroll",
      () => getNodeScroll,
      "getOverflowAncestors",
      () => getOverflowAncestors,
      "getParentNode",
      () => getParentNode,
      "getWindow",
      () => getWindow,
      "isContainingBlock",
      () => isContainingBlock,
      "isElement",
      () => isElement,
      "isHTMLElement",
      () => isHTMLElement,
      "isLastTraversableNode",
      () => isLastTraversableNode,
      "isNode",
      () => isNode,
      "isOverflowElement",
      () => isOverflowElement,
      "isShadowRoot",
      () => isShadowRoot,
      "isTableElement",
      () => isTableElement,
      "isTopLayer",
      () => isTopLayer,
      "isWebKit",
      () => isWebKit,
    ]);
    function hasWindow() {
      return typeof window !== "undefined";
    }
    function getNodeName(node) {
      if (isNode(node)) {
        return (node.nodeName || "").toLowerCase();
      }
      // Mocked nodes in testing environments may not be instances of Node. By
      // returning `#document` an infinite loop won't occur.
      // https://github.com/floating-ui/floating-ui/issues/2317
      return "#document";
    }
    function getWindow(node) {
      var _node$ownerDocument;
      return (
        (node == null || (_node$ownerDocument = node.ownerDocument) == null
          ? void 0
          : _node$ownerDocument.defaultView) || window
      );
    }
    function getDocumentElement(node) {
      var _ref;
      return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null
        ? void 0
        : _ref.documentElement;
    }
    function isNode(value) {
      if (!hasWindow()) {
        return false;
      }
      return value instanceof Node || value instanceof getWindow(value).Node;
    }
    function isElement(value) {
      if (!hasWindow()) {
        return false;
      }
      return value instanceof Element || value instanceof getWindow(value).Element;
    }
    function isHTMLElement(value) {
      if (!hasWindow()) {
        return false;
      }
      return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
    }
    function isShadowRoot(value) {
      if (!hasWindow() || typeof ShadowRoot === "undefined") {
        return false;
      }
      return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
    }
    const invalidOverflowDisplayValues = /*#__PURE__*/ new Set(["inline", "contents"]);
    function isOverflowElement(element) {
      const { overflow, overflowX, overflowY, display } = getComputedStyle(element);
      return (
        /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) &&
        !invalidOverflowDisplayValues.has(display)
      );
    }
    const tableElements = /*#__PURE__*/ new Set(["table", "td", "th"]);
    function isTableElement(element) {
      return tableElements.has(getNodeName(element));
    }
    const topLayerSelectors = [":popover-open", ":modal"];
    function isTopLayer(element) {
      return topLayerSelectors.some((selector) => {
        try {
          return element.matches(selector);
        } catch (_e) {
          return false;
        }
      });
    }
    const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
    const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
    const containValues = ["paint", "layout", "strict", "content"];
    function isContainingBlock(elementOrCss) {
      const webkit = isWebKit();
      const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;
      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
      // https://drafts.csswg.org/css-transforms-2/#individual-transforms
      return (
        transformProperties.some((value) => (css[value] ? css[value] !== "none" : false)) ||
        (css.containerType ? css.containerType !== "normal" : false) ||
        (!webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false)) ||
        (!webkit && (css.filter ? css.filter !== "none" : false)) ||
        willChangeValues.some((value) => (css.willChange || "").includes(value)) ||
        containValues.some((value) => (css.contain || "").includes(value))
      );
    }
    function getContainingBlock(element) {
      let currentNode = getParentNode(element);
      while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
        if (isContainingBlock(currentNode)) {
          return currentNode;
        } else if (isTopLayer(currentNode)) {
          return null;
        }
        currentNode = getParentNode(currentNode);
      }
      return null;
    }
    function isWebKit() {
      if (typeof CSS === "undefined" || !CSS.supports) return false;
      return CSS.supports("-webkit-backdrop-filter", "none");
    }
    const lastTraversableNodeNames = /*#__PURE__*/ new Set(["html", "body", "#document"]);
    function isLastTraversableNode(node) {
      return lastTraversableNodeNames.has(getNodeName(node));
    }
    function getComputedStyle(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function getNodeScroll(element) {
      if (isElement(element)) {
        return {
          scrollLeft: element.scrollLeft,
          scrollTop: element.scrollTop,
        };
      }
      return {
        scrollLeft: element.scrollX,
        scrollTop: element.scrollY,
      };
    }
    function getParentNode(node) {
      if (getNodeName(node) === "html") {
        return node;
      }
      const result = // Step into the shadow DOM of the parent of a slotted node.
        node.assignedSlot || // DOM Element detected.
        node.parentNode || // ShadowRoot detected.
        (isShadowRoot(node) && node.host) || // Fallback.
        getDocumentElement(node);
      return isShadowRoot(result) ? result.host : result;
    }
    function getNearestOverflowAncestor(node) {
      const parentNode = getParentNode(node);
      if (isLastTraversableNode(parentNode)) {
        return node.ownerDocument ? node.ownerDocument.body : node.body;
      }
      if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
        return parentNode;
      }
      return getNearestOverflowAncestor(parentNode);
    }
    function getOverflowAncestors(node, list, traverseIframes) {
      var _node$ownerDocument2;
      if (list === void 0) {
        list = [];
      }
      if (traverseIframes === void 0) {
        traverseIframes = true;
      }
      const scrollableAncestor = getNearestOverflowAncestor(node);
      const isBody =
        scrollableAncestor ===
        ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
      const win = getWindow(scrollableAncestor);
      if (isBody) {
        const frameElement = getFrameElement(win);
        return list.concat(
          win,
          win.visualViewport || [],
          isOverflowElement(scrollableAncestor) ? scrollableAncestor : [],
          frameElement && traverseIframes ? getOverflowAncestors(frameElement) : [],
        );
      }
      return list.concat(
        scrollableAncestor,
        getOverflowAncestors(scrollableAncestor, [], traverseIframes),
      );
    }
    function getFrameElement(win) {
      return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
    }
  },
  "[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs [app-client] (ecmascript) <export getWindow as ownerWindow>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "ownerWindow",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getWindow"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs [app-client] (ecmascript)",
      );
  },
  "[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "alignments",
      () => alignments,
      "clamp",
      () => clamp,
      "createCoords",
      () => createCoords,
      "evaluate",
      () => evaluate,
      "expandPaddingObject",
      () => expandPaddingObject,
      "floor",
      () => floor,
      "getAlignment",
      () => getAlignment,
      "getAlignmentAxis",
      () => getAlignmentAxis,
      "getAlignmentSides",
      () => getAlignmentSides,
      "getAxisLength",
      () => getAxisLength,
      "getExpandedPlacements",
      () => getExpandedPlacements,
      "getOppositeAlignmentPlacement",
      () => getOppositeAlignmentPlacement,
      "getOppositeAxis",
      () => getOppositeAxis,
      "getOppositeAxisPlacements",
      () => getOppositeAxisPlacements,
      "getOppositePlacement",
      () => getOppositePlacement,
      "getPaddingObject",
      () => getPaddingObject,
      "getSide",
      () => getSide,
      "getSideAxis",
      () => getSideAxis,
      "max",
      () => max,
      "min",
      () => min,
      "placements",
      () => placements,
      "rectToClientRect",
      () => rectToClientRect,
      "round",
      () => round,
      "sides",
      () => sides,
    ]);
    /**
     * Custom positioning reference element.
     * @see https://floating-ui.com/docs/virtual-elements
     */ const sides = ["top", "right", "bottom", "left"];
    const alignments = ["start", "end"];
    const placements = /*#__PURE__*/ sides.reduce(
      (acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]),
      [],
    );
    const min = Math.min;
    const max = Math.max;
    const round = Math.round;
    const floor = Math.floor;
    const createCoords = (v) => ({
      x: v,
      y: v,
    });
    const oppositeSideMap = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom",
    };
    const oppositeAlignmentMap = {
      start: "end",
      end: "start",
    };
    function clamp(start, value, end) {
      return max(start, min(value, end));
    }
    function evaluate(value, param) {
      return typeof value === "function" ? value(param) : value;
    }
    function getSide(placement) {
      return placement.split("-")[0];
    }
    function getAlignment(placement) {
      return placement.split("-")[1];
    }
    function getOppositeAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    function getAxisLength(axis) {
      return axis === "y" ? "height" : "width";
    }
    const yAxisSides = /*#__PURE__*/ new Set(["top", "bottom"]);
    function getSideAxis(placement) {
      return yAxisSides.has(getSide(placement)) ? "y" : "x";
    }
    function getAlignmentAxis(placement) {
      return getOppositeAxis(getSideAxis(placement));
    }
    function getAlignmentSides(placement, rects, rtl) {
      if (rtl === void 0) {
        rtl = false;
      }
      const alignment = getAlignment(placement);
      const alignmentAxis = getAlignmentAxis(placement);
      const length = getAxisLength(alignmentAxis);
      let mainAlignmentSide =
        alignmentAxis === "x"
          ? alignment === (rtl ? "end" : "start")
            ? "right"
            : "left"
          : alignment === "start"
            ? "bottom"
            : "top";
      if (rects.reference[length] > rects.floating[length]) {
        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
      }
      return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
    }
    function getExpandedPlacements(placement) {
      const oppositePlacement = getOppositePlacement(placement);
      return [
        getOppositeAlignmentPlacement(placement),
        oppositePlacement,
        getOppositeAlignmentPlacement(oppositePlacement),
      ];
    }
    function getOppositeAlignmentPlacement(placement) {
      return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
    }
    const lrPlacement = ["left", "right"];
    const rlPlacement = ["right", "left"];
    const tbPlacement = ["top", "bottom"];
    const btPlacement = ["bottom", "top"];
    function getSideList(side, isStart, rtl) {
      switch (side) {
        case "top":
        case "bottom":
          if (rtl) return isStart ? rlPlacement : lrPlacement;
          return isStart ? lrPlacement : rlPlacement;
        case "left":
        case "right":
          return isStart ? tbPlacement : btPlacement;
        default:
          return [];
      }
    }
    function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
      const alignment = getAlignment(placement);
      let list = getSideList(getSide(placement), direction === "start", rtl);
      if (alignment) {
        list = list.map((side) => side + "-" + alignment);
        if (flipAlignment) {
          list = list.concat(list.map(getOppositeAlignmentPlacement));
        }
      }
      return list;
    }
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
    }
    function expandPaddingObject(padding) {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...padding,
      };
    }
    function getPaddingObject(padding) {
      return typeof padding !== "number"
        ? expandPaddingObject(padding)
        : {
            top: padding,
            right: padding,
            bottom: padding,
            left: padding,
          };
    }
    function rectToClientRect(rect) {
      const { x, y, width, height } = rect;
      return {
        width,
        height,
        top: y,
        left: x,
        right: x + width,
        bottom: y + height,
        x,
        y,
      };
    }
  },
  "[project]/node_modules/tabbable/dist/index.esm.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "focusable",
      () => focusable,
      "getTabIndex",
      () => getTabIndex,
      "isFocusable",
      () => isFocusable,
      "isTabbable",
      () => isTabbable,
      "tabbable",
      () => tabbable,
    ]);
    /*!
     * tabbable 6.4.0
     * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
     */ // NOTE: separate `:not()` selectors has broader browser support than the newer
    //  `:not([inert], [inert] *)` (Feb 2023)
    var candidateSelectors = [
      "input:not([inert]):not([inert] *)",
      "select:not([inert]):not([inert] *)",
      "textarea:not([inert]):not([inert] *)",
      "a[href]:not([inert]):not([inert] *)",
      "button:not([inert]):not([inert] *)",
      "[tabindex]:not(slot):not([inert]):not([inert] *)",
      "audio[controls]:not([inert]):not([inert] *)",
      "video[controls]:not([inert]):not([inert] *)",
      '[contenteditable]:not([contenteditable="false"]):not([inert]):not([inert] *)',
      "details>summary:first-of-type:not([inert]):not([inert] *)",
      "details:not([inert]):not([inert] *)",
    ];
    var candidateSelector = /* #__PURE__ */ candidateSelectors.join(",");
    var NoElement = typeof Element === "undefined";
    var matches = NoElement
      ? function () {}
      : Element.prototype.matches ||
        Element.prototype.msMatchesSelector ||
        Element.prototype.webkitMatchesSelector;
    var getRootNode =
      !NoElement && Element.prototype.getRootNode
        ? function (element) {
            var _element$getRootNode;
            return element === null || element === void 0
              ? void 0
              : (_element$getRootNode = element.getRootNode) === null ||
                  _element$getRootNode === void 0
                ? void 0
                : _element$getRootNode.call(element);
          }
        : function (element) {
            return element === null || element === void 0 ? void 0 : element.ownerDocument;
          };
    /**
     * Determines if a node is inert or in an inert ancestor.
     * @param {Node} [node]
     * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to
     *  see if any of them are inert. If false, only `node` itself is considered.
     * @returns {boolean} True if inert itself or by way of being in an inert ancestor.
     *  False if `node` is falsy.
     */ var _isInert = function isInert(node, lookUp) {
      var _node$getAttribute;
      if (lookUp === void 0) {
        lookUp = true;
      }
      // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`
      //  JS API property; we have to check the attribute, which can either be empty or 'true';
      //  if it's `null` (not specified) or 'false', it's an active element
      var inertAtt =
        node === null || node === void 0
          ? void 0
          : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0
            ? void 0
            : _node$getAttribute.call(node, "inert");
      var inert = inertAtt === "" || inertAtt === "true";
      // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`
      //  if it weren't for `matches()` not being a function on shadow roots; the following
      //  code works for any kind of node
      var result =
        inert ||
        (lookUp &&
          node && // closest does not exist on shadow roots, so we fall back to a manual
          // lookup upward, in case it is not defined.
          (typeof node.closest === "function"
            ? node.closest("[inert]")
            : _isInert(node.parentNode)));
      return result;
    };
    /**
     * Determines if a node's content is editable.
     * @param {Element} [node]
     * @returns True if it's content-editable; false if it's not or `node` is falsy.
     */ var isContentEditable = function isContentEditable(node) {
      var _node$getAttribute2;
      // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have
      //  to use the attribute directly to check for this, which can either be empty or 'true';
      //  if it's `null` (not specified) or 'false', it's a non-editable element
      var attValue =
        node === null || node === void 0
          ? void 0
          : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0
            ? void 0
            : _node$getAttribute2.call(node, "contenteditable");
      return attValue === "" || attValue === "true";
    };
    /**
     * @param {Element} el container to check in
     * @param {boolean} includeContainer add container to check
     * @param {(node: Element) => boolean} filter filter candidates
     * @returns {Element[]}
     */ var getCandidates = function getCandidates(el, includeContainer, filter) {
      // even if `includeContainer=false`, we still have to check it for inertness because
      //  if it's inert (either by itself or via its parent), then all its children are inert
      if (_isInert(el)) {
        return [];
      }
      var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
      if (includeContainer && matches.call(el, candidateSelector)) {
        candidates.unshift(el);
      }
      candidates = candidates.filter(filter);
      return candidates;
    };
    /**
     * @callback GetShadowRoot
     * @param {Element} element to check for shadow root
     * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.
     */ /**
     * @callback ShadowRootFilter
     * @param {Element} shadowHostNode the element which contains shadow content
     * @returns {boolean} true if a shadow root could potentially contain valid candidates.
     */ /**
     * @typedef {Object} CandidateScope
     * @property {Element} scopeParent contains inner candidates
     * @property {Element[]} candidates list of candidates found in the scope parent
     */ /**
     * @typedef {Object} IterativeOptions
     * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;
     *  if a function, implies shadow support is enabled and either returns the shadow root of an element
     *  or a boolean stating if it has an undisclosed shadow root
     * @property {(node: Element) => boolean} filter filter candidates
     * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list
     * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;
     */ /**
     * @param {Element[]} elements list of element containers to match candidates from
     * @param {boolean} includeContainer add container list to check
     * @param {IterativeOptions} options
     * @returns {Array.<Element|CandidateScope>}
     */ var _getCandidatesIteratively = function getCandidatesIteratively(
      elements,
      includeContainer,
      options,
    ) {
      var candidates = [];
      var elementsToCheck = Array.from(elements);
      while (elementsToCheck.length) {
        var element = elementsToCheck.shift();
        if (_isInert(element, false)) {
          continue;
        }
        if (element.tagName === "SLOT") {
          // add shadow dom slot scope (slot itself cannot be focusable)
          var assigned = element.assignedElements();
          var content = assigned.length ? assigned : element.children;
          var nestedCandidates = _getCandidatesIteratively(content, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element,
              candidates: nestedCandidates,
            });
          }
        } else {
          // check candidate element
          var validCandidate = matches.call(element, candidateSelector);
          if (
            validCandidate &&
            options.filter(element) &&
            (includeContainer || !elements.includes(element))
          ) {
            candidates.push(element);
          }
          // iterate over shadow content if possible
          var shadowRoot =
            element.shadowRoot || // check for an undisclosed shadow
            (typeof options.getShadowRoot === "function" && options.getShadowRoot(element));
          // no inert look up because we're already drilling down and checking for inertness
          //  on the way down, so all containers to this root node should have already been
          //  vetted as non-inert
          var validShadowRoot =
            !_isInert(shadowRoot, false) &&
            (!options.shadowRootFilter || options.shadowRootFilter(element));
          if (shadowRoot && validShadowRoot) {
            // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed
            //  shadow exists, so look at light dom children as fallback BUT create a scope for any
            //  child candidates found because they're likely slotted elements (elements that are
            //  children of the web component element (which has the shadow), in the light dom, but
            //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,
            //  _after_ we return from this recursive call
            var _nestedCandidates = _getCandidatesIteratively(
              shadowRoot === true ? element.children : shadowRoot.children,
              true,
              options,
            );
            if (options.flatten) {
              candidates.push.apply(candidates, _nestedCandidates);
            } else {
              candidates.push({
                scopeParent: element,
                candidates: _nestedCandidates,
              });
            }
          } else {
            // there's not shadow so just dig into the element's (light dom) children
            //  __without__ giving the element special scope treatment
            elementsToCheck.unshift.apply(elementsToCheck, element.children);
          }
        }
      }
      return candidates;
    };
    /**
     * @private
     * Determines if the node has an explicitly specified `tabindex` attribute.
     * @param {HTMLElement} node
     * @returns {boolean} True if so; false if not.
     */ var hasTabIndex = function hasTabIndex(node) {
      return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
    };
    /**
     * Determine the tab index of a given node.
     * @param {HTMLElement} node
     * @returns {number} Tab order (negative, 0, or positive number).
     * @throws {Error} If `node` is falsy.
     */ var getTabIndex = function getTabIndex(node) {
      if (!node) {
        throw new Error("No node provided");
      }
      if (node.tabIndex < 0) {
        // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
        // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
        // yet they are still part of the regular tab order; in FF, they get a default
        // `tabIndex` of 0; since Chrome still puts those elements in the regular tab
        // order, consider their tab index to be 0.
        // Also browsers do not return `tabIndex` correctly for contentEditable nodes;
        // so if they don't have a tabindex attribute specifically set, assume it's 0.
        if (
          (/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) &&
          !hasTabIndex(node)
        ) {
          return 0;
        }
      }
      return node.tabIndex;
    };
    /**
     * Determine the tab index of a given node __for sort order purposes__.
     * @param {HTMLElement} node
     * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,
     *  has tabIndex -1, but needs to be sorted by document order in order for its content to be
     *  inserted into the correct sort position.
     * @returns {number} Tab order (negative, 0, or positive number).
     */ var getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {
      var tabIndex = getTabIndex(node);
      if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
        return 0;
      }
      return tabIndex;
    };
    var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
      return a.tabIndex === b.tabIndex
        ? a.documentOrder - b.documentOrder
        : a.tabIndex - b.tabIndex;
    };
    var isInput = function isInput(node) {
      return node.tagName === "INPUT";
    };
    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === "hidden";
    };
    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r =
        node.tagName === "DETAILS" &&
        Array.prototype.slice.apply(node.children).some(function (child) {
          return child.tagName === "SUMMARY";
        });
      return r;
    };
    var getCheckedRadio = function getCheckedRadio(nodes, form) {
      for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].checked && nodes[i].form === form) {
          return nodes[i];
        }
      }
    };
    var isTabbableRadio = function isTabbableRadio(node) {
      if (!node.name) {
        return true;
      }
      var radioScope = node.form || getRootNode(node);
      var queryRadios = function queryRadios(name) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
      };
      var radioSet;
      if (
        typeof window !== "undefined" &&
        typeof window.CSS !== "undefined" &&
        typeof window.CSS.escape === "function"
      ) {
        radioSet = queryRadios(window.CSS.escape(node.name));
      } else {
        try {
          radioSet = queryRadios(node.name);
        } catch (err) {
          // eslint-disable-next-line no-console
          console.error(
            "Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s",
            err.message,
          );
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    };
    var isRadio = function isRadio(node) {
      return isInput(node) && node.type === "radio";
    };
    var isNonTabbableRadio = function isNonTabbableRadio(node) {
      return isRadio(node) && !isTabbableRadio(node);
    };
    // determines if a node is ultimately attached to the window's document
    var isNodeAttached = function isNodeAttached(node) {
      var _nodeRoot;
      // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
      //  (but NOT _the_ document; see second 'If' comment below for more).
      // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
      //  is attached, and the one we need to check if it's in the document or not (because the
      //  shadow, and all nodes it contains, is never considered in the document since shadows
      //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
      //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
      //  visibility, including all the nodes it contains). The host could be any normal node,
      //  or a custom element (i.e. web component). Either way, that's the one that is considered
      //  part of the document, not the shadow root, nor any of its children (i.e. the node being
      //  tested).
      // To further complicate things, we have to look all the way up until we find a shadow HOST
      //  that is attached (or find none) because the node might be in nested shadows...
      // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
      //  document (per the docs) and while it's a Document-type object, that document does not
      //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
      //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
      //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
      //  node is actually detached.
      // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible
      //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed
      //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then
      //  `ownerDocument` will be `null`, hence the optional chaining on it.
      var nodeRoot = node && getRootNode(node);
      var nodeRootHost =
        (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
      // in some cases, a detached node will return itself as the root instead of a document or
      //  shadow root object, in which case, we shouldn't try to look further up the host chain
      var attached = false;
      if (nodeRoot && nodeRoot !== node) {
        var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
        attached = !!(
          ((_nodeRootHost = nodeRootHost) !== null &&
            _nodeRootHost !== void 0 &&
            (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null &&
            _nodeRootHost$ownerDo !== void 0 &&
            _nodeRootHost$ownerDo.contains(nodeRootHost)) ||
          (node !== null &&
            node !== void 0 &&
            (_node$ownerDocument = node.ownerDocument) !== null &&
            _node$ownerDocument !== void 0 &&
            _node$ownerDocument.contains(node))
        );
        while (!attached && nodeRootHost) {
          var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
          // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
          //  which means we need to get the host's host and check if that parent host is contained
          //  in (i.e. attached to) the document
          nodeRoot = getRootNode(nodeRootHost);
          nodeRootHost =
            (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
          attached = !!(
            (_nodeRootHost2 = nodeRootHost) !== null &&
            _nodeRootHost2 !== void 0 &&
            (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null &&
            _nodeRootHost2$ownerD !== void 0 &&
            _nodeRootHost2$ownerD.contains(nodeRootHost)
          );
        }
      }
      return attached;
    };
    var isZeroArea = function isZeroArea(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(),
        width = _node$getBoundingClie.width,
        height = _node$getBoundingClie.height;
      return width === 0 && height === 0;
    };
    var isHidden = function isHidden(node, _ref) {
      var displayCheck = _ref.displayCheck,
        getShadowRoot = _ref.getShadowRoot;
      if (displayCheck === "full-native") {
        if ("checkVisibility" in node) {
          // Chrome >= 105, Edge >= 105, Firefox >= 106, Safari >= 17.4
          // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/checkVisibility#browser_compatibility
          var visible = node.checkVisibility({
            // Checking opacity might be desirable for some use cases, but natively,
            // opacity zero elements _are_ focusable and tabbable.
            checkOpacity: false,
            opacityProperty: false,
            contentVisibilityAuto: true,
            visibilityProperty: true,
            // This is an alias for `visibilityProperty`. Contemporary browsers
            // support both. However, this alias has wider browser support (Chrome
            // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so
            // we include it anyway.
            checkVisibilityCSS: true,
          });
          return !visible;
        }
        // Fall through to manual visibility checks
      }
      // NOTE: visibility will be `undefined` if node is detached from the document
      //  (see notes about this further down), which means we will consider it visible
      //  (this is legacy behavior from a very long way back)
      // NOTE: we check this regardless of `displayCheck="none"` because this is a
      //  _visibility_ check, not a _display_ check
      if (getComputedStyle(node).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches.call(node, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
      if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      if (
        !displayCheck ||
        displayCheck === "full" || // full-native can run this branch when it falls through in case
        // Element#checkVisibility is unsupported
        displayCheck === "full-native" ||
        displayCheck === "legacy-full"
      ) {
        if (typeof getShadowRoot === "function") {
          // figure out if we should consider the node to be in an undisclosed shadow and use the
          //  'non-zero-area' fallback
          var originalNode = node;
          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);
            if (
              parentElement &&
              !parentElement.shadowRoot &&
              getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
            ) {
              // node has an undisclosed shadow which means we can only treat it as a black box, so we
              //  fall back to a non-zero-area test
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              // iterate up slot
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              // cross shadow boundary
              node = rootNode.host;
            } else {
              // iterate up normal dom
              node = parentElement;
            }
          }
          node = originalNode;
        }
        // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.
        if (isNodeAttached(node)) {
          // this works wherever the node is: if there's at least one client rect, it's
          //  somehow displayed; it also covers the CSS 'display: contents' case where the
          //  node itself is hidden in place of its contents; and there's no need to search
          //  up the hierarchy either
          return !node.getClientRects().length;
        }
        // Else, the node isn't attached to the document, which means the `getClientRects()`
        //  API will __always__ return zero rects (this can happen, for example, if React
        //  is used to render nodes onto a detached tree, as confirmed in this thread:
        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
        //
        // It also means that even window.getComputedStyle(node).display will return `undefined`
        //  because styles are only computed for nodes that are in the document.
        //
        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
        //  somehow. Though it was never stated officially, anyone who has ever used tabbable
        //  APIs on nodes in detached containers has actually implicitly used tabbable in what
        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
        //  considering __everything__ to be visible because of the innability to determine styles.
        //
        // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
        //  nodes as visible with the 'none' fallback.__
        if (displayCheck !== "legacy-full") {
          return true; // hidden
        }
        // else, fallback to 'none' mode and consider the node visible
      } else if (displayCheck === "non-zero-area") {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
      }
      // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
      //  it's visible
      return false;
    };
    // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset
    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement;
        // check if `node` is contained in a disabled <fieldset>
        while (parentNode) {
          if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
            // look for the first <legend> among the children of the disabled <fieldset>
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i);
              // when the first <legend> (in document order) is found
              if (child.tagName === "LEGEND") {
                // if its parent <fieldset> is not nested in another disabled <fieldset>,
                // return whether `node` is a descendant of its first <legend>
                return matches.call(parentNode, "fieldset[disabled] *")
                  ? true
                  : !child.contains(node);
              }
            }
            // the disabled <fieldset> containing `node` has no <legend>
            return true;
          }
          parentNode = parentNode.parentElement;
        }
      }
      // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state
      return false;
    };
    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (
        node.disabled ||
        isHiddenInput(node) ||
        isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
        isDetailsWithSummary(node) ||
        isDisabledFromFieldset(node)
      ) {
        return false;
      }
      return true;
    };
    var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {
      if (
        isNonTabbableRadio(node) ||
        getTabIndex(node) < 0 ||
        !isNodeMatchingSelectorFocusable(options, node)
      ) {
        return false;
      }
      return true;
    };
    var isShadowRootTabbable = function isShadowRootTabbable(shadowHostNode) {
      var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
      if (isNaN(tabIndex) || tabIndex >= 0) {
        return true;
      }
      // If a custom element has an explicit negative tabindex,
      // browsers will not allow tab targeting said element's children.
      return false;
    };
    /**
     * @param {Array.<Element|CandidateScope>} candidates
     * @returns Element[]
     */ var _sortByOrder = function sortByOrder(candidates) {
      var regularTabbables = [];
      var orderedTabbables = [];
      candidates.forEach(function (item, i) {
        var isScope = !!item.scopeParent;
        var element = isScope ? item.scopeParent : item;
        var candidateTabindex = getSortOrderTabIndex(element, isScope);
        var elements = isScope ? _sortByOrder(item.candidates) : element;
        if (candidateTabindex === 0) {
          isScope
            ? regularTabbables.push.apply(regularTabbables, elements)
            : regularTabbables.push(element);
        } else {
          orderedTabbables.push({
            documentOrder: i,
            tabIndex: candidateTabindex,
            item: item,
            isScope: isScope,
            content: elements,
          });
        }
      });
      return orderedTabbables
        .sort(sortOrderedTabbables)
        .reduce(function (acc, sortable) {
          sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
          return acc;
        }, [])
        .concat(regularTabbables);
    };
    var tabbable = function tabbable(container, options) {
      options = options || {};
      var candidates;
      if (options.getShadowRoot) {
        candidates = _getCandidatesIteratively([container], options.includeContainer, {
          filter: isNodeMatchingSelectorTabbable.bind(null, options),
          flatten: false,
          getShadowRoot: options.getShadowRoot,
          shadowRootFilter: isShadowRootTabbable,
        });
      } else {
        candidates = getCandidates(
          container,
          options.includeContainer,
          isNodeMatchingSelectorTabbable.bind(null, options),
        );
      }
      return _sortByOrder(candidates);
    };
    var focusable = function focusable(container, options) {
      options = options || {};
      var candidates;
      if (options.getShadowRoot) {
        candidates = _getCandidatesIteratively([container], options.includeContainer, {
          filter: isNodeMatchingSelectorFocusable.bind(null, options),
          flatten: true,
          getShadowRoot: options.getShadowRoot,
        });
      } else {
        candidates = getCandidates(
          container,
          options.includeContainer,
          isNodeMatchingSelectorFocusable.bind(null, options),
        );
      }
      return candidates;
    };
    var isTabbable = function isTabbable(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, candidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorTabbable(options, node);
    };
    var focusableCandidateSelector = /* #__PURE__ */ candidateSelectors
      .concat("iframe:not([inert]):not([inert] *)")
      .join(",");
    var isFocusable = function isFocusable(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorFocusable(options, node);
    };
  },
  //# sourceMappingURL=index.esm.js.map
  "[project]/node_modules/@floating-ui/core/dist/floating-ui.core.mjs [app-client] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "arrow",
      () => arrow,
      "autoPlacement",
      () => autoPlacement,
      "computePosition",
      () => computePosition,
      "detectOverflow",
      () => detectOverflow,
      "flip",
      () => flip,
      "hide",
      () => hide,
      "inline",
      () => inline,
      "limitShift",
      () => limitShift,
      "offset",
      () => offset,
      "shift",
      () => shift,
      "size",
      () => size,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs [app-client] (ecmascript)",
      );
    function computeCoordsFromPlacement(_ref, placement, rtl) {
      let { reference, floating } = _ref;
      const sideAxis = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getSideAxis"
      ])(placement);
      const alignmentAxis = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getAlignmentAxis"
      ])(placement);
      const alignLength = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getAxisLength"
      ])(alignmentAxis);
      const side = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getSide"
      ])(placement);
      const isVertical = sideAxis === "y";
      const commonX = reference.x + reference.width / 2 - floating.width / 2;
      const commonY = reference.y + reference.height / 2 - floating.height / 2;
      const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
      let coords;
      switch (side) {
        case "top":
          coords = {
            x: commonX,
            y: reference.y - floating.height,
          };
          break;
        case "bottom":
          coords = {
            x: commonX,
            y: reference.y + reference.height,
          };
          break;
        case "right":
          coords = {
            x: reference.x + reference.width,
            y: commonY,
          };
          break;
        case "left":
          coords = {
            x: reference.x - floating.width,
            y: commonY,
          };
          break;
        default:
          coords = {
            x: reference.x,
            y: reference.y,
          };
      }
      switch (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getAlignment"
        ])(placement)
      ) {
        case "start":
          coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
          break;
        case "end":
          coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
          break;
      }
      return coords;
    }
    /**
     * Resolves with an object of overflow side offsets that determine how much the
     * element is overflowing a given clipping boundary on each side.
     * - positive = overflowing the boundary by that number of pixels
     * - negative = how many pixels left before it will overflow
     * - 0 = lies flush with the boundary
     * @see https://floating-ui.com/docs/detectOverflow
     */ async function detectOverflow(state, options) {
      var _await$platform$isEle;
      if (options === void 0) {
        options = {};
      }
      const { x, y, platform, rects, elements, strategy } = state;
      const {
        boundary = "clippingAncestors",
        rootBoundary = "viewport",
        elementContext = "floating",
        altBoundary = false,
        padding = 0,
      } = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "evaluate"
      ])(options, state);
      const paddingObject = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getPaddingObject"
      ])(padding);
      const altContext = elementContext === "floating" ? "reference" : "floating";
      const element = elements[altBoundary ? altContext : elementContext];
      const clippingClientRect = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "rectToClientRect"
      ])(
        await platform.getClippingRect({
          element: (
            (_await$platform$isEle = await (platform.isElement == null
              ? void 0
              : platform.isElement(element))) != null
              ? _await$platform$isEle
              : true
          )
            ? element
            : element.contextElement ||
              (await (platform.getDocumentElement == null
                ? void 0
                : platform.getDocumentElement(elements.floating))),
          boundary,
          rootBoundary,
          strategy,
        }),
      );
      const rect =
        elementContext === "floating"
          ? {
              x,
              y,
              width: rects.floating.width,
              height: rects.floating.height,
            }
          : rects.reference;
      const offsetParent = await (platform.getOffsetParent == null
        ? void 0
        : platform.getOffsetParent(elements.floating));
      const offsetScale = (await (platform.isElement == null
        ? void 0
        : platform.isElement(offsetParent)))
        ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
            x: 1,
            y: 1,
          }
        : {
            x: 1,
            y: 1,
          };
      const elementClientRect = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "rectToClientRect"
      ])(
        platform.convertOffsetParentRelativeRectToViewportRelativeRect
          ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
              elements,
              rect,
              offsetParent,
              strategy,
            })
          : rect,
      );
      return {
        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
        bottom:
          (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) /
          offsetScale.y,
        left:
          (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
        right:
          (elementClientRect.right - clippingClientRect.right + paddingObject.right) /
          offsetScale.x,
      };
    }
    /**
     * Computes the `x` and `y` coordinates that will place the floating element
     * next to a given reference element.
     *
     * This export does not have any `platform` interface logic. You will need to
     * write one for the platform you are using Floating UI with.
     */ const computePosition = async (reference, floating, config) => {
      const { placement = "bottom", strategy = "absolute", middleware = [], platform } = config;
      const validMiddleware = middleware.filter(Boolean);
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
      let rects = await platform.getElementRects({
        reference,
        floating,
        strategy,
      });
      let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i = 0; i < validMiddleware.length; i++) {
        var _platform$detectOverf;
        const { name, fn } = validMiddleware[i];
        const {
          x: nextX,
          y: nextY,
          data,
          reset,
        } = await fn({
          x,
          y,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform: {
            ...platform,
            detectOverflow:
              (_platform$detectOverf = platform.detectOverflow) != null
                ? _platform$detectOverf
                : detectOverflow,
          },
          elements: {
            reference,
            floating,
          },
        });
        x = nextX != null ? nextX : x;
        y = nextY != null ? nextY : y;
        middlewareData = {
          ...middlewareData,
          [name]: {
            ...middlewareData[name],
            ...data,
          },
        };
        if (reset && resetCount <= 50) {
          resetCount++;
          if (typeof reset === "object") {
            if (reset.placement) {
              statefulPlacement = reset.placement;
            }
            if (reset.rects) {
              rects =
                reset.rects === true
                  ? await platform.getElementRects({
                      reference,
                      floating,
                      strategy,
                    })
                  : reset.rects;
            }
            ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i = -1;
        }
      }
      return {
        x,
        y,
        placement: statefulPlacement,
        strategy,
        middlewareData,
      };
    };
    /**
     * Provides data to position an inner element of the floating element so that it
     * appears centered to the reference element.
     * @see https://floating-ui.com/docs/arrow
     */ const arrow = (options) => ({
      name: "arrow",
      options,
      async fn(state) {
        const { x, y, placement, rects, platform, elements, middlewareData } = state;
        // Since `element` is required, we don't Partial<> the type.
        const { element, padding = 0 } =
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "evaluate"
          ])(options, state) || {};
        if (element == null) {
          return {};
        }
        const paddingObject = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getPaddingObject"
        ])(padding);
        const coords = {
          x,
          y,
        };
        const axis = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getAlignmentAxis"
        ])(placement);
        const length = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getAxisLength"
        ])(axis);
        const arrowDimensions = await platform.getDimensions(element);
        const isYAxis = axis === "y";
        const minProp = isYAxis ? "top" : "left";
        const maxProp = isYAxis ? "bottom" : "right";
        const clientProp = isYAxis ? "clientHeight" : "clientWidth";
        const endDiff =
          rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await (platform.getOffsetParent == null
          ? void 0
          : platform.getOffsetParent(element));
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
        // DOM platform can return `window` as the `offsetParent`.
        if (
          !clientSize ||
          !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))
        ) {
          clientSize = elements.floating[clientProp] || rects.floating[length];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        // If the padding is large enough that it causes the arrow to no longer be
        // centered, modify the padding so that it is centered.
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
        const minPadding = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "min"
        ])(paddingObject[minProp], largestPossiblePadding);
        const maxPadding = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "min"
        ])(paddingObject[maxProp], largestPossiblePadding);
        // Make sure the arrow doesn't overflow the floating element if the center
        // point is outside the floating element's bounds.
        const min$1 = minPadding;
        const max = clientSize - arrowDimensions[length] - maxPadding;
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "clamp"
        ])(min$1, center, max);
        // If the reference is small enough that the arrow's padding causes it to
        // to point to nothing for an aligned placement, adjust the offset of the
        // floating element itself. To ensure `shift()` continues to take action,
        // a single reset is performed when this is true.
        const shouldAddOffset =
          !middlewareData.arrow &&
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getAlignment"
          ])(placement) != null &&
          center !== offset &&
          rects.reference[length] / 2 -
            (center < min$1 ? minPadding : maxPadding) -
            arrowDimensions[length] / 2 <
            0;
        const alignmentOffset = shouldAddOffset
          ? center < min$1
            ? center - min$1
            : center - max
          : 0;
        return {
          [axis]: coords[axis] + alignmentOffset,
          data: {
            [axis]: offset,
            centerOffset: center - offset - alignmentOffset,
            ...(shouldAddOffset && {
              alignmentOffset,
            }),
          },
          reset: shouldAddOffset,
        };
      },
    });
    function getPlacementList(alignment, autoAlignment, allowedPlacements) {
      const allowedPlacementsSortedByAlignment = alignment
        ? [
            ...allowedPlacements.filter(
              (placement) =>
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "getAlignment"
                ])(placement) === alignment,
            ),
            ...allowedPlacements.filter(
              (placement) =>
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "getAlignment"
                ])(placement) !== alignment,
            ),
          ]
        : allowedPlacements.filter(
            (placement) =>
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "getSide"
              ])(placement) === placement,
          );
      return allowedPlacementsSortedByAlignment.filter((placement) => {
        if (alignment) {
          return (
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getAlignment"
            ])(placement) === alignment ||
            (autoAlignment
              ? (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "getOppositeAlignmentPlacement"
                ])(placement) !== placement
              : false)
          );
        }
        return true;
      });
    }
    /**
     * Optimizes the visibility of the floating element by choosing the placement
     * that has the most space available automatically, without needing to specify a
     * preferred placement. Alternative to `flip`.
     * @see https://floating-ui.com/docs/autoPlacement
     */ const autoPlacement = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "autoPlacement",
        options,
        async fn(state) {
          var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
          const { rects, middlewareData, placement, platform, elements } = state;
          const {
            crossAxis = false,
            alignment,
            allowedPlacements = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "placements"
            ],
            autoAlignment = true,
            ...detectOverflowOptions
          } = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "evaluate"
          ])(options, state);
          const placements$1 =
            alignment !== undefined ||
            allowedPlacements ===
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "placements"
              ]
              ? getPlacementList(alignment || null, autoAlignment, allowedPlacements)
              : allowedPlacements;
          const overflow = await platform.detectOverflow(state, detectOverflowOptions);
          const currentIndex =
            ((_middlewareData$autoP = middlewareData.autoPlacement) == null
              ? void 0
              : _middlewareData$autoP.index) || 0;
          const currentPlacement = placements$1[currentIndex];
          if (currentPlacement == null) {
            return {};
          }
          const alignmentSides = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getAlignmentSides"
          ])(
            currentPlacement,
            rects,
            await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)),
          );
          // Make `computeCoords` start from the right place.
          if (placement !== currentPlacement) {
            return {
              reset: {
                placement: placements$1[0],
              },
            };
          }
          const currentOverflows = [
            overflow[
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "getSide"
              ])(currentPlacement)
            ],
            overflow[alignmentSides[0]],
            overflow[alignmentSides[1]],
          ];
          const allOverflows = [
            ...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null
              ? void 0
              : _middlewareData$autoP2.overflows) || []),
            {
              placement: currentPlacement,
              overflows: currentOverflows,
            },
          ];
          const nextPlacement = placements$1[currentIndex + 1];
          // There are more placements to check.
          if (nextPlacement) {
            return {
              data: {
                index: currentIndex + 1,
                overflows: allOverflows,
              },
              reset: {
                placement: nextPlacement,
              },
            };
          }
          const placementsSortedByMostSpace = allOverflows
            .map((d) => {
              const alignment = (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "getAlignment"
              ])(d.placement);
              return [
                d.placement,
                alignment && crossAxis // Check along the mainAxis and main crossAxis side.
                  ? d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) // Check only the mainAxis.
                  : d.overflows[0],
                d.overflows,
              ];
            })
            .sort((a, b) => a[1] - b[1]);
          const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d) =>
            d[2]
              .slice(
                0, // Aligned placements should not check their opposite crossAxis
                // side.
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "getAlignment"
                ])(d[0])
                  ? 2
                  : 3,
              )
              .every((v) => v <= 0),
          );
          const resetPlacement =
            ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null
              ? void 0
              : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
          if (resetPlacement !== placement) {
            return {
              data: {
                index: currentIndex + 1,
                overflows: allOverflows,
              },
              reset: {
                placement: resetPlacement,
              },
            };
          }
          return {};
        },
      };
    };
    /**
     * Optimizes the visibility of the floating element by flipping the `placement`
     * in order to keep it in view when the preferred placement(s) will overflow the
     * clipping boundary. Alternative to `autoPlacement`.
     * @see https://floating-ui.com/docs/flip
     */ const flip = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "flip",
        options,
        async fn(state) {
          var _middlewareData$arrow, _middlewareData$flip;
          const { placement, middlewareData, rects, initialPlacement, platform, elements } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            fallbackAxisSideDirection = "none",
            flipAlignment = true,
            ...detectOverflowOptions
          } = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "evaluate"
          ])(options, state);
          // If a reset by the arrow was caused due to an alignment offset being
          // added, we should skip any logic now since `flip()` has already done its
          // work.
          // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
          if (
            (_middlewareData$arrow = middlewareData.arrow) != null &&
            _middlewareData$arrow.alignmentOffset
          ) {
            return {};
          }
          const side = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getSide"
          ])(placement);
          const initialSideAxis = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getSideAxis"
          ])(initialPlacement);
          const isBasePlacement =
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getSide"
            ])(initialPlacement) === initialPlacement;
          const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
          const fallbackPlacements =
            specifiedFallbackPlacements ||
            (isBasePlacement || !flipAlignment
              ? [
                  (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "getOppositePlacement"
                  ])(initialPlacement),
                ]
              : (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "getExpandedPlacements"
                ])(initialPlacement));
          const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
          if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
            fallbackPlacements.push(
              ...(0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "getOppositeAxisPlacements"
              ])(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl),
            );
          }
          const placements = [initialPlacement, ...fallbackPlacements];
          const overflow = await platform.detectOverflow(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData =
            ((_middlewareData$flip = middlewareData.flip) == null
              ? void 0
              : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getAlignmentSides"
            ])(placement, rects, rtl);
            overflows.push(overflow[sides[0]], overflow[sides[1]]);
          }
          overflowsData = [
            ...overflowsData,
            {
              placement,
              overflows,
            },
          ];
          // One or more sides is overflowing.
          if (!overflows.every((side) => side <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex =
              (((_middlewareData$flip2 = middlewareData.flip) == null
                ? void 0
                : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements[nextIndex];
            if (nextPlacement) {
              const ignoreCrossAxisOverflow =
                checkCrossAxis === "alignment"
                  ? initialSideAxis !==
                    (0,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                      "getSideAxis"
                    ])(nextPlacement)
                  : false;
              if (
                !ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
                // overflows the main axis.
                overflowsData.every((d) =>
                  (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "getSideAxis"
                  ])(d.placement) === initialSideAxis
                    ? d.overflows[0] > 0
                    : true,
                )
              ) {
                // Try next placement and re-run the lifecycle.
                return {
                  data: {
                    index: nextIndex,
                    overflows: overflowsData,
                  },
                  reset: {
                    placement: nextPlacement,
                  },
                };
              }
            }
            // First, find the candidates that fit on the mainAxis side of overflow,
            // then find the placement that fits the best on the main crossAxis side.
            let resetPlacement =
              (_overflowsData$filter = overflowsData
                .filter((d) => d.overflows[0] <= 0)
                .sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null
                ? void 0
                : _overflowsData$filter.placement;
            // Otherwise fallback.
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$filter2;
                  const placement =
                    (_overflowsData$filter2 = overflowsData
                      .filter((d) => {
                        if (hasFallbackAxisSideDirection) {
                          const currentSideAxis = (0,
                          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                            "getSideAxis"
                          ])(d.placement);
                          return (
                            currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                            // reading directions favoring greater width.
                            currentSideAxis === "y"
                          );
                        }
                        return true;
                      })
                      .map((d) => [
                        d.placement,
                        d.overflows
                          .filter((overflow) => overflow > 0)
                          .reduce((acc, overflow) => acc + overflow, 0),
                      ])
                      .sort((a, b) => a[1] - b[1])[0]) == null
                      ? void 0
                      : _overflowsData$filter2[0];
                  if (placement) {
                    resetPlacement = placement;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement,
                },
              };
            }
          }
          return {};
        },
      };
    };
    function getSideOffsets(overflow, rect) {
      return {
        top: overflow.top - rect.height,
        right: overflow.right - rect.width,
        bottom: overflow.bottom - rect.height,
        left: overflow.left - rect.width,
      };
    }
    function isAnySideFullyClipped(overflow) {
      return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "sides"
      ].some((side) => overflow[side] >= 0);
    }
    /**
     * Provides data to hide the floating element in applicable situations, such as
     * when it is not in the same clipping context as the reference element.
     * @see https://floating-ui.com/docs/hide
     */ const hide = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "hide",
        options,
        async fn(state) {
          const { rects, platform } = state;
          const { strategy = "referenceHidden", ...detectOverflowOptions } = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "evaluate"
          ])(options, state);
          switch (strategy) {
            case "referenceHidden": {
              const overflow = await platform.detectOverflow(state, {
                ...detectOverflowOptions,
                elementContext: "reference",
              });
              const offsets = getSideOffsets(overflow, rects.reference);
              return {
                data: {
                  referenceHiddenOffsets: offsets,
                  referenceHidden: isAnySideFullyClipped(offsets),
                },
              };
            }
            case "escaped": {
              const overflow = await platform.detectOverflow(state, {
                ...detectOverflowOptions,
                altBoundary: true,
              });
              const offsets = getSideOffsets(overflow, rects.floating);
              return {
                data: {
                  escapedOffsets: offsets,
                  escaped: isAnySideFullyClipped(offsets),
                },
              };
            }
            default: {
              return {};
            }
          }
        },
      };
    };
    function getBoundingRect(rects) {
      const minX = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "min"
      ])(...rects.map((rect) => rect.left));
      const minY = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "min"
      ])(...rects.map((rect) => rect.top));
      const maxX = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "max"
      ])(...rects.map((rect) => rect.right));
      const maxY = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "max"
      ])(...rects.map((rect) => rect.bottom));
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY,
      };
    }
    function getRectsByLine(rects) {
      const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
      const groups = [];
      let prevRect = null;
      for (let i = 0; i < sortedRects.length; i++) {
        const rect = sortedRects[i];
        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
          groups.push([rect]);
        } else {
          groups[groups.length - 1].push(rect);
        }
        prevRect = rect;
      }
      return groups.map((rect) =>
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "rectToClientRect"
        ])(getBoundingRect(rect)),
      );
    }
    /**
     * Provides improved positioning for inline reference elements that can span
     * over multiple lines, such as hyperlinks or range selections.
     * @see https://floating-ui.com/docs/inline
     */ const inline = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "inline",
        options,
        async fn(state) {
          const { placement, elements, rects, platform, strategy } = state;
          // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a
          // ClientRect's bounds, despite the event listener being triggered. A
          // padding of 2 seems to handle this issue.
          const {
            padding = 2,
            x,
            y,
          } = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "evaluate"
          ])(options, state);
          const nativeClientRects = Array.from(
            (await (platform.getClientRects == null
              ? void 0
              : platform.getClientRects(elements.reference))) || [],
          );
          const clientRects = getRectsByLine(nativeClientRects);
          const fallback = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "rectToClientRect"
          ])(getBoundingRect(nativeClientRects));
          const paddingObject = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getPaddingObject"
          ])(padding);
          function getBoundingClientRect() {
            // There are two rects and they are disjoined.
            if (
              clientRects.length === 2 &&
              clientRects[0].left > clientRects[1].right &&
              x != null &&
              y != null
            ) {
              // Find the first rect in which the point is fully inside.
              return (
                clientRects.find(
                  (rect) =>
                    x > rect.left - paddingObject.left &&
                    x < rect.right + paddingObject.right &&
                    y > rect.top - paddingObject.top &&
                    y < rect.bottom + paddingObject.bottom,
                ) || fallback
              );
            }
            // There are 2 or more connected rects.
            if (clientRects.length >= 2) {
              if (
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "getSideAxis"
                ])(placement) === "y"
              ) {
                const firstRect = clientRects[0];
                const lastRect = clientRects[clientRects.length - 1];
                const isTop =
                  (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "getSide"
                  ])(placement) === "top";
                const top = firstRect.top;
                const bottom = lastRect.bottom;
                const left = isTop ? firstRect.left : lastRect.left;
                const right = isTop ? firstRect.right : lastRect.right;
                const width = right - left;
                const height = bottom - top;
                return {
                  top,
                  bottom,
                  left,
                  right,
                  width,
                  height,
                  x: left,
                  y: top,
                };
              }
              const isLeftSide =
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "getSide"
                ])(placement) === "left";
              const maxRight = (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "max"
              ])(...clientRects.map((rect) => rect.right));
              const minLeft = (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "min"
              ])(...clientRects.map((rect) => rect.left));
              const measureRects = clientRects.filter((rect) =>
                isLeftSide ? rect.left === minLeft : rect.right === maxRight,
              );
              const top = measureRects[0].top;
              const bottom = measureRects[measureRects.length - 1].bottom;
              const left = minLeft;
              const right = maxRight;
              const width = right - left;
              const height = bottom - top;
              return {
                top,
                bottom,
                left,
                right,
                width,
                height,
                x: left,
                y: top,
              };
            }
            return fallback;
          }
          const resetRects = await platform.getElementRects({
            reference: {
              getBoundingClientRect,
            },
            floating: elements.floating,
            strategy,
          });
          if (
            rects.reference.x !== resetRects.reference.x ||
            rects.reference.y !== resetRects.reference.y ||
            rects.reference.width !== resetRects.reference.width ||
            rects.reference.height !== resetRects.reference.height
          ) {
            return {
              reset: {
                rects: resetRects,
              },
            };
          }
          return {};
        },
      };
    };
    const originSides = /*#__PURE__*/ new Set(["left", "top"]);
    // For type backwards-compatibility, the `OffsetOptions` type was also
    // Derivable.
    async function convertValueToCoords(state, options) {
      const { placement, platform, elements } = state;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const side = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getSide"
      ])(placement);
      const alignment = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getAlignment"
      ])(placement);
      const isVertical =
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getSideAxis"
        ])(placement) === "y";
      const mainAxisMulti = originSides.has(side) ? -1 : 1;
      const crossAxisMulti = rtl && isVertical ? -1 : 1;
      const rawValue = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "evaluate"
      ])(options, state);
      // eslint-disable-next-line prefer-const
      let { mainAxis, crossAxis, alignmentAxis } =
        typeof rawValue === "number"
          ? {
              mainAxis: rawValue,
              crossAxis: 0,
              alignmentAxis: null,
            }
          : {
              mainAxis: rawValue.mainAxis || 0,
              crossAxis: rawValue.crossAxis || 0,
              alignmentAxis: rawValue.alignmentAxis,
            };
      if (alignment && typeof alignmentAxis === "number") {
        crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
      }
      return isVertical
        ? {
            x: crossAxis * crossAxisMulti,
            y: mainAxis * mainAxisMulti,
          }
        : {
            x: mainAxis * mainAxisMulti,
            y: crossAxis * crossAxisMulti,
          };
    }
    /**
     * Modifies the placement by translating the floating element along the
     * specified axes.
     * A number (shorthand for `mainAxis` or distance), or an axes configuration
     * object may be passed.
     * @see https://floating-ui.com/docs/offset
     */ const offset = function (options) {
      if (options === void 0) {
        options = 0;
      }
      return {
        name: "offset",
        options,
        async fn(state) {
          var _middlewareData$offse, _middlewareData$arrow;
          const { x, y, placement, middlewareData } = state;
          const diffCoords = await convertValueToCoords(state, options);
          // If the placement is the same and the arrow caused an alignment offset
          // then we don't need to change the positioning coordinates.
          if (
            placement ===
              ((_middlewareData$offse = middlewareData.offset) == null
                ? void 0
                : _middlewareData$offse.placement) &&
            (_middlewareData$arrow = middlewareData.arrow) != null &&
            _middlewareData$arrow.alignmentOffset
          ) {
            return {};
          }
          return {
            x: x + diffCoords.x,
            y: y + diffCoords.y,
            data: {
              ...diffCoords,
              placement,
            },
          };
        },
      };
    };
    /**
     * Optimizes the visibility of the floating element by shifting it in order to
     * keep it in view when it will overflow the clipping boundary.
     * @see https://floating-ui.com/docs/shift
     */ const shift = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "shift",
        options,
        async fn(state) {
          const { x, y, placement, platform } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref) => {
                let { x, y } = _ref;
                return {
                  x,
                  y,
                };
              },
            },
            ...detectOverflowOptions
          } = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "evaluate"
          ])(options, state);
          const coords = {
            x,
            y,
          };
          const overflow = await platform.detectOverflow(state, detectOverflowOptions);
          const crossAxis = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getSideAxis"
          ])(
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getSide"
            ])(placement),
          );
          const mainAxis = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getOppositeAxis"
          ])(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min = mainAxisCoord + overflow[minSide];
            const max = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "clamp"
            ])(min, mainAxisCoord, max);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min = crossAxisCoord + overflow[minSide];
            const max = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "clamp"
            ])(min, crossAxisCoord, max);
          }
          const limitedCoords = limiter.fn({
            ...state,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord,
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x,
              y: limitedCoords.y - y,
              enabled: {
                [mainAxis]: checkMainAxis,
                [crossAxis]: checkCrossAxis,
              },
            },
          };
        },
      };
    };
    /**
     * Built-in `limiter` that will stop `shift()` at a certain point.
     */ const limitShift = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        options,
        fn(state) {
          const { x, y, placement, rects, middlewareData } = state;
          const {
            offset = 0,
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
          } = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "evaluate"
          ])(options, state);
          const coords = {
            x,
            y,
          };
          const crossAxis = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getSideAxis"
          ])(placement);
          const mainAxis = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getOppositeAxis"
          ])(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          const rawOffset = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "evaluate"
          ])(offset, state);
          const computedOffset =
            typeof rawOffset === "number"
              ? {
                  mainAxis: rawOffset,
                  crossAxis: 0,
                }
              : {
                  mainAxis: 0,
                  crossAxis: 0,
                  ...rawOffset,
                };
          if (checkMainAxis) {
            const len = mainAxis === "y" ? "height" : "width";
            const limitMin =
              rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
            const limitMax =
              rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
            if (mainAxisCoord < limitMin) {
              mainAxisCoord = limitMin;
            } else if (mainAxisCoord > limitMax) {
              mainAxisCoord = limitMax;
            }
          }
          if (checkCrossAxis) {
            var _middlewareData$offse, _middlewareData$offse2;
            const len = mainAxis === "y" ? "width" : "height";
            const isOriginSide = originSides.has(
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "getSide"
              ])(placement),
            );
            const limitMin =
              rects.reference[crossAxis] -
              rects.floating[len] +
              (isOriginSide
                ? ((_middlewareData$offse = middlewareData.offset) == null
                    ? void 0
                    : _middlewareData$offse[crossAxis]) || 0
                : 0) +
              (isOriginSide ? 0 : computedOffset.crossAxis);
            const limitMax =
              rects.reference[crossAxis] +
              rects.reference[len] +
              (isOriginSide
                ? 0
                : ((_middlewareData$offse2 = middlewareData.offset) == null
                    ? void 0
                    : _middlewareData$offse2[crossAxis]) || 0) -
              (isOriginSide ? computedOffset.crossAxis : 0);
            if (crossAxisCoord < limitMin) {
              crossAxisCoord = limitMin;
            } else if (crossAxisCoord > limitMax) {
              crossAxisCoord = limitMax;
            }
          }
          return {
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord,
          };
        },
      };
    };
    /**
     * Provides data that allows you to change the size of the floating element —
     * for instance, prevent it from overflowing the clipping boundary or match the
     * width of the reference element.
     * @see https://floating-ui.com/docs/size
     */ const size = function (options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "size",
        options,
        async fn(state) {
          var _state$middlewareData, _state$middlewareData2;
          const { placement, rects, platform, elements } = state;
          const { apply = () => {}, ...detectOverflowOptions } = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "evaluate"
          ])(options, state);
          const overflow = await platform.detectOverflow(state, detectOverflowOptions);
          const side = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getSide"
          ])(placement);
          const alignment = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getAlignment"
          ])(placement);
          const isYAxis =
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getSideAxis"
            ])(placement) === "y";
          const { width, height } = rects.floating;
          let heightSide;
          let widthSide;
          if (side === "top" || side === "bottom") {
            heightSide = side;
            widthSide =
              alignment ===
              ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)))
                ? "start"
                : "end")
                ? "left"
                : "right";
          } else {
            widthSide = side;
            heightSide = alignment === "end" ? "top" : "bottom";
          }
          const maximumClippingHeight = height - overflow.top - overflow.bottom;
          const maximumClippingWidth = width - overflow.left - overflow.right;
          const overflowAvailableHeight = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "min"
          ])(height - overflow[heightSide], maximumClippingHeight);
          const overflowAvailableWidth = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "min"
          ])(width - overflow[widthSide], maximumClippingWidth);
          const noShift = !state.middlewareData.shift;
          let availableHeight = overflowAvailableHeight;
          let availableWidth = overflowAvailableWidth;
          if (
            (_state$middlewareData = state.middlewareData.shift) != null &&
            _state$middlewareData.enabled.x
          ) {
            availableWidth = maximumClippingWidth;
          }
          if (
            (_state$middlewareData2 = state.middlewareData.shift) != null &&
            _state$middlewareData2.enabled.y
          ) {
            availableHeight = maximumClippingHeight;
          }
          if (noShift && !alignment) {
            const xMin = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "max"
            ])(overflow.left, 0);
            const xMax = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "max"
            ])(overflow.right, 0);
            const yMin = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "max"
            ])(overflow.top, 0);
            const yMax = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "max"
            ])(overflow.bottom, 0);
            if (isYAxis) {
              availableWidth =
                width -
                2 *
                  (xMin !== 0 || xMax !== 0
                    ? xMin + xMax
                    : (0,
                      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                        "max"
                      ])(overflow.left, overflow.right));
            } else {
              availableHeight =
                height -
                2 *
                  (yMin !== 0 || yMax !== 0
                    ? yMin + yMax
                    : (0,
                      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                        "max"
                      ])(overflow.top, overflow.bottom));
            }
          }
          await apply({
            ...state,
            availableWidth,
            availableHeight,
          });
          const nextDimensions = await platform.getDimensions(elements.floating);
          if (width !== nextDimensions.width || height !== nextDimensions.height) {
            return {
              reset: {
                rects: true,
              },
            };
          }
          return {};
        },
      };
    };
  },
  "[project]/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs [app-client] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "arrow",
      () => arrow,
      "autoPlacement",
      () => autoPlacement,
      "autoUpdate",
      () => autoUpdate,
      "computePosition",
      () => computePosition,
      "detectOverflow",
      () => detectOverflow,
      "flip",
      () => flip,
      "hide",
      () => hide,
      "inline",
      () => inline,
      "limitShift",
      () => limitShift,
      "offset",
      () => offset,
      "platform",
      () => platform,
      "shift",
      () => shift,
      "size",
      () => size,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@floating-ui/core/dist/floating-ui.core.mjs [app-client] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs [app-client] (ecmascript)",
      );
    function getCssDimensions(element) {
      const css = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getComputedStyle"
      ])(element);
      // In testing environments, the `width` and `height` properties are empty
      // strings for SVG elements, returning NaN. Fallback to `0` in this case.
      let width = parseFloat(css.width) || 0;
      let height = parseFloat(css.height) || 0;
      const hasOffset = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "isHTMLElement"
      ])(element);
      const offsetWidth = hasOffset ? element.offsetWidth : width;
      const offsetHeight = hasOffset ? element.offsetHeight : height;
      const shouldFallback =
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "round"
        ])(width) !== offsetWidth ||
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "round"
        ])(height) !== offsetHeight;
      if (shouldFallback) {
        width = offsetWidth;
        height = offsetHeight;
      }
      return {
        width,
        height,
        $: shouldFallback,
      };
    }
    function unwrapElement(element) {
      return !(0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "isElement"
      ])(element)
        ? element.contextElement
        : element;
    }
    function getScale(element) {
      const domElement = unwrapElement(element);
      if (
        !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isHTMLElement"
        ])(domElement)
      ) {
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "createCoords"
        ])(1);
      }
      const rect = domElement.getBoundingClientRect();
      const { width, height, $ } = getCssDimensions(domElement);
      let x =
        ($
          ? (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "round"
            ])(rect.width)
          : rect.width) / width;
      let y =
        ($
          ? (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "round"
            ])(rect.height)
          : rect.height) / height;
      // 0, NaN, or Infinity should always fallback to 1.
      if (!x || !Number.isFinite(x)) {
        x = 1;
      }
      if (!y || !Number.isFinite(y)) {
        y = 1;
      }
      return {
        x,
        y,
      };
    }
    const noOffsets = /*#__PURE__*/ (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "createCoords"
    ])(0);
    function getVisualOffsets(element) {
      const win = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getWindow"
      ])(element);
      if (
        !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isWebKit"
        ])() ||
        !win.visualViewport
      ) {
        return noOffsets;
      }
      return {
        x: win.visualViewport.offsetLeft,
        y: win.visualViewport.offsetTop,
      };
    }
    function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      if (
        !floatingOffsetParent ||
        (isFixed &&
          floatingOffsetParent !==
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getWindow"
            ])(element))
      ) {
        return false;
      }
      return isFixed;
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      const clientRect = element.getBoundingClientRect();
      const domElement = unwrapElement(element);
      let scale = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "createCoords"
      ])(1);
      if (includeScale) {
        if (offsetParent) {
          if (
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "isElement"
            ])(offsetParent)
          ) {
            scale = getScale(offsetParent);
          }
        } else {
          scale = getScale(element);
        }
      }
      const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent)
        ? getVisualOffsets(domElement)
        : (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "createCoords"
          ])(0);
      let x = (clientRect.left + visualOffsets.x) / scale.x;
      let y = (clientRect.top + visualOffsets.y) / scale.y;
      let width = clientRect.width / scale.x;
      let height = clientRect.height / scale.y;
      if (domElement) {
        const win = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getWindow"
        ])(domElement);
        const offsetWin =
          offsetParent &&
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "isElement"
          ])(offsetParent)
            ? (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "getWindow"
              ])(offsetParent)
            : offsetParent;
        let currentWin = win;
        let currentIFrame = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getFrameElement"
        ])(currentWin);
        while (currentIFrame && offsetParent && offsetWin !== currentWin) {
          const iframeScale = getScale(currentIFrame);
          const iframeRect = currentIFrame.getBoundingClientRect();
          const css = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getComputedStyle"
          ])(currentIFrame);
          const left =
            iframeRect.left +
            (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
          const top =
            iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
          x *= iframeScale.x;
          y *= iframeScale.y;
          width *= iframeScale.x;
          height *= iframeScale.y;
          x += left;
          y += top;
          currentWin = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getWindow"
          ])(currentIFrame);
          currentIFrame = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getFrameElement"
          ])(currentWin);
        }
      }
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "rectToClientRect"
      ])({
        width,
        height,
        x,
        y,
      });
    }
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    function getWindowScrollBarX(element, rect) {
      const leftScroll = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getNodeScroll"
      ])(element).scrollLeft;
      if (!rect) {
        return (
          getBoundingClientRect(
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getDocumentElement"
            ])(element),
          ).left + leftScroll
        );
      }
      return rect.left + leftScroll;
    }
    function getHTMLOffset(documentElement, scroll) {
      const htmlRect = documentElement.getBoundingClientRect();
      const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
      const y = htmlRect.top + scroll.scrollTop;
      return {
        x,
        y,
      };
    }
    function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
      let { elements, rect, offsetParent, strategy } = _ref;
      const isFixed = strategy === "fixed";
      const documentElement = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getDocumentElement"
      ])(offsetParent);
      const topLayer = elements
        ? (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "isTopLayer"
          ])(elements.floating)
        : false;
      if (offsetParent === documentElement || (topLayer && isFixed)) {
        return rect;
      }
      let scroll = {
        scrollLeft: 0,
        scrollTop: 0,
      };
      let scale = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "createCoords"
      ])(1);
      const offsets = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "createCoords"
      ])(0);
      const isOffsetParentAnElement = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "isHTMLElement"
      ])(offsetParent);
      if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getNodeName"
          ])(offsetParent) !== "body" ||
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "isOverflowElement"
          ])(documentElement)
        ) {
          scroll = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getNodeScroll"
          ])(offsetParent);
        }
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "isHTMLElement"
          ])(offsetParent)
        ) {
          const offsetRect = getBoundingClientRect(offsetParent);
          scale = getScale(offsetParent);
          offsets.x = offsetRect.x + offsetParent.clientLeft;
          offsets.y = offsetRect.y + offsetParent.clientTop;
        }
      }
      const htmlOffset =
        documentElement && !isOffsetParentAnElement && !isFixed
          ? getHTMLOffset(documentElement, scroll)
          : (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "createCoords"
            ])(0);
      return {
        width: rect.width * scale.x,
        height: rect.height * scale.y,
        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y,
      };
    }
    function getClientRects(element) {
      return Array.from(element.getClientRects());
    }
    // Gets the entire size of the scrollable document area, even extending outside
    // of the `<html>` and `<body>` rect bounds if horizontally scrollable.
    function getDocumentRect(element) {
      const html = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getDocumentElement"
      ])(element);
      const scroll = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getNodeScroll"
      ])(element);
      const body = element.ownerDocument.body;
      const width = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "max"
      ])(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
      const height = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "max"
      ])(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
      let x = -scroll.scrollLeft + getWindowScrollBarX(element);
      const y = -scroll.scrollTop;
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getComputedStyle"
        ])(body).direction === "rtl"
      ) {
        x +=
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "max"
          ])(html.clientWidth, body.clientWidth) - width;
      }
      return {
        width,
        height,
        x,
        y,
      };
    }
    // Safety check: ensure the scrollbar space is reasonable in case this
    // calculation is affected by unusual styles.
    // Most scrollbars leave 15-18px of space.
    const SCROLLBAR_MAX = 25;
    function getViewportRect(element, strategy) {
      const win = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getWindow"
      ])(element);
      const html = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getDocumentElement"
      ])(element);
      const visualViewport = win.visualViewport;
      let width = html.clientWidth;
      let height = html.clientHeight;
      let x = 0;
      let y = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        const visualViewportBased = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isWebKit"
        ])();
        if (!visualViewportBased || (visualViewportBased && strategy === "fixed")) {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }
      const windowScrollbarX = getWindowScrollBarX(html);
      // <html> `overflow: hidden` + `scrollbar-gutter: stable` reduces the
      // visual width of the <html> but this is not considered in the size
      // of `html.clientWidth`.
      if (windowScrollbarX <= 0) {
        const doc = html.ownerDocument;
        const body = doc.body;
        const bodyStyles = getComputedStyle(body);
        const bodyMarginInline =
          doc.compatMode === "CSS1Compat"
            ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0
            : 0;
        const clippingStableScrollbarWidth = Math.abs(
          html.clientWidth - body.clientWidth - bodyMarginInline,
        );
        if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
          width -= clippingStableScrollbarWidth;
        }
      } else if (windowScrollbarX <= SCROLLBAR_MAX) {
        // If the <body> scrollbar is on the left, the width needs to be extended
        // by the scrollbar amount so there isn't extra space on the right.
        width += windowScrollbarX;
      }
      return {
        width,
        height,
        x,
        y,
      };
    }
    const absoluteOrFixed = /*#__PURE__*/ new Set(["absolute", "fixed"]);
    // Returns the inner client rect, subtracting scrollbars if present.
    function getInnerBoundingClientRect(element, strategy) {
      const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
      const top = clientRect.top + element.clientTop;
      const left = clientRect.left + element.clientLeft;
      const scale = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "isHTMLElement"
      ])(element)
        ? getScale(element)
        : (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "createCoords"
          ])(1);
      const width = element.clientWidth * scale.x;
      const height = element.clientHeight * scale.y;
      const x = left * scale.x;
      const y = top * scale.y;
      return {
        width,
        height,
        x,
        y,
      };
    }
    function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
      let rect;
      if (clippingAncestor === "viewport") {
        rect = getViewportRect(element, strategy);
      } else if (clippingAncestor === "document") {
        rect = getDocumentRect(
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getDocumentElement"
          ])(element),
        );
      } else if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isElement"
        ])(clippingAncestor)
      ) {
        rect = getInnerBoundingClientRect(clippingAncestor, strategy);
      } else {
        const visualOffsets = getVisualOffsets(element);
        rect = {
          x: clippingAncestor.x - visualOffsets.x,
          y: clippingAncestor.y - visualOffsets.y,
          width: clippingAncestor.width,
          height: clippingAncestor.height,
        };
      }
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "rectToClientRect"
      ])(rect);
    }
    function hasFixedPositionAncestor(element, stopNode) {
      const parentNode = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getParentNode"
      ])(element);
      if (
        parentNode === stopNode ||
        !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isElement"
        ])(parentNode) ||
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isLastTraversableNode"
        ])(parentNode)
      ) {
        return false;
      }
      return (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getComputedStyle"
        ])(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode)
      );
    }
    // A "clipping ancestor" is an `overflow` element with the characteristic of
    // clipping (or hiding) child elements. This returns all clipping ancestors
    // of the given element up the tree.
    function getClippingElementAncestors(element, cache) {
      const cachedResult = cache.get(element);
      if (cachedResult) {
        return cachedResult;
      }
      let result = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getOverflowAncestors"
      ])(element, [], false).filter(
        (el) =>
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "isElement"
          ])(el) &&
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getNodeName"
          ])(el) !== "body",
      );
      let currentContainingBlockComputedStyle = null;
      const elementIsFixed =
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getComputedStyle"
        ])(element).position === "fixed";
      let currentNode = elementIsFixed
        ? (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getParentNode"
          ])(element)
        : element;
      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
      while (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isElement"
        ])(currentNode) &&
        !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isLastTraversableNode"
        ])(currentNode)
      ) {
        const computedStyle = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getComputedStyle"
        ])(currentNode);
        const currentNodeIsContaining = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isContainingBlock"
        ])(currentNode);
        if (!currentNodeIsContaining && computedStyle.position === "fixed") {
          currentContainingBlockComputedStyle = null;
        }
        const shouldDropCurrentNode = elementIsFixed
          ? !currentNodeIsContaining && !currentContainingBlockComputedStyle
          : (!currentNodeIsContaining &&
              computedStyle.position === "static" &&
              !!currentContainingBlockComputedStyle &&
              absoluteOrFixed.has(currentContainingBlockComputedStyle.position)) ||
            ((0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "isOverflowElement"
            ])(currentNode) &&
              !currentNodeIsContaining &&
              hasFixedPositionAncestor(element, currentNode));
        if (shouldDropCurrentNode) {
          // Drop non-containing blocks.
          result = result.filter((ancestor) => ancestor !== currentNode);
        } else {
          // Record last containing block for next iteration.
          currentContainingBlockComputedStyle = computedStyle;
        }
        currentNode = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getParentNode"
        ])(currentNode);
      }
      cache.set(element, result);
      return result;
    }
    // Gets the maximum area that the element is visible in due to any number of
    // clipping ancestors.
    function getClippingRect(_ref) {
      let { element, boundary, rootBoundary, strategy } = _ref;
      const elementClippingAncestors =
        boundary === "clippingAncestors"
          ? (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "isTopLayer"
            ])(element)
            ? []
            : getClippingElementAncestors(element, this._c)
          : [].concat(boundary);
      const clippingAncestors = [...elementClippingAncestors, rootBoundary];
      const firstClippingAncestor = clippingAncestors[0];
      const clippingRect = clippingAncestors.reduce(
        (accRect, clippingAncestor) => {
          const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
          accRect.top = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "max"
          ])(rect.top, accRect.top);
          accRect.right = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "min"
          ])(rect.right, accRect.right);
          accRect.bottom = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "min"
          ])(rect.bottom, accRect.bottom);
          accRect.left = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "max"
          ])(rect.left, accRect.left);
          return accRect;
        },
        getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy),
      );
      return {
        width: clippingRect.right - clippingRect.left,
        height: clippingRect.bottom - clippingRect.top,
        x: clippingRect.left,
        y: clippingRect.top,
      };
    }
    function getDimensions(element) {
      const { width, height } = getCssDimensions(element);
      return {
        width,
        height,
      };
    }
    function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
      const isOffsetParentAnElement = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "isHTMLElement"
      ])(offsetParent);
      const documentElement = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getDocumentElement"
      ])(offsetParent);
      const isFixed = strategy === "fixed";
      const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
      let scroll = {
        scrollLeft: 0,
        scrollTop: 0,
      };
      const offsets = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "createCoords"
      ])(0);
      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
      // Firefox with layout.scrollbar.side = 3 in about:config to test this.
      function setLeftRTLScrollbarOffset() {
        offsets.x = getWindowScrollBarX(documentElement);
      }
      if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getNodeName"
          ])(offsetParent) !== "body" ||
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "isOverflowElement"
          ])(documentElement)
        ) {
          scroll = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getNodeScroll"
          ])(offsetParent);
        }
        if (isOffsetParentAnElement) {
          const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
          offsets.x = offsetRect.x + offsetParent.clientLeft;
          offsets.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) {
          setLeftRTLScrollbarOffset();
        }
      }
      if (isFixed && !isOffsetParentAnElement && documentElement) {
        setLeftRTLScrollbarOffset();
      }
      const htmlOffset =
        documentElement && !isOffsetParentAnElement && !isFixed
          ? getHTMLOffset(documentElement, scroll)
          : (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "createCoords"
            ])(0);
      const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
      const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
      return {
        x,
        y,
        width: rect.width,
        height: rect.height,
      };
    }
    function isStaticPositioned(element) {
      return (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getComputedStyle"
        ])(element).position === "static"
      );
    }
    function getTrueOffsetParent(element, polyfill) {
      if (
        !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isHTMLElement"
        ])(element) ||
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getComputedStyle"
        ])(element).position === "fixed"
      ) {
        return null;
      }
      if (polyfill) {
        return polyfill(element);
      }
      let rawOffsetParent = element.offsetParent;
      // Firefox returns the <html> element as the offsetParent if it's non-static,
      // while Chrome and Safari return the <body> element. The <body> element must
      // be used to perform the correct calculations even if the <html> element is
      // non-static.
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getDocumentElement"
        ])(element) === rawOffsetParent
      ) {
        rawOffsetParent = rawOffsetParent.ownerDocument.body;
      }
      return rawOffsetParent;
    }
    // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.
    function getOffsetParent(element, polyfill) {
      const win = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getWindow"
      ])(element);
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isTopLayer"
        ])(element)
      ) {
        return win;
      }
      if (
        !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isHTMLElement"
        ])(element)
      ) {
        let svgOffsetParent = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getParentNode"
        ])(element);
        while (
          svgOffsetParent &&
          !(0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "isLastTraversableNode"
          ])(svgOffsetParent)
        ) {
          if (
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "isElement"
            ])(svgOffsetParent) &&
            !isStaticPositioned(svgOffsetParent)
          ) {
            return svgOffsetParent;
          }
          svgOffsetParent = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getParentNode"
          ])(svgOffsetParent);
        }
        return win;
      }
      let offsetParent = getTrueOffsetParent(element, polyfill);
      while (
        offsetParent &&
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isTableElement"
        ])(offsetParent) &&
        isStaticPositioned(offsetParent)
      ) {
        offsetParent = getTrueOffsetParent(offsetParent, polyfill);
      }
      if (
        offsetParent &&
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isLastTraversableNode"
        ])(offsetParent) &&
        isStaticPositioned(offsetParent) &&
        !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isContainingBlock"
        ])(offsetParent)
      ) {
        return win;
      }
      return (
        offsetParent ||
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getContainingBlock"
        ])(element) ||
        win
      );
    }
    const getElementRects = async function (data) {
      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
      const getDimensionsFn = this.getDimensions;
      const floatingDimensions = await getDimensionsFn(data.floating);
      return {
        reference: getRectRelativeToOffsetParent(
          data.reference,
          await getOffsetParentFn(data.floating),
          data.strategy,
        ),
        floating: {
          x: 0,
          y: 0,
          width: floatingDimensions.width,
          height: floatingDimensions.height,
        },
      };
    };
    function isRTL(element) {
      return (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getComputedStyle"
        ])(element).direction === "rtl"
      );
    }
    const platform = {
      convertOffsetParentRelativeRectToViewportRelativeRect,
      getDocumentElement:
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "getDocumentElement"
        ],
      getClippingRect,
      getOffsetParent,
      getElementRects,
      getClientRects,
      getDimensions,
      getScale,
      isElement:
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "isElement"
        ],
      isRTL,
    };
    function rectsAreEqual(a, b) {
      return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
    }
    // https://samthor.au/2021/observing-dom/
    function observeMove(element, onMove) {
      let io = null;
      let timeoutId;
      const root = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "getDocumentElement"
      ])(element);
      function cleanup() {
        var _io;
        clearTimeout(timeoutId);
        (_io = io) == null || _io.disconnect();
        io = null;
      }
      function refresh(skip, threshold) {
        if (skip === void 0) {
          skip = false;
        }
        if (threshold === void 0) {
          threshold = 1;
        }
        cleanup();
        const elementRectForRootMargin = element.getBoundingClientRect();
        const { left, top, width, height } = elementRectForRootMargin;
        if (!skip) {
          onMove();
        }
        if (!width || !height) {
          return;
        }
        const insetTop = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "floor"
        ])(top);
        const insetRight = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "floor"
        ])(root.clientWidth - (left + width));
        const insetBottom = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "floor"
        ])(root.clientHeight - (top + height));
        const insetLeft = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "floor"
        ])(left);
        const rootMargin =
          -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
        const options = {
          rootMargin,
          threshold:
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "max"
            ])(
              0,
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "min"
              ])(1, threshold),
            ) || 1,
        };
        let isFirstUpdate = true;
        function handleObserve(entries) {
          const ratio = entries[0].intersectionRatio;
          if (ratio !== threshold) {
            if (!isFirstUpdate) {
              return refresh();
            }
            if (!ratio) {
              // If the reference is clipped, the ratio is 0. Throttle the refresh
              // to prevent an infinite loop of updates.
              timeoutId = setTimeout(() => {
                refresh(false, 1e-7);
              }, 1000);
            } else {
              refresh(false, ratio);
            }
          }
          if (
            ratio === 1 &&
            !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())
          ) {
            // It's possible that even though the ratio is reported as 1, the
            // element is not actually fully within the IntersectionObserver's root
            // area anymore. This can happen under performance constraints. This may
            // be a bug in the browser's IntersectionObserver implementation. To
            // work around this, we compare the element's bounding rect now with
            // what it was at the time we created the IntersectionObserver. If they
            // are not equal then the element moved, so we refresh.
            refresh();
          }
          isFirstUpdate = false;
        }
        // Older browsers don't support a `document` as the root and will throw an
        // error.
        try {
          io = new IntersectionObserver(handleObserve, {
            ...options,
            // Handle <iframe>s
            root: root.ownerDocument,
          });
        } catch (_e) {
          io = new IntersectionObserver(handleObserve, options);
        }
        io.observe(element);
      }
      refresh(true);
      return cleanup;
    }
    /**
     * Automatically updates the position of the floating element when necessary.
     * Should only be called when the floating element is mounted on the DOM or
     * visible on the screen.
     * @returns cleanup function that should be invoked when the floating element is
     * removed from the DOM or hidden from the screen.
     * @see https://floating-ui.com/docs/autoUpdate
     */ function autoUpdate(reference, floating, update, options) {
      if (options === void 0) {
        options = {};
      }
      const {
        ancestorScroll = true,
        ancestorResize = true,
        elementResize = typeof ResizeObserver === "function",
        layoutShift = typeof IntersectionObserver === "function",
        animationFrame = false,
      } = options;
      const referenceEl = unwrapElement(reference);
      const ancestors =
        ancestorScroll || ancestorResize
          ? [
              ...(referenceEl
                ? (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "getOverflowAncestors"
                  ])(referenceEl)
                : []),
              ...(0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$utils$2f$dist$2f$floating$2d$ui$2e$utils$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "getOverflowAncestors"
              ])(floating),
            ]
          : [];
      ancestors.forEach((ancestor) => {
        ancestorScroll &&
          ancestor.addEventListener("scroll", update, {
            passive: true,
          });
        ancestorResize && ancestor.addEventListener("resize", update);
      });
      const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
      let reobserveFrame = -1;
      let resizeObserver = null;
      if (elementResize) {
        resizeObserver = new ResizeObserver((_ref) => {
          let [firstEntry] = _ref;
          if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
            // Prevent update loops when using the `size` middleware.
            // https://github.com/floating-ui/floating-ui/issues/1740
            resizeObserver.unobserve(floating);
            cancelAnimationFrame(reobserveFrame);
            reobserveFrame = requestAnimationFrame(() => {
              var _resizeObserver;
              (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
            });
          }
          update();
        });
        if (referenceEl && !animationFrame) {
          resizeObserver.observe(referenceEl);
        }
        resizeObserver.observe(floating);
      }
      let frameId;
      let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
      if (animationFrame) {
        frameLoop();
      }
      function frameLoop() {
        const nextRefRect = getBoundingClientRect(reference);
        if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
          update();
        }
        prevRefRect = nextRefRect;
        frameId = requestAnimationFrame(frameLoop);
      }
      update();
      return () => {
        var _resizeObserver2;
        ancestors.forEach((ancestor) => {
          ancestorScroll && ancestor.removeEventListener("scroll", update);
          ancestorResize && ancestor.removeEventListener("resize", update);
        });
        cleanupIo == null || cleanupIo();
        (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
        resizeObserver = null;
        if (animationFrame) {
          cancelAnimationFrame(frameId);
        }
      };
    }
    /**
     * Resolves with an object of overflow side offsets that determine how much the
     * element is overflowing a given clipping boundary on each side.
     * - positive = overflowing the boundary by that number of pixels
     * - negative = how many pixels left before it will overflow
     * - 0 = lies flush with the boundary
     * @see https://floating-ui.com/docs/detectOverflow
     */ const detectOverflow =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "detectOverflow"
      ];
    /**
     * Modifies the placement by translating the floating element along the
     * specified axes.
     * A number (shorthand for `mainAxis` or distance), or an axes configuration
     * object may be passed.
     * @see https://floating-ui.com/docs/offset
     */ const offset =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "offset"
      ];
    /**
     * Optimizes the visibility of the floating element by choosing the placement
     * that has the most space available automatically, without needing to specify a
     * preferred placement. Alternative to `flip`.
     * @see https://floating-ui.com/docs/autoPlacement
     */ const autoPlacement =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "autoPlacement"
      ];
    /**
     * Optimizes the visibility of the floating element by shifting it in order to
     * keep it in view when it will overflow the clipping boundary.
     * @see https://floating-ui.com/docs/shift
     */ const shift =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "shift"
      ];
    /**
     * Optimizes the visibility of the floating element by flipping the `placement`
     * in order to keep it in view when the preferred placement(s) will overflow the
     * clipping boundary. Alternative to `autoPlacement`.
     * @see https://floating-ui.com/docs/flip
     */ const flip =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "flip"
      ];
    /**
     * Provides data that allows you to change the size of the floating element —
     * for instance, prevent it from overflowing the clipping boundary or match the
     * width of the reference element.
     * @see https://floating-ui.com/docs/size
     */ const size =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "size"
      ];
    /**
     * Provides data to hide the floating element in applicable situations, such as
     * when it is not in the same clipping context as the reference element.
     * @see https://floating-ui.com/docs/hide
     */ const hide =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "hide"
      ];
    /**
     * Provides data to position an inner element of the floating element so that it
     * appears centered to the reference element.
     * @see https://floating-ui.com/docs/arrow
     */ const arrow =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "arrow"
      ];
    /**
     * Provides improved positioning for inline reference elements that can span
     * over multiple lines, such as hyperlinks or range selections.
     * @see https://floating-ui.com/docs/inline
     */ const inline =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "inline"
      ];
    /**
     * Built-in `limiter` that will stop `shift()` at a certain point.
     */ const limitShift =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "limitShift"
      ];
    /**
     * Computes the `x` and `y` coordinates that will place the floating element
     * next to a given reference element.
     */ const computePosition = (reference, floating, options) => {
      // This caches the expensive `getClippingElementAncestors` function so that
      // multiple lifecycle resets re-use the same result. It only lives for a
      // single call. If other functions become expensive, we can add them as well.
      const cache = new Map();
      const mergedOptions = {
        platform,
        ...options,
      };
      const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache,
      };
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$core$2f$dist$2f$floating$2d$ui$2e$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "computePosition"
      ])(reference, floating, {
        ...mergedOptions,
        platform: platformWithCache,
      });
    };
  },
  "[project]/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs [app-client] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "arrow",
      () => arrow,
      "autoPlacement",
      () => autoPlacement,
      "flip",
      () => flip,
      "hide",
      () => hide,
      "inline",
      () => inline,
      "limitShift",
      () => limitShift,
      "offset",
      () => offset,
      "shift",
      () => shift,
      "size",
      () => size,
      "useFloating",
      () => useFloating,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs [app-client] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)",
      );
    var isClient = typeof document !== "undefined";
    var noop = function noop() {};
    var index = isClient
      ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useLayoutEffect"
        ]
      : noop;
    // Fork of `fast-deep-equal` that only does the comparisons we need and compares
    // functions
    function deepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a !== typeof b) {
        return false;
      }
      if (typeof a === "function" && a.toString() === b.toString()) {
        return true;
      }
      let length;
      let i;
      let keys;
      if (a && b && typeof a === "object") {
        if (Array.isArray(a)) {
          length = a.length;
          if (length !== b.length) return false;
          for (i = length; i-- !== 0; ) {
            if (!deepEqual(a[i], b[i])) {
              return false;
            }
          }
          return true;
        }
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) {
          return false;
        }
        for (i = length; i-- !== 0; ) {
          if (!{}.hasOwnProperty.call(b, keys[i])) {
            return false;
          }
        }
        for (i = length; i-- !== 0; ) {
          const key = keys[i];
          if (key === "_owner" && a.$$typeof) {
            continue;
          }
          if (!deepEqual(a[key], b[key])) {
            return false;
          }
        }
        return true;
      }
      return a !== a && b !== b;
    }
    function getDPR(element) {
      if (typeof window === "undefined") {
        return 1;
      }
      const win = element.ownerDocument.defaultView || window;
      return win.devicePixelRatio || 1;
    }
    function roundByDPR(element, value) {
      const dpr = getDPR(element);
      return Math.round(value * dpr) / dpr;
    }
    function useLatestRef(value) {
      const ref =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useRef"
        ](value);
      index(() => {
        ref.current = value;
      });
      return ref;
    }
    /**
     * Provides data to position a floating element.
     * @see https://floating-ui.com/docs/useFloating
     */ function useFloating(options) {
      if (options === void 0) {
        options = {};
      }
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware = [],
        platform,
        elements: { reference: externalReference, floating: externalFloating } = {},
        transform = true,
        whileElementsMounted,
        open,
      } = options;
      const [data, setData] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useState"
        ]({
          x: 0,
          y: 0,
          strategy,
          placement,
          middlewareData: {},
          isPositioned: false,
        });
      const [latestMiddleware, setLatestMiddleware] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useState"
        ](middleware);
      if (!deepEqual(latestMiddleware, middleware)) {
        setLatestMiddleware(middleware);
      }
      const [_reference, _setReference] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useState"
        ](null);
      const [_floating, _setFloating] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useState"
        ](null);
      const setReference =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useCallback"
        ](
          {
            "useFloating.useCallback[setReference]": (node) => {
              if (node !== referenceRef.current) {
                referenceRef.current = node;
                _setReference(node);
              }
            },
          }["useFloating.useCallback[setReference]"],
          [],
        );
      const setFloating =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useCallback"
        ](
          {
            "useFloating.useCallback[setFloating]": (node) => {
              if (node !== floatingRef.current) {
                floatingRef.current = node;
                _setFloating(node);
              }
            },
          }["useFloating.useCallback[setFloating]"],
          [],
        );
      const referenceEl = externalReference || _reference;
      const floatingEl = externalFloating || _floating;
      const referenceRef =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useRef"
        ](null);
      const floatingRef =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useRef"
        ](null);
      const dataRef =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useRef"
        ](data);
      const hasWhileElementsMounted = whileElementsMounted != null;
      const whileElementsMountedRef = useLatestRef(whileElementsMounted);
      const platformRef = useLatestRef(platform);
      const openRef = useLatestRef(open);
      const update =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useCallback"
        ](
          {
            "useFloating.useCallback[update]": () => {
              if (!referenceRef.current || !floatingRef.current) {
                return;
              }
              const config = {
                placement,
                strategy,
                middleware: latestMiddleware,
              };
              if (platformRef.current) {
                config.platform = platformRef.current;
              }
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "computePosition"
              ])(referenceRef.current, floatingRef.current, config).then(
                {
                  "useFloating.useCallback[update]": (data) => {
                    const fullData = {
                      ...data,
                      // The floating element's position may be recomputed while it's closed
                      // but still mounted (such as when transitioning out). To ensure
                      // `isPositioned` will be `false` initially on the next open, avoid
                      // setting it to `true` when `open === false` (must be specified).
                      isPositioned: openRef.current !== false,
                    };
                    if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
                      dataRef.current = fullData;
                      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                        "flushSync"
                      ](
                        {
                          "useFloating.useCallback[update]": () => {
                            setData(fullData);
                          },
                        }["useFloating.useCallback[update]"],
                      );
                    }
                  },
                }["useFloating.useCallback[update]"],
              );
            },
          }["useFloating.useCallback[update]"],
          [latestMiddleware, placement, strategy, platformRef, openRef],
        );
      index(() => {
        if (open === false && dataRef.current.isPositioned) {
          dataRef.current.isPositioned = false;
          setData((data) => ({
            ...data,
            isPositioned: false,
          }));
        }
      }, [open]);
      const isMountedRef =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useRef"
        ](false);
      index(() => {
        isMountedRef.current = true;
        return () => {
          isMountedRef.current = false;
        };
      }, []);
      index(() => {
        if (referenceEl) referenceRef.current = referenceEl;
        if (floatingEl) floatingRef.current = floatingEl;
        if (referenceEl && floatingEl) {
          if (whileElementsMountedRef.current) {
            return whileElementsMountedRef.current(referenceEl, floatingEl, update);
          }
          update();
        }
      }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
      const refs =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useMemo"
        ](
          {
            "useFloating.useMemo[refs]": () => ({
              reference: referenceRef,
              floating: floatingRef,
              setReference,
              setFloating,
            }),
          }["useFloating.useMemo[refs]"],
          [setReference, setFloating],
        );
      const elements =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useMemo"
        ](
          {
            "useFloating.useMemo[elements]": () => ({
              reference: referenceEl,
              floating: floatingEl,
            }),
          }["useFloating.useMemo[elements]"],
          [referenceEl, floatingEl],
        );
      const floatingStyles =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useMemo"
        ](
          {
            "useFloating.useMemo[floatingStyles]": () => {
              const initialStyles = {
                position: strategy,
                left: 0,
                top: 0,
              };
              if (!elements.floating) {
                return initialStyles;
              }
              const x = roundByDPR(elements.floating, data.x);
              const y = roundByDPR(elements.floating, data.y);
              if (transform) {
                return {
                  ...initialStyles,
                  transform: "translate(" + x + "px, " + y + "px)",
                  ...(getDPR(elements.floating) >= 1.5 && {
                    willChange: "transform",
                  }),
                };
              }
              return {
                position: strategy,
                left: x,
                top: y,
              };
            },
          }["useFloating.useMemo[floatingStyles]"],
          [strategy, transform, elements.floating, data.x, data.y],
        );
      return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useMemo"
      ](
        {
          "useFloating.useMemo": () => ({
            ...data,
            update,
            refs,
            elements,
            floatingStyles,
          }),
        }["useFloating.useMemo"],
        [data, update, refs, elements, floatingStyles],
      );
    }
    /**
     * Provides data to position an inner element of the floating element so that it
     * appears centered to the reference element.
     * This wraps the core `arrow` middleware to allow React refs as the element.
     * @see https://floating-ui.com/docs/arrow
     */ const arrow$1 = (options) => {
      function isRef(value) {
        return {}.hasOwnProperty.call(value, "current");
      }
      return {
        name: "arrow",
        options,
        fn(state) {
          const { element, padding } = typeof options === "function" ? options(state) : options;
          if (element && isRef(element)) {
            if (element.current != null) {
              return (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "arrow"
              ])({
                element: element.current,
                padding,
              }).fn(state);
            }
            return {};
          }
          if (element) {
            return (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "arrow"
            ])({
              element,
              padding,
            }).fn(state);
          }
          return {};
        },
      };
    };
    /**
     * Modifies the placement by translating the floating element along the
     * specified axes.
     * A number (shorthand for `mainAxis` or distance), or an axes configuration
     * object may be passed.
     * @see https://floating-ui.com/docs/offset
     */ const offset = (options, deps) => ({
      ...(0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "offset"
      ])(options),
      options: [options, deps],
    });
    /**
     * Optimizes the visibility of the floating element by shifting it in order to
     * keep it in view when it will overflow the clipping boundary.
     * @see https://floating-ui.com/docs/shift
     */ const shift = (options, deps) => ({
      ...(0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "shift"
      ])(options),
      options: [options, deps],
    });
    /**
     * Built-in `limiter` that will stop `shift()` at a certain point.
     */ const limitShift = (options, deps) => ({
      ...(0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "limitShift"
      ])(options),
      options: [options, deps],
    });
    /**
     * Optimizes the visibility of the floating element by flipping the `placement`
     * in order to keep it in view when the preferred placement(s) will overflow the
     * clipping boundary. Alternative to `autoPlacement`.
     * @see https://floating-ui.com/docs/flip
     */ const flip = (options, deps) => ({
      ...(0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "flip"
      ])(options),
      options: [options, deps],
    });
    /**
     * Provides data that allows you to change the size of the floating element —
     * for instance, prevent it from overflowing the clipping boundary or match the
     * width of the reference element.
     * @see https://floating-ui.com/docs/size
     */ const size = (options, deps) => ({
      ...(0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "size"
      ])(options),
      options: [options, deps],
    });
    /**
     * Optimizes the visibility of the floating element by choosing the placement
     * that has the most space available automatically, without needing to specify a
     * preferred placement. Alternative to `flip`.
     * @see https://floating-ui.com/docs/autoPlacement
     */ const autoPlacement = (options, deps) => ({
      ...(0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "autoPlacement"
      ])(options),
      options: [options, deps],
    });
    /**
     * Provides data to hide the floating element in applicable situations, such as
     * when it is not in the same clipping context as the reference element.
     * @see https://floating-ui.com/docs/hide
     */ const hide = (options, deps) => ({
      ...(0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "hide"
      ])(options),
      options: [options, deps],
    });
    /**
     * Provides improved positioning for inline reference elements that can span
     * over multiple lines, such as hyperlinks or range selections.
     * @see https://floating-ui.com/docs/inline
     */ const inline = (options, deps) => ({
      ...(0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$floating$2d$ui$2f$dom$2f$dist$2f$floating$2d$ui$2e$dom$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "inline"
      ])(options),
      options: [options, deps],
    });
    /**
     * Provides data to position an inner element of the floating element so that it
     * appears centered to the reference element.
     * This wraps the core `arrow` middleware to allow React refs as the element.
     * @see https://floating-ui.com/docs/arrow
     */ const arrow = (options, deps) => ({
      ...arrow$1(options),
      options: [options, deps],
    });
  },
  "[project]/node_modules/reselect/dist/reselect.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "createSelector",
      () => createSelector,
      "createSelectorCreator",
      () => createSelectorCreator,
      "createStructuredSelector",
      () => createStructuredSelector,
      "lruMemoize",
      () => lruMemoize,
      "referenceEqualityCheck",
      () => referenceEqualityCheck,
      "setGlobalDevModeChecks",
      () => setGlobalDevModeChecks,
      "unstable_autotrackMemoize",
      () => autotrackMemoize,
      "weakMapMemoize",
      () => weakMapMemoize,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    // src/devModeChecks/identityFunctionCheck.ts
    var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
      if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
        let isInputSameAsOutput = false;
        try {
          const emptyObject = {};
          if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true;
        } catch {}
        if (isInputSameAsOutput) {
          let stack = void 0;
          try {
            throw new Error();
          } catch (e) {
            ({ stack } = e);
          }
          console.warn(
            "The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.",
            {
              stack,
            },
          );
        }
      }
    };
    // src/devModeChecks/inputStabilityCheck.ts
    var runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs) => {
      const { memoize, memoizeOptions } = options;
      const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
      const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions);
      const areInputSelectorResultsEqual =
        createAnEmptyObject.apply(null, inputSelectorResults) ===
        createAnEmptyObject.apply(null, inputSelectorResultsCopy);
      if (!areInputSelectorResultsEqual) {
        let stack = void 0;
        try {
          throw new Error();
        } catch (e) {
          ({ stack } = e);
        }
        console.warn(
          "An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`",
          {
            arguments: inputSelectorArgs,
            firstInputs: inputSelectorResults,
            secondInputs: inputSelectorResultsCopy,
            stack,
          },
        );
      }
    };
    // src/devModeChecks/setGlobalDevModeChecks.ts
    var globalDevModeChecks = {
      inputStabilityCheck: "once",
      identityFunctionCheck: "once",
    };
    var setGlobalDevModeChecks = (devModeChecks) => {
      Object.assign(globalDevModeChecks, devModeChecks);
    };
    // src/utils.ts
    var NOT_FOUND = /* @__PURE__ */ Symbol("NOT_FOUND");
    function assertIsFunction(
      func,
      errorMessage = `expected a function, instead received ${typeof func}`,
    ) {
      if (typeof func !== "function") {
        throw new TypeError(errorMessage);
      }
    }
    function assertIsObject(
      object,
      errorMessage = `expected an object, instead received ${typeof object}`,
    ) {
      if (typeof object !== "object") {
        throw new TypeError(errorMessage);
      }
    }
    function assertIsArrayOfFunctions(
      array,
      errorMessage = `expected all items to be functions, instead received the following types: `,
    ) {
      if (!array.every((item) => typeof item === "function")) {
        const itemTypes = array
          .map((item) =>
            typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item,
          )
          .join(", ");
        throw new TypeError(`${errorMessage}[${itemTypes}]`);
      }
    }
    var ensureIsArray = (item) => {
      return Array.isArray(item) ? item : [item];
    };
    function getDependencies(createSelectorArgs) {
      const dependencies = Array.isArray(createSelectorArgs[0])
        ? createSelectorArgs[0]
        : createSelectorArgs;
      assertIsArrayOfFunctions(
        dependencies,
        `createSelector expects all input-selectors to be functions, but received the following types: `,
      );
      return dependencies;
    }
    function collectInputSelectorResults(dependencies, inputSelectorArgs) {
      const inputSelectorResults = [];
      const { length } = dependencies;
      for (let i = 0; i < length; i++) {
        inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
      }
      return inputSelectorResults;
    }
    var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
      const { identityFunctionCheck, inputStabilityCheck } = {
        ...globalDevModeChecks,
        ...devModeChecks,
      };
      return {
        identityFunctionCheck: {
          shouldRun:
            identityFunctionCheck === "always" || (identityFunctionCheck === "once" && firstRun),
          run: runIdentityFunctionCheck,
        },
        inputStabilityCheck: {
          shouldRun:
            inputStabilityCheck === "always" || (inputStabilityCheck === "once" && firstRun),
          run: runInputStabilityCheck,
        },
      };
    };
    // src/autotrackMemoize/autotracking.ts
    var $REVISION = 0;
    var CURRENT_TRACKER = null;
    var Cell = class {
      revision = $REVISION;
      _value;
      _lastValue;
      _isEqual = tripleEq;
      constructor(initialValue, isEqual = tripleEq) {
        this._value = this._lastValue = initialValue;
        this._isEqual = isEqual;
      }
      // Whenever a storage value is read, it'll add itself to the current tracker if
      // one exists, entangling its state with that cache.
      get value() {
        CURRENT_TRACKER?.add(this);
        return this._value;
      }
      // Whenever a storage value is updated, we bump the global revision clock,
      // assign the revision for this storage to the new value, _and_ we schedule a
      // rerender. This is important, and it's what makes autotracking  _pull_
      // based. We don't actively tell the caches which depend on the storage that
      // anything has happened. Instead, we recompute the caches when needed.
      set value(newValue) {
        if (this.value === newValue) return;
        this._value = newValue;
        this.revision = ++$REVISION;
      }
    };
    function tripleEq(a, b) {
      return a === b;
    }
    var TrackingCache = class {
      _cachedValue;
      _cachedRevision = -1;
      _deps = [];
      hits = 0;
      fn;
      constructor(fn) {
        this.fn = fn;
      }
      clear() {
        this._cachedValue = void 0;
        this._cachedRevision = -1;
        this._deps = [];
        this.hits = 0;
      }
      get value() {
        if (this.revision > this._cachedRevision) {
          const { fn } = this;
          const currentTracker = /* @__PURE__ */ new Set();
          const prevTracker = CURRENT_TRACKER;
          CURRENT_TRACKER = currentTracker;
          this._cachedValue = fn();
          CURRENT_TRACKER = prevTracker;
          this.hits++;
          this._deps = Array.from(currentTracker);
          this._cachedRevision = this.revision;
        }
        CURRENT_TRACKER?.add(this);
        return this._cachedValue;
      }
      get revision() {
        return Math.max(...this._deps.map((d) => d.revision), 0);
      }
    };
    function getValue(cell) {
      if (!(cell instanceof Cell)) {
        console.warn("Not a valid cell! ", cell);
      }
      return cell.value;
    }
    function setValue(storage, value) {
      if (!(storage instanceof Cell)) {
        throw new TypeError(
          "setValue must be passed a tracked store created with `createStorage`.",
        );
      }
      storage.value = storage._lastValue = value;
    }
    function createCell(initialValue, isEqual = tripleEq) {
      return new Cell(initialValue, isEqual);
    }
    function createCache(fn) {
      assertIsFunction(fn, "the first parameter to `createCache` must be a function");
      return new TrackingCache(fn);
    }
    // src/autotrackMemoize/tracking.ts
    var neverEq = (a, b) => false;
    function createTag() {
      return createCell(null, neverEq);
    }
    function dirtyTag(tag, value) {
      setValue(tag, value);
    }
    var consumeCollection = (node) => {
      let tag = node.collectionTag;
      if (tag === null) {
        tag = node.collectionTag = createTag();
      }
      getValue(tag);
    };
    var dirtyCollection = (node) => {
      const tag = node.collectionTag;
      if (tag !== null) {
        dirtyTag(tag, null);
      }
    };
    // src/autotrackMemoize/proxy.ts
    var REDUX_PROXY_LABEL = Symbol();
    var nextId = 0;
    var proto = Object.getPrototypeOf({});
    var ObjectTreeNode = class {
      constructor(value) {
        this.value = value;
        this.value = value;
        this.tag.value = value;
      }
      proxy = new Proxy(this, objectProxyHandler);
      tag = createTag();
      tags = {};
      children = {};
      collectionTag = null;
      id = nextId++;
    };
    var objectProxyHandler = {
      get(node, key) {
        function calculateResult() {
          const { value } = node;
          const childValue = Reflect.get(value, key);
          if (typeof key === "symbol") {
            return childValue;
          }
          if (key in proto) {
            return childValue;
          }
          if (typeof childValue === "object" && childValue !== null) {
            let childNode = node.children[key];
            if (childNode === void 0) {
              childNode = node.children[key] = createNode(childValue);
            }
            if (childNode.tag) {
              getValue(childNode.tag);
            }
            return childNode.proxy;
          } else {
            let tag = node.tags[key];
            if (tag === void 0) {
              tag = node.tags[key] = createTag();
              tag.value = childValue;
            }
            getValue(tag);
            return childValue;
          }
        }
        const res = calculateResult();
        return res;
      },
      ownKeys(node) {
        consumeCollection(node);
        return Reflect.ownKeys(node.value);
      },
      getOwnPropertyDescriptor(node, prop) {
        return Reflect.getOwnPropertyDescriptor(node.value, prop);
      },
      has(node, prop) {
        return Reflect.has(node.value, prop);
      },
    };
    var ArrayTreeNode = class {
      constructor(value) {
        this.value = value;
        this.value = value;
        this.tag.value = value;
      }
      proxy = new Proxy([this], arrayProxyHandler);
      tag = createTag();
      tags = {};
      children = {};
      collectionTag = null;
      id = nextId++;
    };
    var arrayProxyHandler = {
      get([node], key) {
        if (key === "length") {
          consumeCollection(node);
        }
        return objectProxyHandler.get(node, key);
      },
      ownKeys([node]) {
        return objectProxyHandler.ownKeys(node);
      },
      getOwnPropertyDescriptor([node], prop) {
        return objectProxyHandler.getOwnPropertyDescriptor(node, prop);
      },
      has([node], prop) {
        return objectProxyHandler.has(node, prop);
      },
    };
    function createNode(value) {
      if (Array.isArray(value)) {
        return new ArrayTreeNode(value);
      }
      return new ObjectTreeNode(value);
    }
    function updateNode(node, newValue) {
      const { value, tags, children } = node;
      node.value = newValue;
      if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {
        dirtyCollection(node);
      } else {
        if (value !== newValue) {
          let oldKeysSize = 0;
          let newKeysSize = 0;
          let anyKeysAdded = false;
          for (const _key in value) {
            oldKeysSize++;
          }
          for (const key in newValue) {
            newKeysSize++;
            if (!(key in value)) {
              anyKeysAdded = true;
              break;
            }
          }
          const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;
          if (isDifferent) {
            dirtyCollection(node);
          }
        }
      }
      for (const key in tags) {
        const childValue = value[key];
        const newChildValue = newValue[key];
        if (childValue !== newChildValue) {
          dirtyCollection(node);
          dirtyTag(tags[key], newChildValue);
        }
        if (typeof newChildValue === "object" && newChildValue !== null) {
          delete tags[key];
        }
      }
      for (const key in children) {
        const childNode = children[key];
        const newChildValue = newValue[key];
        const childValue = childNode.value;
        if (childValue === newChildValue) {
          continue;
        } else if (typeof newChildValue === "object" && newChildValue !== null) {
          updateNode(childNode, newChildValue);
        } else {
          deleteNode(childNode);
          delete children[key];
        }
      }
    }
    function deleteNode(node) {
      if (node.tag) {
        dirtyTag(node.tag, null);
      }
      dirtyCollection(node);
      for (const key in node.tags) {
        dirtyTag(node.tags[key], null);
      }
      for (const key in node.children) {
        deleteNode(node.children[key]);
      }
    }
    // src/lruMemoize.ts
    function createSingletonCache(equals) {
      let entry;
      return {
        get(key) {
          if (entry && equals(entry.key, key)) {
            return entry.value;
          }
          return NOT_FOUND;
        },
        put(key, value) {
          entry = {
            key,
            value,
          };
        },
        getEntries() {
          return entry ? [entry] : [];
        },
        clear() {
          entry = void 0;
        },
      };
    }
    function createLruCache(maxSize, equals) {
      let entries = [];
      function get(key) {
        const cacheIndex = entries.findIndex((entry) => equals(key, entry.key));
        if (cacheIndex > -1) {
          const entry = entries[cacheIndex];
          if (cacheIndex > 0) {
            entries.splice(cacheIndex, 1);
            entries.unshift(entry);
          }
          return entry.value;
        }
        return NOT_FOUND;
      }
      function put(key, value) {
        if (get(key) === NOT_FOUND) {
          entries.unshift({
            key,
            value,
          });
          if (entries.length > maxSize) {
            entries.pop();
          }
        }
      }
      function getEntries() {
        return entries;
      }
      function clear() {
        entries = [];
      }
      return {
        get,
        put,
        getEntries,
        clear,
      };
    }
    var referenceEqualityCheck = (a, b) => a === b;
    function createCacheKeyComparator(equalityCheck) {
      return function areArgumentsShallowlyEqual(prev, next) {
        if (prev === null || next === null || prev.length !== next.length) {
          return false;
        }
        const { length } = prev;
        for (let i = 0; i < length; i++) {
          if (!equalityCheck(prev[i], next[i])) {
            return false;
          }
        }
        return true;
      };
    }
    function lruMemoize(func, equalityCheckOrOptions) {
      const providedOptions =
        typeof equalityCheckOrOptions === "object"
          ? equalityCheckOrOptions
          : {
              equalityCheck: equalityCheckOrOptions,
            };
      const {
        equalityCheck = referenceEqualityCheck,
        maxSize = 1,
        resultEqualityCheck,
      } = providedOptions;
      const comparator = createCacheKeyComparator(equalityCheck);
      let resultsCount = 0;
      const cache =
        maxSize <= 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
      function memoized() {
        let value = cache.get(arguments);
        if (value === NOT_FOUND) {
          value = func.apply(null, arguments);
          resultsCount++;
          if (resultEqualityCheck) {
            const entries = cache.getEntries();
            const matchingEntry = entries.find((entry) => resultEqualityCheck(entry.value, value));
            if (matchingEntry) {
              value = matchingEntry.value;
              resultsCount !== 0 && resultsCount--;
            }
          }
          cache.put(arguments, value);
        }
        return value;
      }
      memoized.clearCache = () => {
        cache.clear();
        memoized.resetResultsCount();
      };
      memoized.resultsCount = () => resultsCount;
      memoized.resetResultsCount = () => {
        resultsCount = 0;
      };
      return memoized;
    }
    // src/autotrackMemoize/autotrackMemoize.ts
    function autotrackMemoize(func) {
      const node = createNode([]);
      let lastArgs = null;
      const shallowEqual = createCacheKeyComparator(referenceEqualityCheck);
      const cache = createCache(() => {
        const res = func.apply(null, node.proxy);
        return res;
      });
      function memoized() {
        if (!shallowEqual(lastArgs, arguments)) {
          updateNode(node, arguments);
          lastArgs = arguments;
        }
        return cache.value;
      }
      memoized.clearCache = () => {
        return cache.clear();
      };
      return memoized;
    }
    // src/weakMapMemoize.ts
    var StrongRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
    var UNTERMINATED = 0;
    var TERMINATED = 1;
    function createCacheNode() {
      return {
        s: UNTERMINATED,
        v: void 0,
        o: null,
        p: null,
      };
    }
    function weakMapMemoize(func, options = {}) {
      let fnNode = createCacheNode();
      const { resultEqualityCheck } = options;
      let lastResult;
      let resultsCount = 0;
      function memoized() {
        let cacheNode = fnNode;
        const { length } = arguments;
        for (let i = 0, l = length; i < l; i++) {
          const arg = arguments[i];
          if (typeof arg === "function" || (typeof arg === "object" && arg !== null)) {
            let objectCache = cacheNode.o;
            if (objectCache === null) {
              cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
            }
            const objectNode = objectCache.get(arg);
            if (objectNode === void 0) {
              cacheNode = createCacheNode();
              objectCache.set(arg, cacheNode);
            } else {
              cacheNode = objectNode;
            }
          } else {
            let primitiveCache = cacheNode.p;
            if (primitiveCache === null) {
              cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
            }
            const primitiveNode = primitiveCache.get(arg);
            if (primitiveNode === void 0) {
              cacheNode = createCacheNode();
              primitiveCache.set(arg, cacheNode);
            } else {
              cacheNode = primitiveNode;
            }
          }
        }
        const terminatedNode = cacheNode;
        let result;
        if (cacheNode.s === TERMINATED) {
          result = cacheNode.v;
        } else {
          result = func.apply(null, arguments);
          resultsCount++;
          if (resultEqualityCheck) {
            const lastResultValue = lastResult?.deref?.() ?? lastResult;
            if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
              result = lastResultValue;
              resultsCount !== 0 && resultsCount--;
            }
            const needsWeakRef =
              (typeof result === "object" && result !== null) || typeof result === "function";
            lastResult = needsWeakRef ? new Ref(result) : result;
          }
        }
        terminatedNode.s = TERMINATED;
        terminatedNode.v = result;
        return result;
      }
      memoized.clearCache = () => {
        fnNode = createCacheNode();
        memoized.resetResultsCount();
      };
      memoized.resultsCount = () => resultsCount;
      memoized.resetResultsCount = () => {
        resultsCount = 0;
      };
      return memoized;
    }
    // src/createSelectorCreator.ts
    function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
      const createSelectorCreatorOptions =
        typeof memoizeOrOptions === "function"
          ? {
              memoize: memoizeOrOptions,
              memoizeOptions: memoizeOptionsFromArgs,
            }
          : memoizeOrOptions;
      const createSelector2 = (...createSelectorArgs) => {
        let recomputations = 0;
        let dependencyRecomputations = 0;
        let lastResult;
        let directlyPassedOptions = {};
        let resultFunc = createSelectorArgs.pop();
        if (typeof resultFunc === "object") {
          directlyPassedOptions = resultFunc;
          resultFunc = createSelectorArgs.pop();
        }
        assertIsFunction(
          resultFunc,
          `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`,
        );
        const combinedOptions = {
          ...createSelectorCreatorOptions,
          ...directlyPassedOptions,
        };
        const {
          memoize,
          memoizeOptions = [],
          argsMemoize = weakMapMemoize,
          argsMemoizeOptions = [],
          devModeChecks = {},
        } = combinedOptions;
        const finalMemoizeOptions = ensureIsArray(memoizeOptions);
        const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
        const dependencies = getDependencies(createSelectorArgs);
        const memoizedResultFunc = memoize(
          function recomputationWrapper() {
            recomputations++;
            return resultFunc.apply(null, arguments);
          },
          ...finalMemoizeOptions,
        );
        let firstRun = true;
        const selector = argsMemoize(
          function dependenciesChecker() {
            dependencyRecomputations++;
            const inputSelectorResults = collectInputSelectorResults(dependencies, arguments);
            lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
            if (("TURBOPACK compile-time truthy", 1)) {
              const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(
                firstRun,
                devModeChecks,
              );
              if (identityFunctionCheck.shouldRun) {
                identityFunctionCheck.run(resultFunc, inputSelectorResults, lastResult);
              }
              if (inputStabilityCheck.shouldRun) {
                const inputSelectorResultsCopy = collectInputSelectorResults(
                  dependencies,
                  arguments,
                );
                inputStabilityCheck.run(
                  {
                    inputSelectorResults,
                    inputSelectorResultsCopy,
                  },
                  {
                    memoize,
                    memoizeOptions: finalMemoizeOptions,
                  },
                  arguments,
                );
              }
              if (firstRun) firstRun = false;
            }
            return lastResult;
          },
          ...finalArgsMemoizeOptions,
        );
        return Object.assign(selector, {
          resultFunc,
          memoizedResultFunc,
          dependencies,
          dependencyRecomputations: () => dependencyRecomputations,
          resetDependencyRecomputations: () => {
            dependencyRecomputations = 0;
          },
          lastResult: () => lastResult,
          recomputations: () => recomputations,
          resetRecomputations: () => {
            recomputations = 0;
          },
          memoize,
          argsMemoize,
        });
      };
      Object.assign(createSelector2, {
        withTypes: () => createSelector2,
      });
      return createSelector2;
    }
    var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
    // src/createStructuredSelector.ts
    var createStructuredSelector = Object.assign(
      (inputSelectorsObject, selectorCreator = createSelector) => {
        assertIsObject(
          inputSelectorsObject,
          `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`,
        );
        const inputSelectorKeys = Object.keys(inputSelectorsObject);
        const dependencies = inputSelectorKeys.map((key) => inputSelectorsObject[key]);
        const structuredSelector = selectorCreator(dependencies, (...inputSelectorResults) => {
          return inputSelectorResults.reduce((composition, value, index) => {
            composition[inputSelectorKeys[index]] = value;
            return composition;
          }, {});
        });
        return structuredSelector;
      },
      {
        withTypes: () => createStructuredSelector,
      },
    );
  },
  //# sourceMappingURL=reselect.mjs.map
  "[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    /**
     * @license React
     * use-sync-external-store-shim.development.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */ ("use strict");
    "production" !== ("TURBOPACK compile-time value", "development") &&
      (function () {
        function is(x, y) {
          return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
        }
        function useSyncExternalStore$2(subscribe, getSnapshot) {
          didWarnOld18Alpha ||
            void 0 === React.startTransition ||
            ((didWarnOld18Alpha = !0),
            console.error(
              "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.",
            ));
          var value = getSnapshot();
          if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            objectIs(value, cachedValue) ||
              (console.error(
                "The result of getSnapshot should be cached to avoid an infinite loop",
              ),
              (didWarnUncachedGetSnapshot = !0));
          }
          cachedValue = useState({
            inst: {
              value: value,
              getSnapshot: getSnapshot,
            },
          });
          var inst = cachedValue[0].inst,
            forceUpdate = cachedValue[1];
          useLayoutEffect(
            {
              "useSyncExternalStore$2.useLayoutEffect": function () {
                inst.value = value;
                inst.getSnapshot = getSnapshot;
                checkIfSnapshotChanged(inst) &&
                  forceUpdate({
                    inst: inst,
                  });
              },
            }["useSyncExternalStore$2.useLayoutEffect"],
            [subscribe, value, getSnapshot],
          );
          useEffect(
            {
              "useSyncExternalStore$2.useEffect": function () {
                checkIfSnapshotChanged(inst) &&
                  forceUpdate({
                    inst: inst,
                  });
                return subscribe(
                  {
                    "useSyncExternalStore$2.useEffect": function () {
                      checkIfSnapshotChanged(inst) &&
                        forceUpdate({
                          inst: inst,
                        });
                    },
                  }["useSyncExternalStore$2.useEffect"],
                );
              },
            }["useSyncExternalStore$2.useEffect"],
            [subscribe],
          );
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error) {
            return !0;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot) {
          return getSnapshot();
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
          "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React = __turbopack_context__.r(
            "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
          ),
          objectIs = "function" === typeof Object.is ? Object.is : is,
          useState = React.useState,
          useEffect = React.useEffect,
          useLayoutEffect = React.useLayoutEffect,
          useDebugValue = React.useDebugValue,
          didWarnOld18Alpha = !1,
          didWarnUncachedGetSnapshot = !1,
          shim =
            "undefined" === typeof window ||
            "undefined" === typeof window.document ||
            "undefined" === typeof window.document.createElement
              ? useSyncExternalStore$1
              : useSyncExternalStore$2;
        exports.useSyncExternalStore =
          void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
          "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
  },
  "[project]/node_modules/use-sync-external-store/shim/index.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    ("use strict");
    if (("TURBOPACK compile-time falsy", 0)) //TURBOPACK unreachable
    ;
    else {
      module.exports = __turbopack_context__.r(
        "[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [app-client] (ecmascript)",
      );
    }
  },
  "[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    /**
     * @license React
     * use-sync-external-store-shim/with-selector.development.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */ ("use strict");
    "production" !== ("TURBOPACK compile-time value", "development") &&
      (function () {
        function is(x, y) {
          return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
          "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React = __turbopack_context__.r(
            "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
          ),
          shim = __turbopack_context__.r(
            "[project]/node_modules/use-sync-external-store/shim/index.js [app-client] (ecmascript)",
          ),
          objectIs = "function" === typeof Object.is ? Object.is : is,
          useSyncExternalStore = shim.useSyncExternalStore,
          useRef = React.useRef,
          useEffect = React.useEffect,
          useMemo = React.useMemo,
          useDebugValue = React.useDebugValue;
        exports.useSyncExternalStoreWithSelector = function (
          subscribe,
          getSnapshot,
          getServerSnapshot,
          selector,
          isEqual,
        ) {
          var instRef = useRef(null);
          if (null === instRef.current) {
            var inst = {
              hasValue: !1,
              value: null,
            };
            instRef.current = inst;
          } else inst = instRef.current;
          instRef = useMemo(
            function () {
              function memoizedSelector(nextSnapshot) {
                if (!hasMemo) {
                  hasMemo = !0;
                  memoizedSnapshot = nextSnapshot;
                  nextSnapshot = selector(nextSnapshot);
                  if (void 0 !== isEqual && inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, nextSnapshot))
                      return (memoizedSelection = currentSelection);
                  }
                  return (memoizedSelection = nextSnapshot);
                }
                currentSelection = memoizedSelection;
                if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
                var nextSelection = selector(nextSnapshot);
                if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                  return ((memoizedSnapshot = nextSnapshot), currentSelection);
                memoizedSnapshot = nextSnapshot;
                return (memoizedSelection = nextSelection);
              }
              var hasMemo = !1,
                memoizedSnapshot,
                memoizedSelection,
                maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
              return [
                function () {
                  return memoizedSelector(getSnapshot());
                },
                null === maybeGetServerSnapshot
                  ? void 0
                  : function () {
                      return memoizedSelector(maybeGetServerSnapshot());
                    },
              ];
            },
            [getSnapshot, getServerSnapshot, selector, isEqual],
          );
          var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
          useEffect(
            function () {
              inst.hasValue = !0;
              inst.value = value;
            },
            [value],
          );
          useDebugValue(value);
          return value;
        };
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
          "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
  },
  "[project]/node_modules/use-sync-external-store/shim/with-selector.js [app-client] (ecmascript)",
  (__turbopack_context__, module, exports) => {
    "use strict";

    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    ("use strict");
    if (("TURBOPACK compile-time falsy", 0)) //TURBOPACK unreachable
    ;
    else {
      module.exports = __turbopack_context__.r(
        "[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js [app-client] (ecmascript)",
      );
    }
  },
  "[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "hasA11yProp",
      () => hasA11yProp,
      "mergeClasses",
      () => mergeClasses,
      "toCamelCase",
      () => toCamelCase,
      "toKebabCase",
      () => toKebabCase,
      "toPascalCase",
      () => toPascalCase,
    ]);
    /**
     * @license lucide-react v0.546.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */ const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
    const toCamelCase = (string) =>
      string.replace(/^([A-Z])|[\s-_]+(\w)/g, (match, p1, p2) =>
        p2 ? p2.toUpperCase() : p1.toLowerCase(),
      );
    const toPascalCase = (string) => {
      const camelCase = toCamelCase(string);
      return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
    };
    const mergeClasses = (...classes) =>
      classes
        .filter((className, index, array) => {
          return (
            Boolean(className) && className.trim() !== "" && array.indexOf(className) === index
          );
        })
        .join(" ")
        .trim();
    const hasA11yProp = (props) => {
      for (const prop in props) {
        if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
          return true;
        }
      }
    };
  },
  //# sourceMappingURL=utils.js.map
  "[project]/node_modules/lucide-react/dist/esm/defaultAttributes.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["default", () => defaultAttributes]);
    /**
     * @license lucide-react v0.546.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */ var defaultAttributes = {
      xmlns: "http://www.w3.org/2000/svg",
      width: 24,
      height: 24,
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: 2,
      strokeLinecap: "round",
      strokeLinejoin: "round",
    };
  },
  //# sourceMappingURL=defaultAttributes.js.map
  "[project]/node_modules/lucide-react/dist/esm/Icon.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["default", () => Icon]);
    /**
     * @license lucide-react v0.546.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/defaultAttributes.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-client] (ecmascript)",
      );
    const Icon = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "forwardRef"
    ])(
      (
        {
          color = "currentColor",
          size = 24,
          strokeWidth = 2,
          absoluteStrokeWidth,
          className = "",
          children,
          iconNode,
          ...rest
        },
        ref,
      ) =>
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "createElement"
        ])(
          "svg",
          {
            ref,
            ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$defaultAttributes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "default"
            ],
            width: size,
            height: size,
            stroke: color,
            strokeWidth: absoluteStrokeWidth
              ? (Number(strokeWidth) * 24) / Number(size)
              : strokeWidth,
            className: (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "mergeClasses"
            ])("lucide", className),
            ...(!children &&
              !(0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "hasA11yProp"
              ])(rest) && {
                "aria-hidden": "true",
              }),
            ...rest,
          },
          [
            ...iconNode.map(([tag, attrs]) =>
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "createElement"
              ])(tag, attrs),
            ),
            ...(Array.isArray(children) ? children : [children]),
          ],
        ),
    );
  },
  //# sourceMappingURL=Icon.js.map
  "[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["default", () => createLucideIcon]);
    /**
     * @license lucide-react v0.546.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/shared/src/utils.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/Icon.js [app-client] (ecmascript)",
      );
    const createLucideIcon = (iconName, iconNode) => {
      const Component = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "forwardRef"
      ])(({ className, ...props }, ref) =>
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "createElement"
        ])(
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$Icon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ],
          {
            ref,
            iconNode,
            className: (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "mergeClasses"
            ])(
              `lucide-${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toKebabCase"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toPascalCase"])(iconName))}`,
              `lucide-${iconName}`,
              className,
            ),
            ...props,
          },
        ),
      );
      Component.displayName = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$shared$2f$src$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "toPascalCase"
      ])(iconName);
      return Component;
    };
  },
  //# sourceMappingURL=createLucideIcon.js.map
  "[project]/node_modules/lucide-react/dist/esm/icons/check.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["__iconNode", () => __iconNode, "default", () => Check]);
    /**
     * @license lucide-react v0.546.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)",
      );
    const __iconNode = [
      [
        "path",
        {
          d: "M20 6 9 17l-5-5",
          key: "1gmf2c",
        },
      ],
    ];
    const Check = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "default"
    ])("check", __iconNode);
  },
  //# sourceMappingURL=check.js.map
  "[project]/node_modules/lucide-react/dist/esm/icons/check.js [app-client] (ecmascript) <export default as CheckIcon>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "CheckIcon",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/icons/check.js [app-client] (ecmascript)",
      );
  },
  "[project]/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["__iconNode", () => __iconNode, "default", () => ChevronRight]);
    /**
     * @license lucide-react v0.546.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)",
      );
    const __iconNode = [
      [
        "path",
        {
          d: "m9 18 6-6-6-6",
          key: "mthhwq",
        },
      ],
    ];
    const ChevronRight = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "default"
    ])("chevron-right", __iconNode);
  },
  //# sourceMappingURL=chevron-right.js.map
  "[project]/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-client] (ecmascript) <export default as ChevronRightIcon>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "ChevronRightIcon",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$right$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$chevron$2d$right$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/icons/chevron-right.js [app-client] (ecmascript)",
      );
  },
  "[project]/node_modules/lucide-react/dist/esm/icons/circle-check.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["__iconNode", () => __iconNode, "default", () => CircleCheck]);
    /**
     * @license lucide-react v0.546.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)",
      );
    const __iconNode = [
      [
        "circle",
        {
          cx: "12",
          cy: "12",
          r: "10",
          key: "1mglay",
        },
      ],
      [
        "path",
        {
          d: "m9 12 2 2 4-4",
          key: "dzmm74",
        },
      ],
    ];
    const CircleCheck = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "default"
    ])("circle-check", __iconNode);
  },
  //# sourceMappingURL=circle-check.js.map
  "[project]/node_modules/lucide-react/dist/esm/icons/circle-check.js [app-client] (ecmascript) <export default as CircleCheckIcon>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "CircleCheckIcon",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$circle$2d$check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$circle$2d$check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/icons/circle-check.js [app-client] (ecmascript)",
      );
  },
  "[project]/node_modules/lucide-react/dist/esm/icons/info.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["__iconNode", () => __iconNode, "default", () => Info]);
    /**
     * @license lucide-react v0.546.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)",
      );
    const __iconNode = [
      [
        "circle",
        {
          cx: "12",
          cy: "12",
          r: "10",
          key: "1mglay",
        },
      ],
      [
        "path",
        {
          d: "M12 16v-4",
          key: "1dtifu",
        },
      ],
      [
        "path",
        {
          d: "M12 8h.01",
          key: "e9boi3",
        },
      ],
    ];
    const Info = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "default"
    ])("info", __iconNode);
  },
  //# sourceMappingURL=info.js.map
  "[project]/node_modules/lucide-react/dist/esm/icons/info.js [app-client] (ecmascript) <export default as InfoIcon>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "InfoIcon",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/icons/info.js [app-client] (ecmascript)",
      );
  },
  "[project]/node_modules/lucide-react/dist/esm/icons/loader-circle.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["__iconNode", () => __iconNode, "default", () => LoaderCircle]);
    /**
     * @license lucide-react v0.546.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)",
      );
    const __iconNode = [
      [
        "path",
        {
          d: "M21 12a9 9 0 1 1-6.219-8.56",
          key: "13zald",
        },
      ],
    ];
    const LoaderCircle = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "default"
    ])("loader-circle", __iconNode);
  },
  //# sourceMappingURL=loader-circle.js.map
  "[project]/node_modules/lucide-react/dist/esm/icons/loader-circle.js [app-client] (ecmascript) <export default as Loader2Icon>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "Loader2Icon",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$loader$2d$circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$loader$2d$circle$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/icons/loader-circle.js [app-client] (ecmascript)",
      );
  },
  "[project]/node_modules/lucide-react/dist/esm/icons/octagon-x.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["__iconNode", () => __iconNode, "default", () => OctagonX]);
    /**
     * @license lucide-react v0.546.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)",
      );
    const __iconNode = [
      [
        "path",
        {
          d: "m15 9-6 6",
          key: "1uzhvr",
        },
      ],
      [
        "path",
        {
          d: "M2.586 16.726A2 2 0 0 1 2 15.312V8.688a2 2 0 0 1 .586-1.414l4.688-4.688A2 2 0 0 1 8.688 2h6.624a2 2 0 0 1 1.414.586l4.688 4.688A2 2 0 0 1 22 8.688v6.624a2 2 0 0 1-.586 1.414l-4.688 4.688a2 2 0 0 1-1.414.586H8.688a2 2 0 0 1-1.414-.586z",
          key: "2d38gg",
        },
      ],
      [
        "path",
        {
          d: "m9 9 6 6",
          key: "z0biqf",
        },
      ],
    ];
    const OctagonX = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "default"
    ])("octagon-x", __iconNode);
  },
  //# sourceMappingURL=octagon-x.js.map
  "[project]/node_modules/lucide-react/dist/esm/icons/octagon-x.js [app-client] (ecmascript) <export default as OctagonXIcon>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "OctagonXIcon",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$octagon$2d$x$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$octagon$2d$x$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/icons/octagon-x.js [app-client] (ecmascript)",
      );
  },
  "[project]/node_modules/lucide-react/dist/esm/icons/triangle-alert.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["__iconNode", () => __iconNode, "default", () => TriangleAlert]);
    /**
     * @license lucide-react v0.546.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/createLucideIcon.js [app-client] (ecmascript)",
      );
    const __iconNode = [
      [
        "path",
        {
          d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
          key: "wmoenq",
        },
      ],
      [
        "path",
        {
          d: "M12 9v4",
          key: "juzpu7",
        },
      ],
      [
        "path",
        {
          d: "M12 17h.01",
          key: "p32p05",
        },
      ],
    ];
    const TriangleAlert = (0,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$createLucideIcon$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
      "default"
    ])("triangle-alert", __iconNode);
  },
  //# sourceMappingURL=triangle-alert.js.map
  "[project]/node_modules/lucide-react/dist/esm/icons/triangle-alert.js [app-client] (ecmascript) <export default as TriangleAlertIcon>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "TriangleAlertIcon",
      () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$triangle$2d$alert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ],
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lucide$2d$react$2f$dist$2f$esm$2f$icons$2f$triangle$2d$alert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/lucide-react/dist/esm/icons/triangle-alert.js [app-client] (ecmascript)",
      );
  },
  "[project]/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "QueryClientContext",
      () => QueryClientContext,
      "QueryClientProvider",
      () => QueryClientProvider,
      "useQueryClient",
      () => useQueryClient,
    ]);
    // src/QueryClientProvider.tsx
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)",
      );
    ("use client");
    var QueryClientContext =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "createContext"
      ](void 0);
    var useQueryClient = (queryClient) => {
      const client =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useContext"
        ](QueryClientContext);
      if (queryClient) {
        return queryClient;
      }
      if (!client) {
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
      }
      return client;
    };
    var QueryClientProvider = ({ client, children }) => {
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "QueryClientProvider.useEffect": () => {
            client.mount();
            return {
              "QueryClientProvider.useEffect": () => {
                client.unmount();
              },
            }["QueryClientProvider.useEffect"];
          },
        }["QueryClientProvider.useEffect"],
        [client],
      );
      return /* @__PURE__ */ (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "jsx"
      ])(QueryClientContext.Provider, {
        value: client,
        children,
      });
    };
  },
  //# sourceMappingURL=QueryClientProvider.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/subscribable.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["Subscribable", () => Subscribable]);
    // src/subscribable.ts
    var Subscribable = class {
      constructor() {
        this.listeners = /* @__PURE__ */ new Set();
        this.subscribe = this.subscribe.bind(this);
      }
      subscribe(listener) {
        this.listeners.add(listener);
        this.onSubscribe();
        return () => {
          this.listeners.delete(listener);
          this.onUnsubscribe();
        };
      }
      hasListeners() {
        return this.listeners.size > 0;
      }
      onSubscribe() {}
      onUnsubscribe() {}
    };
  },
  //# sourceMappingURL=subscribable.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/timeoutManager.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "TimeoutManager",
      () => TimeoutManager,
      "defaultTimeoutProvider",
      () => defaultTimeoutProvider,
      "systemSetTimeoutZero",
      () => systemSetTimeoutZero,
      "timeoutManager",
      () => timeoutManager,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    // src/timeoutManager.ts
    var defaultTimeoutProvider = {
      // We need the wrapper function syntax below instead of direct references to
      // global setTimeout etc.
      //
      // BAD: `setTimeout: setTimeout`
      // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
      //
      // If we use direct references here, then anything that wants to spy on or
      // replace the global setTimeout (like tests) won't work since we'll already
      // have a hard reference to the original implementation at the time when this
      // file was imported.
      setTimeout: (callback, delay) => setTimeout(callback, delay),
      clearTimeout: (timeoutId) => clearTimeout(timeoutId),
      setInterval: (callback, delay) => setInterval(callback, delay),
      clearInterval: (intervalId) => clearInterval(intervalId),
    };
    var TimeoutManager = class {
      // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
      // type at app boot; and if we leave that type, then any new timer provider
      // would need to support ReturnType<typeof setTimeout>, which is infeasible.
      //
      // We settle for type safety for the TimeoutProvider type, and accept that
      // this class is unsafe internally to allow for extension.
      #provider = defaultTimeoutProvider;
      #providerCalled = false;
      setTimeoutProvider(provider) {
        if (("TURBOPACK compile-time truthy", 1)) {
          if (this.#providerCalled && provider !== this.#provider) {
            console.error(
              `[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`,
              {
                previous: this.#provider,
                provider,
              },
            );
          }
        }
        this.#provider = provider;
        if (("TURBOPACK compile-time value", "development") !== "production") {
          this.#providerCalled = false;
        }
      }
      setTimeout(callback, delay) {
        if (("TURBOPACK compile-time value", "development") !== "production") {
          this.#providerCalled = true;
        }
        return this.#provider.setTimeout(callback, delay);
      }
      clearTimeout(timeoutId) {
        this.#provider.clearTimeout(timeoutId);
      }
      setInterval(callback, delay) {
        if (("TURBOPACK compile-time value", "development") !== "production") {
          this.#providerCalled = true;
        }
        return this.#provider.setInterval(callback, delay);
      }
      clearInterval(intervalId) {
        this.#provider.clearInterval(intervalId);
      }
    };
    var timeoutManager = new TimeoutManager();
    function systemSetTimeoutZero(callback) {
      setTimeout(callback, 0);
    }
  },
  //# sourceMappingURL=timeoutManager.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "addConsumeAwareSignal",
      () => addConsumeAwareSignal,
      "addToEnd",
      () => addToEnd,
      "addToStart",
      () => addToStart,
      "ensureQueryFn",
      () => ensureQueryFn,
      "functionalUpdate",
      () => functionalUpdate,
      "hashKey",
      () => hashKey,
      "hashQueryKeyByOptions",
      () => hashQueryKeyByOptions,
      "isPlainArray",
      () => isPlainArray,
      "isPlainObject",
      () => isPlainObject,
      "isServer",
      () => isServer,
      "isValidTimeout",
      () => isValidTimeout,
      "keepPreviousData",
      () => keepPreviousData,
      "matchMutation",
      () => matchMutation,
      "matchQuery",
      () => matchQuery,
      "noop",
      () => noop,
      "partialMatchKey",
      () => partialMatchKey,
      "replaceData",
      () => replaceData,
      "replaceEqualDeep",
      () => replaceEqualDeep,
      "resolveEnabled",
      () => resolveEnabled,
      "resolveStaleTime",
      () => resolveStaleTime,
      "shallowEqualObjects",
      () => shallowEqualObjects,
      "shouldThrowError",
      () => shouldThrowError,
      "skipToken",
      () => skipToken,
      "sleep",
      () => sleep,
      "timeUntilStale",
      () => timeUntilStale,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    // src/utils.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$timeoutManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/timeoutManager.js [app-client] (ecmascript)",
      );
    var isServer = typeof window === "undefined" || "Deno" in globalThis;
    function noop() {}
    function functionalUpdate(updater, input) {
      return typeof updater === "function" ? updater(input) : updater;
    }
    function isValidTimeout(value) {
      return typeof value === "number" && value >= 0 && value !== Infinity;
    }
    function timeUntilStale(updatedAt, staleTime) {
      return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
    }
    function resolveStaleTime(staleTime, query) {
      return typeof staleTime === "function" ? staleTime(query) : staleTime;
    }
    function resolveEnabled(enabled, query) {
      return typeof enabled === "function" ? enabled(query) : enabled;
    }
    function matchQuery(filters, query) {
      const { type = "all", exact, fetchStatus, predicate, queryKey, stale } = filters;
      if (queryKey) {
        if (exact) {
          if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
            return false;
          }
        } else if (!partialMatchKey(query.queryKey, queryKey)) {
          return false;
        }
      }
      if (type !== "all") {
        const isActive = query.isActive();
        if (type === "active" && !isActive) {
          return false;
        }
        if (type === "inactive" && isActive) {
          return false;
        }
      }
      if (typeof stale === "boolean" && query.isStale() !== stale) {
        return false;
      }
      if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
        return false;
      }
      if (predicate && !predicate(query)) {
        return false;
      }
      return true;
    }
    function matchMutation(filters, mutation) {
      const { exact, status, predicate, mutationKey } = filters;
      if (mutationKey) {
        if (!mutation.options.mutationKey) {
          return false;
        }
        if (exact) {
          if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
            return false;
          }
        } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
          return false;
        }
      }
      if (status && mutation.state.status !== status) {
        return false;
      }
      if (predicate && !predicate(mutation)) {
        return false;
      }
      return true;
    }
    function hashQueryKeyByOptions(queryKey, options) {
      const hashFn = options?.queryKeyHashFn || hashKey;
      return hashFn(queryKey);
    }
    function hashKey(queryKey) {
      return JSON.stringify(queryKey, (_, val) =>
        isPlainObject(val)
          ? Object.keys(val)
              .sort()
              .reduce((result, key) => {
                result[key] = val[key];
                return result;
              }, {})
          : val,
      );
    }
    function partialMatchKey(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a !== typeof b) {
        return false;
      }
      if (a && b && typeof a === "object" && typeof b === "object") {
        return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]));
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty;
    function replaceEqualDeep(a, b, depth = 0) {
      if (a === b) {
        return a;
      }
      if (depth > 500) return b;
      const array = isPlainArray(a) && isPlainArray(b);
      if (!array && !(isPlainObject(a) && isPlainObject(b))) return b;
      const aItems = array ? a : Object.keys(a);
      const aSize = aItems.length;
      const bItems = array ? b : Object.keys(b);
      const bSize = bItems.length;
      const copy = array ? new Array(bSize) : {};
      let equalItems = 0;
      for (let i = 0; i < bSize; i++) {
        const key = array ? i : bItems[i];
        const aItem = a[key];
        const bItem = b[key];
        if (aItem === bItem) {
          copy[key] = aItem;
          if (array ? i < aSize : hasOwn.call(a, key)) equalItems++;
          continue;
        }
        if (
          aItem === null ||
          bItem === null ||
          typeof aItem !== "object" ||
          typeof bItem !== "object"
        ) {
          copy[key] = bItem;
          continue;
        }
        const v = replaceEqualDeep(aItem, bItem, depth + 1);
        copy[key] = v;
        if (v === aItem) equalItems++;
      }
      return aSize === bSize && equalItems === aSize ? a : copy;
    }
    function shallowEqualObjects(a, b) {
      if (!b || Object.keys(a).length !== Object.keys(b).length) {
        return false;
      }
      for (const key in a) {
        if (a[key] !== b[key]) {
          return false;
        }
      }
      return true;
    }
    function isPlainArray(value) {
      return Array.isArray(value) && value.length === Object.keys(value).length;
    }
    function isPlainObject(o) {
      if (!hasObjectPrototype(o)) {
        return false;
      }
      const ctor = o.constructor;
      if (ctor === void 0) {
        return true;
      }
      const prot = ctor.prototype;
      if (!hasObjectPrototype(prot)) {
        return false;
      }
      if (!prot.hasOwnProperty("isPrototypeOf")) {
        return false;
      }
      if (Object.getPrototypeOf(o) !== Object.prototype) {
        return false;
      }
      return true;
    }
    function hasObjectPrototype(o) {
      return Object.prototype.toString.call(o) === "[object Object]";
    }
    function sleep(timeout) {
      return new Promise((resolve) => {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$timeoutManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "timeoutManager"
        ].setTimeout(resolve, timeout);
      });
    }
    function replaceData(prevData, data, options) {
      if (typeof options.structuralSharing === "function") {
        return options.structuralSharing(prevData, data);
      } else if (options.structuralSharing !== false) {
        if (("TURBOPACK compile-time truthy", 1)) {
          try {
            return replaceEqualDeep(prevData, data);
          } catch (error) {
            console.error(
              `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`,
            );
            throw error;
          }
        }
        return replaceEqualDeep(prevData, data);
      }
      return data;
    }
    function keepPreviousData(previousData) {
      return previousData;
    }
    function addToEnd(items, item, max = 0) {
      const newItems = [...items, item];
      return max && newItems.length > max ? newItems.slice(1) : newItems;
    }
    function addToStart(items, item, max = 0) {
      const newItems = [item, ...items];
      return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
    }
    var skipToken = /* @__PURE__ */ Symbol();
    function ensureQueryFn(options, fetchOptions) {
      if (("TURBOPACK compile-time truthy", 1)) {
        if (options.queryFn === skipToken) {
          console.error(
            `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`,
          );
        }
      }
      if (!options.queryFn && fetchOptions?.initialPromise) {
        return () => fetchOptions.initialPromise;
      }
      if (!options.queryFn || options.queryFn === skipToken) {
        return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
      }
      return options.queryFn;
    }
    function shouldThrowError(throwOnError, params) {
      if (typeof throwOnError === "function") {
        return throwOnError(...params);
      }
      return !!throwOnError;
    }
    function addConsumeAwareSignal(object, getSignal, onCancelled) {
      let consumed = false;
      let signal;
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          signal ??= getSignal();
          if (consumed) {
            return signal;
          }
          consumed = true;
          if (signal.aborted) {
            onCancelled();
          } else {
            signal.addEventListener("abort", onCancelled, {
              once: true,
            });
          }
          return signal;
        },
      });
      return object;
    }
  },
  //# sourceMappingURL=utils.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/onlineManager.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "OnlineManager",
      () => OnlineManager,
      "onlineManager",
      () => onlineManager,
    ]);
    // src/onlineManager.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/subscribable.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)",
      );
    var OnlineManager = class
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "Subscribable"
      ]
    {
      #online = true;
      #cleanup;
      #setup;
      constructor() {
        super();
        this.#setup = (onOnline) => {
          if (
            !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "isServer"
            ] &&
            window.addEventListener
          ) {
            const onlineListener = () => onOnline(true);
            const offlineListener = () => onOnline(false);
            window.addEventListener("online", onlineListener, false);
            window.addEventListener("offline", offlineListener, false);
            return () => {
              window.removeEventListener("online", onlineListener);
              window.removeEventListener("offline", offlineListener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.#cleanup) {
          this.setEventListener(this.#setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.#cleanup?.();
          this.#cleanup = void 0;
        }
      }
      setEventListener(setup) {
        this.#setup = setup;
        this.#cleanup?.();
        this.#cleanup = setup(this.setOnline.bind(this));
      }
      setOnline(online) {
        const changed = this.#online !== online;
        if (changed) {
          this.#online = online;
          this.listeners.forEach((listener) => {
            listener(online);
          });
        }
      }
      isOnline() {
        return this.#online;
      }
    };
    var onlineManager = new OnlineManager();
  },
  //# sourceMappingURL=onlineManager.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/notifyManager.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "createNotifyManager",
      () => createNotifyManager,
      "defaultScheduler",
      () => defaultScheduler,
      "notifyManager",
      () => notifyManager,
    ]);
    // src/notifyManager.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$timeoutManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/timeoutManager.js [app-client] (ecmascript)",
      );
    var defaultScheduler =
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$timeoutManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "systemSetTimeoutZero"
      ];
    function createNotifyManager() {
      let queue = [];
      let transactions = 0;
      let notifyFn = (callback) => {
        callback();
      };
      let batchNotifyFn = (callback) => {
        callback();
      };
      let scheduleFn = defaultScheduler;
      const schedule = (callback) => {
        if (transactions) {
          queue.push(callback);
        } else {
          scheduleFn(() => {
            notifyFn(callback);
          });
        }
      };
      const flush = () => {
        const originalQueue = queue;
        queue = [];
        if (originalQueue.length) {
          scheduleFn(() => {
            batchNotifyFn(() => {
              originalQueue.forEach((callback) => {
                notifyFn(callback);
              });
            });
          });
        }
      };
      return {
        batch: (callback) => {
          let result;
          transactions++;
          try {
            result = callback();
          } finally {
            transactions--;
            if (!transactions) {
              flush();
            }
          }
          return result;
        },
        /**
         * All calls to the wrapped function will be batched.
         */ batchCalls: (callback) => {
          return (...args) => {
            schedule(() => {
              callback(...args);
            });
          };
        },
        schedule,
        /**
         * Use this method to set a custom notify function.
         * This can be used to for example wrap notifications with `React.act` while running tests.
         */ setNotifyFunction: (fn) => {
          notifyFn = fn;
        },
        /**
         * Use this method to set a custom function to batch notifications together into a single tick.
         * By default React Query will use the batch function provided by ReactDOM or React Native.
         */ setBatchNotifyFunction: (fn) => {
          batchNotifyFn = fn;
        },
        setScheduler: (fn) => {
          scheduleFn = fn;
        },
      };
    }
    var notifyManager = createNotifyManager();
  },
  //# sourceMappingURL=notifyManager.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/focusManager.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "FocusManager",
      () => FocusManager,
      "focusManager",
      () => focusManager,
    ]);
    // src/focusManager.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/subscribable.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)",
      );
    var FocusManager = class
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "Subscribable"
      ]
    {
      #focused;
      #cleanup;
      #setup;
      constructor() {
        super();
        this.#setup = (onFocus) => {
          if (
            !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "isServer"
            ] &&
            window.addEventListener
          ) {
            const listener = () => onFocus();
            window.addEventListener("visibilitychange", listener, false);
            return () => {
              window.removeEventListener("visibilitychange", listener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.#cleanup) {
          this.setEventListener(this.#setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.#cleanup?.();
          this.#cleanup = void 0;
        }
      }
      setEventListener(setup) {
        this.#setup = setup;
        this.#cleanup?.();
        this.#cleanup = setup((focused) => {
          if (typeof focused === "boolean") {
            this.setFocused(focused);
          } else {
            this.onFocus();
          }
        });
      }
      setFocused(focused) {
        const changed = this.#focused !== focused;
        if (changed) {
          this.#focused = focused;
          this.onFocus();
        }
      }
      onFocus() {
        const isFocused = this.isFocused();
        this.listeners.forEach((listener) => {
          listener(isFocused);
        });
      }
      isFocused() {
        if (typeof this.#focused === "boolean") {
          return this.#focused;
        }
        return globalThis.document?.visibilityState !== "hidden";
      }
    };
    var focusManager = new FocusManager();
  },
  //# sourceMappingURL=focusManager.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/thenable.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "pendingThenable",
      () => pendingThenable,
      "tryResolveSync",
      () => tryResolveSync,
    ]);
    // src/thenable.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)",
      );
    function pendingThenable() {
      let resolve;
      let reject;
      const thenable = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      });
      thenable.status = "pending";
      thenable.catch(() => {});
      function finalize(data) {
        Object.assign(thenable, data);
        delete thenable.resolve;
        delete thenable.reject;
      }
      thenable.resolve = (value) => {
        finalize({
          status: "fulfilled",
          value,
        });
        resolve(value);
      };
      thenable.reject = (reason) => {
        finalize({
          status: "rejected",
          reason,
        });
        reject(reason);
      };
      return thenable;
    }
    function tryResolveSync(promise) {
      let data;
      promise
        .then((result) => {
          data = result;
          return result;
        }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noop"])
        ?.catch(
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "noop"
          ],
        );
      if (data !== void 0) {
        return {
          data,
        };
      }
      return void 0;
    }
  },
  //# sourceMappingURL=thenable.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/retryer.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "CancelledError",
      () => CancelledError,
      "canFetch",
      () => canFetch,
      "createRetryer",
      () => createRetryer,
      "isCancelledError",
      () => isCancelledError,
    ]);
    // src/retryer.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$focusManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/focusManager.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$onlineManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/onlineManager.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$thenable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/thenable.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)",
      );
    function defaultRetryDelay(failureCount) {
      return Math.min(1e3 * 2 ** failureCount, 3e4);
    }
    function canFetch(networkMode) {
      return (networkMode ?? "online") === "online"
        ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$onlineManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "onlineManager"
          ].isOnline()
        : true;
    }
    var CancelledError = class extends Error {
      constructor(options) {
        super("CancelledError");
        this.revert = options?.revert;
        this.silent = options?.silent;
      }
    };
    function isCancelledError(value) {
      return value instanceof CancelledError;
    }
    function createRetryer(config) {
      let isRetryCancelled = false;
      let failureCount = 0;
      let continueFn;
      const thenable = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$thenable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "pendingThenable"
      ])();
      const isResolved = () => thenable.status !== "pending";
      const cancel = (cancelOptions) => {
        if (!isResolved()) {
          const error = new CancelledError(cancelOptions);
          reject(error);
          config.onCancel?.(error);
        }
      };
      const cancelRetry = () => {
        isRetryCancelled = true;
      };
      const continueRetry = () => {
        isRetryCancelled = false;
      };
      const canContinue = () =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$focusManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "focusManager"
        ].isFocused() &&
        (config.networkMode === "always" ||
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$onlineManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "onlineManager"
          ].isOnline()) &&
        config.canRun();
      const canStart = () => canFetch(config.networkMode) && config.canRun();
      const resolve = (value) => {
        if (!isResolved()) {
          continueFn?.();
          thenable.resolve(value);
        }
      };
      const reject = (value) => {
        if (!isResolved()) {
          continueFn?.();
          thenable.reject(value);
        }
      };
      const pause = () => {
        return new Promise((continueResolve) => {
          continueFn = (value) => {
            if (isResolved() || canContinue()) {
              continueResolve(value);
            }
          };
          config.onPause?.();
        }).then(() => {
          continueFn = void 0;
          if (!isResolved()) {
            config.onContinue?.();
          }
        });
      };
      const run = () => {
        if (isResolved()) {
          return;
        }
        let promiseOrValue;
        const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
        try {
          promiseOrValue = initialPromise ?? config.fn();
        } catch (error) {
          promiseOrValue = Promise.reject(error);
        }
        Promise.resolve(promiseOrValue)
          .then(resolve)
          .catch((error) => {
            if (isResolved()) {
              return;
            }
            const retry =
              config.retry ??
              (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "isServer"
              ]
                ? 0
                : 3);
            const retryDelay = config.retryDelay ?? defaultRetryDelay;
            const delay =
              typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
            const shouldRetry =
              retry === true ||
              (typeof retry === "number" && failureCount < retry) ||
              (typeof retry === "function" && retry(failureCount, error));
            if (isRetryCancelled || !shouldRetry) {
              reject(error);
              return;
            }
            failureCount++;
            config.onFail?.(failureCount, error);
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "sleep"
            ])(delay)
              .then(() => {
                return canContinue() ? void 0 : pause();
              })
              .then(() => {
                if (isRetryCancelled) {
                  reject(error);
                } else {
                  run();
                }
              });
          });
      };
      return {
        promise: thenable,
        status: () => thenable.status,
        cancel,
        continue: () => {
          continueFn?.();
          return thenable;
        },
        cancelRetry,
        continueRetry,
        canStart,
        start: () => {
          if (canStart()) {
            run();
          } else {
            pause().then(run);
          }
          return thenable;
        },
      };
    }
  },
  //# sourceMappingURL=retryer.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/removable.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["Removable", () => Removable]);
    // src/removable.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$timeoutManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/timeoutManager.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)",
      );
    var Removable = class {
      #gcTimeout;
      destroy() {
        this.clearGcTimeout();
      }
      scheduleGc() {
        this.clearGcTimeout();
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "isValidTimeout"
          ])(this.gcTime)
        ) {
          this.#gcTimeout =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$timeoutManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "timeoutManager"
            ].setTimeout(() => {
              this.optionalRemove();
            }, this.gcTime);
        }
      }
      updateGcTime(newGcTime) {
        this.gcTime = Math.max(
          this.gcTime || 0,
          newGcTime ??
            (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "isServer"
            ]
              ? Infinity
              : 5 * 60 * 1e3),
        );
      }
      clearGcTimeout() {
        if (this.#gcTimeout) {
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$timeoutManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "timeoutManager"
          ].clearTimeout(this.#gcTimeout);
          this.#gcTimeout = void 0;
        }
      }
    };
  },
  //# sourceMappingURL=removable.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/query.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["Query", () => Query, "fetchState", () => fetchState]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    // src/query.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/notifyManager.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$retryer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/retryer.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$removable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/removable.js [app-client] (ecmascript)",
      );
    var Query = class
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$removable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "Removable"
      ]
    {
      #initialState;
      #revertState;
      #cache;
      #client;
      #retryer;
      #defaultOptions;
      #abortSignalConsumed;
      constructor(config) {
        super();
        this.#abortSignalConsumed = false;
        this.#defaultOptions = config.defaultOptions;
        this.setOptions(config.options);
        this.observers = [];
        this.#client = config.client;
        this.#cache = this.#client.getQueryCache();
        this.queryKey = config.queryKey;
        this.queryHash = config.queryHash;
        this.#initialState = getDefaultState(this.options);
        this.state = config.state ?? this.#initialState;
        this.scheduleGc();
      }
      get meta() {
        return this.options.meta;
      }
      get promise() {
        return this.#retryer?.promise;
      }
      setOptions(options) {
        this.options = {
          ...this.#defaultOptions,
          ...options,
        };
        this.updateGcTime(this.options.gcTime);
        if (this.state && this.state.data === void 0) {
          const defaultState = getDefaultState(this.options);
          if (defaultState.data !== void 0) {
            this.setState(successState(defaultState.data, defaultState.dataUpdatedAt));
            this.#initialState = defaultState;
          }
        }
      }
      optionalRemove() {
        if (!this.observers.length && this.state.fetchStatus === "idle") {
          this.#cache.remove(this);
        }
      }
      setData(newData, options) {
        const data = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "replaceData"
        ])(this.state.data, newData, this.options);
        this.#dispatch({
          data,
          type: "success",
          dataUpdatedAt: options?.updatedAt,
          manual: options?.manual,
        });
        return data;
      }
      setState(state, setStateOptions) {
        this.#dispatch({
          type: "setState",
          state,
          setStateOptions,
        });
      }
      cancel(options) {
        const promise = this.#retryer?.promise;
        this.#retryer?.cancel(options);
        return promise
          ? promise
              .then(
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "noop"
                ],
              )
              .catch(
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "noop"
                ],
              )
          : Promise.resolve();
      }
      destroy() {
        super.destroy();
        this.cancel({
          silent: true,
        });
      }
      reset() {
        this.destroy();
        this.setState(this.#initialState);
      }
      isActive() {
        return this.observers.some(
          (observer) =>
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "resolveEnabled"
            ])(observer.options.enabled, this) !== false,
        );
      }
      isDisabled() {
        if (this.getObserversCount() > 0) {
          return !this.isActive();
        }
        return (
          this.options.queryFn ===
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "skipToken"
            ] || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
        );
      }
      isStatic() {
        if (this.getObserversCount() > 0) {
          return this.observers.some(
            (observer) =>
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "resolveStaleTime"
              ])(observer.options.staleTime, this) === "static",
          );
        }
        return false;
      }
      isStale() {
        if (this.getObserversCount() > 0) {
          return this.observers.some((observer) => observer.getCurrentResult().isStale);
        }
        return this.state.data === void 0 || this.state.isInvalidated;
      }
      isStaleByTime(staleTime = 0) {
        if (this.state.data === void 0) {
          return true;
        }
        if (staleTime === "static") {
          return false;
        }
        if (this.state.isInvalidated) {
          return true;
        }
        return !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "timeUntilStale"
        ])(this.state.dataUpdatedAt, staleTime);
      }
      onFocus() {
        const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
        observer?.refetch({
          cancelRefetch: false,
        });
        this.#retryer?.continue();
      }
      onOnline() {
        const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
        observer?.refetch({
          cancelRefetch: false,
        });
        this.#retryer?.continue();
      }
      addObserver(observer) {
        if (!this.observers.includes(observer)) {
          this.observers.push(observer);
          this.clearGcTimeout();
          this.#cache.notify({
            type: "observerAdded",
            query: this,
            observer,
          });
        }
      }
      removeObserver(observer) {
        if (this.observers.includes(observer)) {
          this.observers = this.observers.filter((x) => x !== observer);
          if (!this.observers.length) {
            if (this.#retryer) {
              if (this.#abortSignalConsumed) {
                this.#retryer.cancel({
                  revert: true,
                });
              } else {
                this.#retryer.cancelRetry();
              }
            }
            this.scheduleGc();
          }
          this.#cache.notify({
            type: "observerRemoved",
            query: this,
            observer,
          });
        }
      }
      getObserversCount() {
        return this.observers.length;
      }
      invalidate() {
        if (!this.state.isInvalidated) {
          this.#dispatch({
            type: "invalidate",
          });
        }
      }
      async fetch(options, fetchOptions) {
        if (
          this.state.fetchStatus !== "idle" && // If the promise in the retryer is already rejected, we have to definitely
          // re-start the fetch; there is a chance that the query is still in a
          // pending state when that happens
          this.#retryer?.status() !== "rejected"
        ) {
          if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {
            this.cancel({
              silent: true,
            });
          } else if (this.#retryer) {
            this.#retryer.continueRetry();
            return this.#retryer.promise;
          }
        }
        if (options) {
          this.setOptions(options);
        }
        if (!this.options.queryFn) {
          const observer = this.observers.find((x) => x.options.queryFn);
          if (observer) {
            this.setOptions(observer.options);
          }
        }
        if (("TURBOPACK compile-time truthy", 1)) {
          if (!Array.isArray(this.options.queryKey)) {
            console.error(
              `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,
            );
          }
        }
        const abortController = new AbortController();
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              this.#abortSignalConsumed = true;
              return abortController.signal;
            },
          });
        };
        const fetchFn = () => {
          const queryFn = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "ensureQueryFn"
          ])(this.options, fetchOptions);
          const createQueryFnContext = () => {
            const queryFnContext2 = {
              client: this.#client,
              queryKey: this.queryKey,
              meta: this.meta,
            };
            addSignalProperty(queryFnContext2);
            return queryFnContext2;
          };
          const queryFnContext = createQueryFnContext();
          this.#abortSignalConsumed = false;
          if (this.options.persister) {
            return this.options.persister(queryFn, queryFnContext, this);
          }
          return queryFn(queryFnContext);
        };
        const createFetchContext = () => {
          const context2 = {
            fetchOptions,
            options: this.options,
            queryKey: this.queryKey,
            client: this.#client,
            state: this.state,
            fetchFn,
          };
          addSignalProperty(context2);
          return context2;
        };
        const context = createFetchContext();
        this.options.behavior?.onFetch(context, this);
        this.#revertState = this.state;
        if (
          this.state.fetchStatus === "idle" ||
          this.state.fetchMeta !== context.fetchOptions?.meta
        ) {
          this.#dispatch({
            type: "fetch",
            meta: context.fetchOptions?.meta,
          });
        }
        this.#retryer = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$retryer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "createRetryer"
        ])({
          initialPromise: fetchOptions?.initialPromise,
          fn: context.fetchFn,
          onCancel: (error) => {
            if (
              error instanceof
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$retryer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "CancelledError"
                ] &&
              error.revert
            ) {
              this.setState({
                ...this.#revertState,
                fetchStatus: "idle",
              });
            }
            abortController.abort();
          },
          onFail: (failureCount, error) => {
            this.#dispatch({
              type: "failed",
              failureCount,
              error,
            });
          },
          onPause: () => {
            this.#dispatch({
              type: "pause",
            });
          },
          onContinue: () => {
            this.#dispatch({
              type: "continue",
            });
          },
          retry: context.options.retry,
          retryDelay: context.options.retryDelay,
          networkMode: context.options.networkMode,
          canRun: () => true,
        });
        try {
          const data = await this.#retryer.start();
          if (data === void 0) {
            if (("TURBOPACK compile-time truthy", 1)) {
              console.error(
                `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,
              );
            }
            throw new Error(`${this.queryHash} data is undefined`);
          }
          this.setData(data);
          this.#cache.config.onSuccess?.(data, this);
          this.#cache.config.onSettled?.(data, this.state.error, this);
          return data;
        } catch (error) {
          if (
            error instanceof
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$retryer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "CancelledError"
            ]
          ) {
            if (error.silent) {
              return this.#retryer.promise;
            } else if (error.revert) {
              if (this.state.data === void 0) {
                throw error;
              }
              return this.state.data;
            }
          }
          this.#dispatch({
            type: "error",
            error,
          });
          this.#cache.config.onError?.(error, this);
          this.#cache.config.onSettled?.(this.state.data, error, this);
          throw error;
        } finally {
          this.scheduleGc();
        }
      }
      #dispatch(action) {
        const reducer = (state) => {
          switch (action.type) {
            case "failed":
              return {
                ...state,
                fetchFailureCount: action.failureCount,
                fetchFailureReason: action.error,
              };
            case "pause":
              return {
                ...state,
                fetchStatus: "paused",
              };
            case "continue":
              return {
                ...state,
                fetchStatus: "fetching",
              };
            case "fetch":
              return {
                ...state,
                ...fetchState(state.data, this.options),
                fetchMeta: action.meta ?? null,
              };
            case "success":
              const newState = {
                ...state,
                ...successState(action.data, action.dataUpdatedAt),
                dataUpdateCount: state.dataUpdateCount + 1,
                ...(!action.manual && {
                  fetchStatus: "idle",
                  fetchFailureCount: 0,
                  fetchFailureReason: null,
                }),
              };
              this.#revertState = action.manual ? newState : void 0;
              return newState;
            case "error":
              const error = action.error;
              return {
                ...state,
                error,
                errorUpdateCount: state.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: state.fetchFailureCount + 1,
                fetchFailureReason: error,
                fetchStatus: "idle",
                status: "error",
                // flag existing data as invalidated if we get a background error
                // note that "no data" always means stale so we can set unconditionally here
                isInvalidated: true,
              };
            case "invalidate":
              return {
                ...state,
                isInvalidated: true,
              };
            case "setState":
              return {
                ...state,
                ...action.state,
              };
          }
        };
        this.state = reducer(this.state);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() => {
          this.observers.forEach((observer) => {
            observer.onQueryUpdate();
          });
          this.#cache.notify({
            query: this,
            type: "updated",
            action,
          });
        });
      }
    };
    function fetchState(data, options) {
      return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$retryer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "canFetch"
        ])(options.networkMode)
          ? "fetching"
          : "paused",
        ...(data === void 0 && {
          error: null,
          status: "pending",
        }),
      };
    }
    function successState(data, dataUpdatedAt) {
      return {
        data,
        dataUpdatedAt: dataUpdatedAt ?? Date.now(),
        error: null,
        isInvalidated: false,
        status: "success",
      };
    }
    function getDefaultState(options) {
      const data =
        typeof options.initialData === "function" ? options.initialData() : options.initialData;
      const hasData = data !== void 0;
      const initialDataUpdatedAt = hasData
        ? typeof options.initialDataUpdatedAt === "function"
          ? options.initialDataUpdatedAt()
          : options.initialDataUpdatedAt
        : 0;
      return {
        data,
        dataUpdateCount: 0,
        dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: false,
        status: hasData ? "success" : "pending",
        fetchStatus: "idle",
      };
    }
  },
  //# sourceMappingURL=query.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/queryCache.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["QueryCache", () => QueryCache]);
    // src/queryCache.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$query$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/query.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/notifyManager.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/subscribable.js [app-client] (ecmascript)",
      );
    var QueryCache = class
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "Subscribable"
      ]
    {
      constructor(config = {}) {
        super();
        this.config = config;
        this.#queries = /* @__PURE__ */ new Map();
      }
      #queries;
      build(client, options, state) {
        const queryKey = options.queryKey;
        const queryHash =
          options.queryHash ??
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "hashQueryKeyByOptions"
          ])(queryKey, options);
        let query = this.get(queryHash);
        if (!query) {
          query =
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$query$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "Query"
            ]({
              client,
              queryKey,
              queryHash,
              options: client.defaultQueryOptions(options),
              state,
              defaultOptions: client.getQueryDefaults(queryKey),
            });
          this.add(query);
        }
        return query;
      }
      add(query) {
        if (!this.#queries.has(query.queryHash)) {
          this.#queries.set(query.queryHash, query);
          this.notify({
            type: "added",
            query,
          });
        }
      }
      remove(query) {
        const queryInMap = this.#queries.get(query.queryHash);
        if (queryInMap) {
          query.destroy();
          if (queryInMap === query) {
            this.#queries.delete(query.queryHash);
          }
          this.notify({
            type: "removed",
            query,
          });
        }
      }
      clear() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() => {
          this.getAll().forEach((query) => {
            this.remove(query);
          });
        });
      }
      get(queryHash) {
        return this.#queries.get(queryHash);
      }
      getAll() {
        return [...this.#queries.values()];
      }
      find(filters) {
        const defaultedFilters = {
          exact: true,
          ...filters,
        };
        return this.getAll().find((query) =>
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "matchQuery"
          ])(defaultedFilters, query),
        );
      }
      findAll(filters = {}) {
        const queries = this.getAll();
        return Object.keys(filters).length > 0
          ? queries.filter((query) =>
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "matchQuery"
              ])(filters, query),
            )
          : queries;
      }
      notify(event) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() => {
          this.listeners.forEach((listener) => {
            listener(event);
          });
        });
      }
      onFocus() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() => {
          this.getAll().forEach((query) => {
            query.onFocus();
          });
        });
      }
      onOnline() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() => {
          this.getAll().forEach((query) => {
            query.onOnline();
          });
        });
      }
    };
  },
  //# sourceMappingURL=queryCache.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/mutation.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["Mutation", () => Mutation, "getDefaultState", () => getDefaultState]);
    // src/mutation.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/notifyManager.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$removable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/removable.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$retryer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/retryer.js [app-client] (ecmascript)",
      );
    var Mutation = class
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$removable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "Removable"
      ]
    {
      #client;
      #observers;
      #mutationCache;
      #retryer;
      constructor(config) {
        super();
        this.#client = config.client;
        this.mutationId = config.mutationId;
        this.#mutationCache = config.mutationCache;
        this.#observers = [];
        this.state = config.state || getDefaultState();
        this.setOptions(config.options);
        this.scheduleGc();
      }
      setOptions(options) {
        this.options = options;
        this.updateGcTime(this.options.gcTime);
      }
      get meta() {
        return this.options.meta;
      }
      addObserver(observer) {
        if (!this.#observers.includes(observer)) {
          this.#observers.push(observer);
          this.clearGcTimeout();
          this.#mutationCache.notify({
            type: "observerAdded",
            mutation: this,
            observer,
          });
        }
      }
      removeObserver(observer) {
        this.#observers = this.#observers.filter((x) => x !== observer);
        this.scheduleGc();
        this.#mutationCache.notify({
          type: "observerRemoved",
          mutation: this,
          observer,
        });
      }
      optionalRemove() {
        if (!this.#observers.length) {
          if (this.state.status === "pending") {
            this.scheduleGc();
          } else {
            this.#mutationCache.remove(this);
          }
        }
      }
      continue() {
        return (
          this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
          this.execute(this.state.variables)
        );
      }
      async execute(variables) {
        const onContinue = () => {
          this.#dispatch({
            type: "continue",
          });
        };
        const mutationFnContext = {
          client: this.#client,
          meta: this.options.meta,
          mutationKey: this.options.mutationKey,
        };
        this.#retryer = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$retryer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "createRetryer"
        ])({
          fn: () => {
            if (!this.options.mutationFn) {
              return Promise.reject(new Error("No mutationFn found"));
            }
            return this.options.mutationFn(variables, mutationFnContext);
          },
          onFail: (failureCount, error) => {
            this.#dispatch({
              type: "failed",
              failureCount,
              error,
            });
          },
          onPause: () => {
            this.#dispatch({
              type: "pause",
            });
          },
          onContinue,
          retry: this.options.retry ?? 0,
          retryDelay: this.options.retryDelay,
          networkMode: this.options.networkMode,
          canRun: () => this.#mutationCache.canRun(this),
        });
        const restored = this.state.status === "pending";
        const isPaused = !this.#retryer.canStart();
        try {
          if (restored) {
            onContinue();
          } else {
            this.#dispatch({
              type: "pending",
              variables,
              isPaused,
            });
            if (this.#mutationCache.config.onMutate) {
              await this.#mutationCache.config.onMutate(variables, this, mutationFnContext);
            }
            const context = await this.options.onMutate?.(variables, mutationFnContext);
            if (context !== this.state.context) {
              this.#dispatch({
                type: "pending",
                context,
                variables,
                isPaused,
              });
            }
          }
          const data = await this.#retryer.start();
          await this.#mutationCache.config.onSuccess?.(
            data,
            variables,
            this.state.context,
            this,
            mutationFnContext,
          );
          await this.options.onSuccess?.(data, variables, this.state.context, mutationFnContext);
          await this.#mutationCache.config.onSettled?.(
            data,
            null,
            this.state.variables,
            this.state.context,
            this,
            mutationFnContext,
          );
          await this.options.onSettled?.(
            data,
            null,
            variables,
            this.state.context,
            mutationFnContext,
          );
          this.#dispatch({
            type: "success",
            data,
          });
          return data;
        } catch (error) {
          try {
            await this.#mutationCache.config.onError?.(
              error,
              variables,
              this.state.context,
              this,
              mutationFnContext,
            );
          } catch (e) {
            void Promise.reject(e);
          }
          try {
            await this.options.onError?.(error, variables, this.state.context, mutationFnContext);
          } catch (e) {
            void Promise.reject(e);
          }
          try {
            await this.#mutationCache.config.onSettled?.(
              void 0,
              error,
              this.state.variables,
              this.state.context,
              this,
              mutationFnContext,
            );
          } catch (e) {
            void Promise.reject(e);
          }
          try {
            await this.options.onSettled?.(
              void 0,
              error,
              variables,
              this.state.context,
              mutationFnContext,
            );
          } catch (e) {
            void Promise.reject(e);
          }
          this.#dispatch({
            type: "error",
            error,
          });
          throw error;
        } finally {
          this.#mutationCache.runNext(this);
        }
      }
      #dispatch(action) {
        const reducer = (state) => {
          switch (action.type) {
            case "failed":
              return {
                ...state,
                failureCount: action.failureCount,
                failureReason: action.error,
              };
            case "pause":
              return {
                ...state,
                isPaused: true,
              };
            case "continue":
              return {
                ...state,
                isPaused: false,
              };
            case "pending":
              return {
                ...state,
                context: action.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: action.isPaused,
                status: "pending",
                variables: action.variables,
                submittedAt: Date.now(),
              };
            case "success":
              return {
                ...state,
                data: action.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: false,
              };
            case "error":
              return {
                ...state,
                data: void 0,
                error: action.error,
                failureCount: state.failureCount + 1,
                failureReason: action.error,
                isPaused: false,
                status: "error",
              };
          }
        };
        this.state = reducer(this.state);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() => {
          this.#observers.forEach((observer) => {
            observer.onMutationUpdate(action);
          });
          this.#mutationCache.notify({
            mutation: this,
            type: "updated",
            action,
          });
        });
      }
    };
    function getDefaultState() {
      return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: false,
        status: "idle",
        variables: void 0,
        submittedAt: 0,
      };
    }
  },
  //# sourceMappingURL=mutation.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/mutationCache.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["MutationCache", () => MutationCache]);
    // src/mutationCache.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/notifyManager.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$mutation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/mutation.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/subscribable.js [app-client] (ecmascript)",
      );
    var MutationCache = class
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "Subscribable"
      ]
    {
      constructor(config = {}) {
        super();
        this.config = config;
        this.#mutations = /* @__PURE__ */ new Set();
        this.#scopes = /* @__PURE__ */ new Map();
        this.#mutationId = 0;
      }
      #mutations;
      #scopes;
      #mutationId;
      build(client, options, state) {
        const mutation =
          new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$mutation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "Mutation"
          ]({
            client,
            mutationCache: this,
            mutationId: ++this.#mutationId,
            options: client.defaultMutationOptions(options),
            state,
          });
        this.add(mutation);
        return mutation;
      }
      add(mutation) {
        this.#mutations.add(mutation);
        const scope = scopeFor(mutation);
        if (typeof scope === "string") {
          const scopedMutations = this.#scopes.get(scope);
          if (scopedMutations) {
            scopedMutations.push(mutation);
          } else {
            this.#scopes.set(scope, [mutation]);
          }
        }
        this.notify({
          type: "added",
          mutation,
        });
      }
      remove(mutation) {
        if (this.#mutations.delete(mutation)) {
          const scope = scopeFor(mutation);
          if (typeof scope === "string") {
            const scopedMutations = this.#scopes.get(scope);
            if (scopedMutations) {
              if (scopedMutations.length > 1) {
                const index = scopedMutations.indexOf(mutation);
                if (index !== -1) {
                  scopedMutations.splice(index, 1);
                }
              } else if (scopedMutations[0] === mutation) {
                this.#scopes.delete(scope);
              }
            }
          }
        }
        this.notify({
          type: "removed",
          mutation,
        });
      }
      canRun(mutation) {
        const scope = scopeFor(mutation);
        if (typeof scope === "string") {
          const mutationsWithSameScope = this.#scopes.get(scope);
          const firstPendingMutation = mutationsWithSameScope?.find(
            (m) => m.state.status === "pending",
          );
          return !firstPendingMutation || firstPendingMutation === mutation;
        } else {
          return true;
        }
      }
      runNext(mutation) {
        const scope = scopeFor(mutation);
        if (typeof scope === "string") {
          const foundMutation = this.#scopes
            .get(scope)
            ?.find((m) => m !== mutation && m.state.isPaused);
          return foundMutation?.continue() ?? Promise.resolve();
        } else {
          return Promise.resolve();
        }
      }
      clear() {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() => {
          this.#mutations.forEach((mutation) => {
            this.notify({
              type: "removed",
              mutation,
            });
          });
          this.#mutations.clear();
          this.#scopes.clear();
        });
      }
      getAll() {
        return Array.from(this.#mutations);
      }
      find(filters) {
        const defaultedFilters = {
          exact: true,
          ...filters,
        };
        return this.getAll().find((mutation) =>
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "matchMutation"
          ])(defaultedFilters, mutation),
        );
      }
      findAll(filters = {}) {
        return this.getAll().filter((mutation) =>
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "matchMutation"
          ])(filters, mutation),
        );
      }
      notify(event) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() => {
          this.listeners.forEach((listener) => {
            listener(event);
          });
        });
      }
      resumePausedMutations() {
        const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() =>
          Promise.all(
            pausedMutations.map((mutation) =>
              mutation
                .continue()
                .catch(
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "noop"
                  ],
                ),
            ),
          ),
        );
      }
    };
    function scopeFor(mutation) {
      return mutation.options.scope?.id;
    }
  },
  //# sourceMappingURL=mutationCache.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "hasNextPage",
      () => hasNextPage,
      "hasPreviousPage",
      () => hasPreviousPage,
      "infiniteQueryBehavior",
      () => infiniteQueryBehavior,
    ]);
    // src/infiniteQueryBehavior.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)",
      );
    function infiniteQueryBehavior(pages) {
      return {
        onFetch: (context, query) => {
          const options = context.options;
          const direction = context.fetchOptions?.meta?.fetchMore?.direction;
          const oldPages = context.state.data?.pages || [];
          const oldPageParams = context.state.data?.pageParams || [];
          let result = {
            pages: [],
            pageParams: [],
          };
          let currentPage = 0;
          const fetchFn = async () => {
            let cancelled = false;
            const addSignalProperty = (object) => {
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "addConsumeAwareSignal"
              ])(
                object,
                () => context.signal,
                () => (cancelled = true),
              );
            };
            const queryFn = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "ensureQueryFn"
            ])(context.options, context.fetchOptions);
            const fetchPage = async (data, param, previous) => {
              if (cancelled) {
                return Promise.reject();
              }
              if (param == null && data.pages.length) {
                return Promise.resolve(data);
              }
              const createQueryFnContext = () => {
                const queryFnContext2 = {
                  client: context.client,
                  queryKey: context.queryKey,
                  pageParam: param,
                  direction: previous ? "backward" : "forward",
                  meta: context.options.meta,
                };
                addSignalProperty(queryFnContext2);
                return queryFnContext2;
              };
              const queryFnContext = createQueryFnContext();
              const page = await queryFn(queryFnContext);
              const { maxPages } = context.options;
              const addTo = previous
                ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "addToStart"
                  ]
                : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "addToEnd"
                  ];
              return {
                pages: addTo(data.pages, page, maxPages),
                pageParams: addTo(data.pageParams, param, maxPages),
              };
            };
            if (direction && oldPages.length) {
              const previous = direction === "backward";
              const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
              const oldData = {
                pages: oldPages,
                pageParams: oldPageParams,
              };
              const param = pageParamFn(options, oldData);
              result = await fetchPage(oldData, param, previous);
            } else {
              const remainingPages = pages ?? oldPages.length;
              do {
                const param =
                  currentPage === 0
                    ? (oldPageParams[0] ?? options.initialPageParam)
                    : getNextPageParam(options, result);
                if (currentPage > 0 && param == null) {
                  break;
                }
                result = await fetchPage(result, param);
                currentPage++;
              } while (currentPage < remainingPages);
            }
            return result;
          };
          if (context.options.persister) {
            context.fetchFn = () => {
              return context.options.persister?.(
                fetchFn,
                {
                  client: context.client,
                  queryKey: context.queryKey,
                  meta: context.options.meta,
                  signal: context.signal,
                },
                query,
              );
            };
          } else {
            context.fetchFn = fetchFn;
          }
        },
      };
    }
    function getNextPageParam(options, { pages, pageParams }) {
      const lastIndex = pages.length - 1;
      return pages.length > 0
        ? options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams)
        : void 0;
    }
    function getPreviousPageParam(options, { pages, pageParams }) {
      return pages.length > 0
        ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams)
        : void 0;
    }
    function hasNextPage(options, data) {
      if (!data) return false;
      return getNextPageParam(options, data) != null;
    }
    function hasPreviousPage(options, data) {
      if (!data || !options.getPreviousPageParam) return false;
      return getPreviousPageParam(options, data) != null;
    }
  },
  //# sourceMappingURL=infiniteQueryBehavior.js.map
  "[project]/node_modules/@tanstack/query-core/build/modern/queryClient.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["QueryClient", () => QueryClient]);
    // src/queryClient.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$queryCache$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/queryCache.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$mutationCache$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/mutationCache.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$focusManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/focusManager.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$onlineManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/onlineManager.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/notifyManager.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$infiniteQueryBehavior$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js [app-client] (ecmascript)",
      );
    var QueryClient = class {
      #queryCache;
      #mutationCache;
      #defaultOptions;
      #queryDefaults;
      #mutationDefaults;
      #mountCount;
      #unsubscribeFocus;
      #unsubscribeOnline;
      constructor(config = {}) {
        this.#queryCache =
          config.queryCache ||
          new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$queryCache$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "QueryCache"
          ]();
        this.#mutationCache =
          config.mutationCache ||
          new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$mutationCache$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "MutationCache"
          ]();
        this.#defaultOptions = config.defaultOptions || {};
        this.#queryDefaults = /* @__PURE__ */ new Map();
        this.#mutationDefaults = /* @__PURE__ */ new Map();
        this.#mountCount = 0;
      }
      mount() {
        this.#mountCount++;
        if (this.#mountCount !== 1) return;
        this.#unsubscribeFocus =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$focusManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "focusManager"
          ].subscribe(async (focused) => {
            if (focused) {
              await this.resumePausedMutations();
              this.#queryCache.onFocus();
            }
          });
        this.#unsubscribeOnline =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$onlineManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "onlineManager"
          ].subscribe(async (online) => {
            if (online) {
              await this.resumePausedMutations();
              this.#queryCache.onOnline();
            }
          });
      }
      unmount() {
        this.#mountCount--;
        if (this.#mountCount !== 0) return;
        this.#unsubscribeFocus?.();
        this.#unsubscribeFocus = void 0;
        this.#unsubscribeOnline?.();
        this.#unsubscribeOnline = void 0;
      }
      isFetching(filters) {
        return this.#queryCache.findAll({
          ...filters,
          fetchStatus: "fetching",
        }).length;
      }
      isMutating(filters) {
        return this.#mutationCache.findAll({
          ...filters,
          status: "pending",
        }).length;
      }
      /**
       * Imperative (non-reactive) way to retrieve data for a QueryKey.
       * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
       *
       * Hint: Do not use this function inside a component, because it won't receive updates.
       * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
       */ getQueryData(queryKey) {
        const options = this.defaultQueryOptions({
          queryKey,
        });
        return this.#queryCache.get(options.queryHash)?.state.data;
      }
      ensureQueryData(options) {
        const defaultedOptions = this.defaultQueryOptions(options);
        const query = this.#queryCache.build(this, defaultedOptions);
        const cachedData = query.state.data;
        if (cachedData === void 0) {
          return this.fetchQuery(options);
        }
        if (
          options.revalidateIfStale &&
          query.isStaleByTime(
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "resolveStaleTime"
            ])(defaultedOptions.staleTime, query),
          )
        ) {
          void this.prefetchQuery(defaultedOptions);
        }
        return Promise.resolve(cachedData);
      }
      getQueriesData(filters) {
        return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {
          const data = state.data;
          return [queryKey, data];
        });
      }
      setQueryData(queryKey, updater, options) {
        const defaultedOptions = this.defaultQueryOptions({
          queryKey,
        });
        const query = this.#queryCache.get(defaultedOptions.queryHash);
        const prevData = query?.state.data;
        const data = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "functionalUpdate"
        ])(updater, prevData);
        if (data === void 0) {
          return void 0;
        }
        return this.#queryCache.build(this, defaultedOptions).setData(data, {
          ...options,
          manual: true,
        });
      }
      setQueriesData(filters, updater, options) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() =>
          this.#queryCache
            .findAll(filters)
            .map(({ queryKey }) => [queryKey, this.setQueryData(queryKey, updater, options)]),
        );
      }
      getQueryState(queryKey) {
        const options = this.defaultQueryOptions({
          queryKey,
        });
        return this.#queryCache.get(options.queryHash)?.state;
      }
      removeQueries(filters) {
        const queryCache = this.#queryCache;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() => {
          queryCache.findAll(filters).forEach((query) => {
            queryCache.remove(query);
          });
        });
      }
      resetQueries(filters, options) {
        const queryCache = this.#queryCache;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() => {
          queryCache.findAll(filters).forEach((query) => {
            query.reset();
          });
          return this.refetchQueries(
            {
              type: "active",
              ...filters,
            },
            options,
          );
        });
      }
      cancelQueries(filters, cancelOptions = {}) {
        const defaultedCancelOptions = {
          revert: true,
          ...cancelOptions,
        };
        const promises =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "notifyManager"
          ].batch(() =>
            this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions)),
          );
        return Promise.all(promises)
          .then(
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "noop"
            ],
          )
          .catch(
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "noop"
            ],
          );
      }
      invalidateQueries(filters, options = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "notifyManager"
        ].batch(() => {
          this.#queryCache.findAll(filters).forEach((query) => {
            query.invalidate();
          });
          if (filters?.refetchType === "none") {
            return Promise.resolve();
          }
          return this.refetchQueries(
            {
              ...filters,
              type: filters?.refetchType ?? filters?.type ?? "active",
            },
            options,
          );
        });
      }
      refetchQueries(filters, options = {}) {
        const fetchOptions = {
          ...options,
          cancelRefetch: options.cancelRefetch ?? true,
        };
        const promises =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "notifyManager"
          ].batch(() =>
            this.#queryCache
              .findAll(filters)
              .filter((query) => !query.isDisabled() && !query.isStatic())
              .map((query) => {
                let promise = query.fetch(void 0, fetchOptions);
                if (!fetchOptions.throwOnError) {
                  promise = promise.catch(
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                      "noop"
                    ],
                  );
                }
                return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
              }),
          );
        return Promise.all(promises).then(
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "noop"
          ],
        );
      }
      fetchQuery(options) {
        const defaultedOptions = this.defaultQueryOptions(options);
        if (defaultedOptions.retry === void 0) {
          defaultedOptions.retry = false;
        }
        const query = this.#queryCache.build(this, defaultedOptions);
        return query.isStaleByTime(
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "resolveStaleTime"
          ])(defaultedOptions.staleTime, query),
        )
          ? query.fetch(defaultedOptions)
          : Promise.resolve(query.state.data);
      }
      prefetchQuery(options) {
        return this.fetchQuery(options)
          .then(
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "noop"
            ],
          )
          .catch(
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "noop"
            ],
          );
      }
      fetchInfiniteQuery(options) {
        options.behavior = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$infiniteQueryBehavior$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "infiniteQueryBehavior"
        ])(options.pages);
        return this.fetchQuery(options);
      }
      prefetchInfiniteQuery(options) {
        return this.fetchInfiniteQuery(options)
          .then(
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "noop"
            ],
          )
          .catch(
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "noop"
            ],
          );
      }
      ensureInfiniteQueryData(options) {
        options.behavior = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$infiniteQueryBehavior$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "infiniteQueryBehavior"
        ])(options.pages);
        return this.ensureQueryData(options);
      }
      resumePausedMutations() {
        if (
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$onlineManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "onlineManager"
          ].isOnline()
        ) {
          return this.#mutationCache.resumePausedMutations();
        }
        return Promise.resolve();
      }
      getQueryCache() {
        return this.#queryCache;
      }
      getMutationCache() {
        return this.#mutationCache;
      }
      getDefaultOptions() {
        return this.#defaultOptions;
      }
      setDefaultOptions(options) {
        this.#defaultOptions = options;
      }
      setQueryDefaults(queryKey, options) {
        this.#queryDefaults.set(
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "hashKey"
          ])(queryKey),
          {
            queryKey,
            defaultOptions: options,
          },
        );
      }
      getQueryDefaults(queryKey) {
        const defaults = [...this.#queryDefaults.values()];
        const result = {};
        defaults.forEach((queryDefault) => {
          if (
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "partialMatchKey"
            ])(queryKey, queryDefault.queryKey)
          ) {
            Object.assign(result, queryDefault.defaultOptions);
          }
        });
        return result;
      }
      setMutationDefaults(mutationKey, options) {
        this.#mutationDefaults.set(
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "hashKey"
          ])(mutationKey),
          {
            mutationKey,
            defaultOptions: options,
          },
        );
      }
      getMutationDefaults(mutationKey) {
        const defaults = [...this.#mutationDefaults.values()];
        const result = {};
        defaults.forEach((queryDefault) => {
          if (
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "partialMatchKey"
            ])(mutationKey, queryDefault.mutationKey)
          ) {
            Object.assign(result, queryDefault.defaultOptions);
          }
        });
        return result;
      }
      defaultQueryOptions(options) {
        if (options._defaulted) {
          return options;
        }
        const defaultedOptions = {
          ...this.#defaultOptions.queries,
          ...this.getQueryDefaults(options.queryKey),
          ...options,
          _defaulted: true,
        };
        if (!defaultedOptions.queryHash) {
          defaultedOptions.queryHash = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "hashQueryKeyByOptions"
          ])(defaultedOptions.queryKey, defaultedOptions);
        }
        if (defaultedOptions.refetchOnReconnect === void 0) {
          defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
        }
        if (defaultedOptions.throwOnError === void 0) {
          defaultedOptions.throwOnError = !!defaultedOptions.suspense;
        }
        if (!defaultedOptions.networkMode && defaultedOptions.persister) {
          defaultedOptions.networkMode = "offlineFirst";
        }
        if (
          defaultedOptions.queryFn ===
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "skipToken"
          ]
        ) {
          defaultedOptions.enabled = false;
        }
        return defaultedOptions;
      }
      defaultMutationOptions(options) {
        if (options?._defaulted) {
          return options;
        }
        return {
          ...this.#defaultOptions.mutations,
          ...(options?.mutationKey && this.getMutationDefaults(options.mutationKey)),
          ...options,
          _defaulted: true,
        };
      }
      clear() {
        this.#queryCache.clear();
        this.#mutationCache.clear();
      }
    };
  },
  //# sourceMappingURL=queryClient.js.map
  "[project]/node_modules/@tanstack/react-query-devtools/build/modern/ReactQueryDevtools.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["ReactQueryDevtools", () => ReactQueryDevtools]);
    // src/ReactQueryDevtools.tsx
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$onlineManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/onlineManager.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$QueryClientProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$devtools$2f$build$2f$dev$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-devtools/build/dev.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)",
      );
    ("use client");
    function ReactQueryDevtools(props) {
      const queryClient = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$QueryClientProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useQueryClient"
      ])(props.client);
      const ref =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useRef"
        ](null);
      const {
        buttonPosition,
        position,
        initialIsOpen,
        errorTypes,
        styleNonce,
        shadowDOMTarget,
        hideDisabledQueries,
        theme,
      } = props;
      const [devtools] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useState"
        ](
          new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$devtools$2f$build$2f$dev$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "TanstackQueryDevtools"
          ]({
            client: queryClient,
            queryFlavor: "React Query",
            version: "5",
            onlineManager:
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$onlineManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "onlineManager"
              ],
            buttonPosition,
            position,
            initialIsOpen,
            errorTypes,
            styleNonce,
            shadowDOMTarget,
            hideDisabledQueries,
            theme,
          }),
        );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "ReactQueryDevtools.useEffect": () => {
            devtools.setClient(queryClient);
          },
        }["ReactQueryDevtools.useEffect"],
        [queryClient, devtools],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "ReactQueryDevtools.useEffect": () => {
            if (buttonPosition) {
              devtools.setButtonPosition(buttonPosition);
            }
          },
        }["ReactQueryDevtools.useEffect"],
        [buttonPosition, devtools],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "ReactQueryDevtools.useEffect": () => {
            if (position) {
              devtools.setPosition(position);
            }
          },
        }["ReactQueryDevtools.useEffect"],
        [position, devtools],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "ReactQueryDevtools.useEffect": () => {
            devtools.setInitialIsOpen(initialIsOpen || false);
          },
        }["ReactQueryDevtools.useEffect"],
        [initialIsOpen, devtools],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "ReactQueryDevtools.useEffect": () => {
            devtools.setErrorTypes(errorTypes || []);
          },
        }["ReactQueryDevtools.useEffect"],
        [errorTypes, devtools],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "ReactQueryDevtools.useEffect": () => {
            devtools.setTheme(theme);
          },
        }["ReactQueryDevtools.useEffect"],
        [theme, devtools],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "ReactQueryDevtools.useEffect": () => {
            if (ref.current) {
              devtools.mount(ref.current);
            }
            return {
              "ReactQueryDevtools.useEffect": () => {
                devtools.unmount();
              },
            }["ReactQueryDevtools.useEffect"];
          },
        }["ReactQueryDevtools.useEffect"],
        [devtools],
      );
      return /* @__PURE__ */ (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "jsx"
      ])("div", {
        dir: "ltr",
        className: "tsqd-parent-container",
        ref,
      });
    }
  },
  //# sourceMappingURL=ReactQueryDevtools.js.map
  "[project]/node_modules/@tanstack/react-query-devtools/build/modern/ReactQueryDevtoolsPanel.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["ReactQueryDevtoolsPanel", () => ReactQueryDevtoolsPanel]);
    // src/ReactQueryDevtoolsPanel.tsx
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$onlineManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/onlineManager.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$QueryClientProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$devtools$2f$build$2f$dev$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-devtools/build/dev.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)",
      );
    ("use client");
    function ReactQueryDevtoolsPanel(props) {
      const queryClient = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$modern$2f$QueryClientProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useQueryClient"
      ])(props.client);
      const ref =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useRef"
        ](null);
      const { errorTypes, styleNonce, shadowDOMTarget, hideDisabledQueries, theme } = props;
      const [devtools] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useState"
        ](
          new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$devtools$2f$build$2f$dev$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "TanstackQueryDevtoolsPanel"
          ]({
            client: queryClient,
            queryFlavor: "React Query",
            version: "5",
            onlineManager:
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$onlineManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "onlineManager"
              ],
            buttonPosition: "bottom-left",
            position: "bottom",
            initialIsOpen: true,
            errorTypes,
            styleNonce,
            shadowDOMTarget,
            onClose: props.onClose,
            hideDisabledQueries,
            theme,
          }),
        );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "ReactQueryDevtoolsPanel.useEffect": () => {
            devtools.setClient(queryClient);
          },
        }["ReactQueryDevtoolsPanel.useEffect"],
        [queryClient, devtools],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "ReactQueryDevtoolsPanel.useEffect": () => {
            devtools.setOnClose(
              props.onClose ??
                {
                  "ReactQueryDevtoolsPanel.useEffect": () => {},
                }["ReactQueryDevtoolsPanel.useEffect"],
            );
          },
        }["ReactQueryDevtoolsPanel.useEffect"],
        [props.onClose, devtools],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "ReactQueryDevtoolsPanel.useEffect": () => {
            devtools.setErrorTypes(errorTypes || []);
          },
        }["ReactQueryDevtoolsPanel.useEffect"],
        [errorTypes, devtools],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "ReactQueryDevtoolsPanel.useEffect": () => {
            devtools.setTheme(theme);
          },
        }["ReactQueryDevtoolsPanel.useEffect"],
        [theme, devtools],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "useEffect"
      ](
        {
          "ReactQueryDevtoolsPanel.useEffect": () => {
            if (ref.current) {
              devtools.mount(ref.current);
            }
            return {
              "ReactQueryDevtoolsPanel.useEffect": () => {
                devtools.unmount();
              },
            }["ReactQueryDevtoolsPanel.useEffect"];
          },
        }["ReactQueryDevtoolsPanel.useEffect"],
        [devtools],
      );
      return /* @__PURE__ */ (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "jsx"
      ])("div", {
        style: {
          height: "500px",
          ...props.style,
        },
        className: "tsqd-parent-container",
        ref,
      });
    }
  },
  //# sourceMappingURL=ReactQueryDevtoolsPanel.js.map
  "[project]/node_modules/@tanstack/react-query-devtools/build/modern/index.js [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "ReactQueryDevtools",
      () => ReactQueryDevtools2,
      "ReactQueryDevtoolsPanel",
      () => ReactQueryDevtoolsPanel2,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      /*#__PURE__*/ __turbopack_context__.i(
        "[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)",
      );
    // src/index.ts
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2d$devtools$2f$build$2f$modern$2f$ReactQueryDevtools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/react-query-devtools/build/modern/ReactQueryDevtools.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2d$devtools$2f$build$2f$modern$2f$ReactQueryDevtoolsPanel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/react-query-devtools/build/modern/ReactQueryDevtoolsPanel.js [app-client] (ecmascript)",
      );
    ("use client");
    var ReactQueryDevtools2 = ("TURBOPACK compile-time falsy", 0)
      ? "TURBOPACK unreachable"
      : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2d$devtools$2f$build$2f$modern$2f$ReactQueryDevtools$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "ReactQueryDevtools"
        ];
    var ReactQueryDevtoolsPanel2 = ("TURBOPACK compile-time falsy", 0)
      ? "TURBOPACK unreachable"
      : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$react$2d$query$2d$devtools$2f$build$2f$modern$2f$ReactQueryDevtoolsPanel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "ReactQueryDevtoolsPanel"
        ];
  },
  //# sourceMappingURL=index.js.map
  "[project]/node_modules/@orpc/shared/dist/index.mjs [app-client] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "AbortError",
      () => AbortError,
      "AsyncIdQueue",
      () => AsyncIdQueue,
      "AsyncIteratorClass",
      () => AsyncIteratorClass,
      "EventPublisher",
      () => EventPublisher,
      "NullProtoObj",
      () => NullProtoObj,
      "ORPC_NAME",
      () => ORPC_NAME,
      "ORPC_SHARED_PACKAGE_NAME",
      () => ORPC_SHARED_PACKAGE_NAME,
      "ORPC_SHARED_PACKAGE_VERSION",
      () => ORPC_SHARED_PACKAGE_VERSION,
      "SequentialIdGenerator",
      () => SequentialIdGenerator,
      "asyncIteratorToStream",
      () => asyncIteratorToStream,
      "asyncIteratorToUnproxiedDataStream",
      () => asyncIteratorToUnproxiedDataStream,
      "asyncIteratorWithSpan",
      () => asyncIteratorWithSpan,
      "clone",
      () => clone,
      "compareSequentialIds",
      () => compareSequentialIds,
      "defer",
      () => defer,
      "fallback",
      () => fallback,
      "findDeepMatches",
      () => findDeepMatches,
      "get",
      () => get,
      "getConstructor",
      () => getConstructor,
      "getGlobalOtelConfig",
      () => getGlobalOtelConfig,
      "intercept",
      () => intercept,
      "isAsyncIteratorObject",
      () => isAsyncIteratorObject,
      "isObject",
      () => isObject,
      "isPropertyKey",
      () => isPropertyKey,
      "isTypescriptObject",
      () => isTypescriptObject,
      "onError",
      () => onError,
      "onFinish",
      () => onFinish,
      "onStart",
      () => onStart,
      "onSuccess",
      () => onSuccess,
      "once",
      () => once,
      "overlayProxy",
      () => overlayProxy,
      "parseEmptyableJSON",
      () => parseEmptyableJSON,
      "preventNativeAwait",
      () => preventNativeAwait,
      "readAsBuffer",
      () => readAsBuffer,
      "replicateAsyncIterator",
      () => replicateAsyncIterator,
      "resolveMaybeOptionalOptions",
      () => resolveMaybeOptionalOptions,
      "runInSpanContext",
      () => runInSpanContext,
      "runWithSpan",
      () => runWithSpan,
      "sequential",
      () => sequential,
      "setGlobalOtelConfig",
      () => setGlobalOtelConfig,
      "setSpanAttribute",
      () => setSpanAttribute,
      "setSpanError",
      () => setSpanError,
      "splitInHalf",
      () => splitInHalf,
      "startSpan",
      () => startSpan,
      "streamToAsyncIteratorClass",
      () => streamToAsyncIteratorClass,
      "stringifyJSON",
      () => stringifyJSON,
      "toArray",
      () => toArray,
      "toOtelException",
      () => toOtelException,
      "toSpanAttributeValue",
      () => toSpanAttributeValue,
      "tryDecodeURIComponent",
      () => tryDecodeURIComponent,
      "value",
      () => value,
    ]);
    function resolveMaybeOptionalOptions(rest) {
      return rest[0] ?? {};
    }
    function toArray(value) {
      return Array.isArray(value) ? value : value === void 0 || value === null ? [] : [value];
    }
    function splitInHalf(arr) {
      const half = Math.ceil(arr.length / 2);
      return [arr.slice(0, half), arr.slice(half)];
    }
    function readAsBuffer(source) {
      if (typeof source.bytes === "function") {
        return source.bytes();
      }
      return source.arrayBuffer();
    }
    const ORPC_NAME = "orpc";
    const ORPC_SHARED_PACKAGE_NAME = "@orpc/shared";
    const ORPC_SHARED_PACKAGE_VERSION = "1.13.5";
    class AbortError extends Error {
      constructor(...rest) {
        super(...rest);
        this.name = "AbortError";
      }
    }
    function once(fn) {
      let cached;
      return () => {
        if (cached) {
          return cached.result;
        }
        const result = fn();
        cached = {
          result,
        };
        return result;
      };
    }
    function sequential(fn) {
      let lastOperationPromise = Promise.resolve();
      return (...args) => {
        return (lastOperationPromise = lastOperationPromise
          .catch(() => {})
          .then(() => {
            return fn(...args);
          }));
      };
    }
    function defer(callback) {
      if (typeof setTimeout === "function") {
        setTimeout(callback, 0);
      } else {
        Promise.resolve().then(() =>
          Promise.resolve().then(() => Promise.resolve().then(callback)),
        );
      }
    }
    const SPAN_ERROR_STATUS = 2;
    const GLOBAL_OTEL_CONFIG_KEY = `__${ORPC_SHARED_PACKAGE_NAME}@${ORPC_SHARED_PACKAGE_VERSION}/otel/config__`;
    function setGlobalOtelConfig(config) {
      globalThis[GLOBAL_OTEL_CONFIG_KEY] = config;
    }
    function getGlobalOtelConfig() {
      return globalThis[GLOBAL_OTEL_CONFIG_KEY];
    }
    function startSpan(name, options = {}, context) {
      const tracer = getGlobalOtelConfig()?.tracer;
      return tracer?.startSpan(name, options, context);
    }
    function setSpanError(span, error, options = {}) {
      if (!span) {
        return;
      }
      const exception = toOtelException(error);
      span.recordException(exception);
      if (!options.signal?.aborted || options.signal.reason !== error) {
        span.setStatus({
          code: SPAN_ERROR_STATUS,
          message: exception.message,
        });
      }
    }
    function setSpanAttribute(span, key, value) {
      if (!span || value === void 0) {
        return;
      }
      span.setAttribute(key, value);
    }
    function toOtelException(error) {
      if (error instanceof Error) {
        const exception = {
          message: error.message,
          name: error.name,
          stack: error.stack,
        };
        if ("code" in error && (typeof error.code === "string" || typeof error.code === "number")) {
          exception.code = error.code;
        }
        return exception;
      }
      return {
        message: String(error),
      };
    }
    function toSpanAttributeValue(data) {
      if (data === void 0) {
        return "undefined";
      }
      try {
        return JSON.stringify(data, (_, value) => {
          if (typeof value === "bigint") {
            return value.toString();
          }
          if (value instanceof Map || value instanceof Set) {
            return Array.from(value);
          }
          return value;
        });
      } catch {
        return String(data);
      }
    }
    async function runWithSpan({ name, context, ...options }, fn) {
      const tracer = getGlobalOtelConfig()?.tracer;
      if (!tracer) {
        return fn();
      }
      const callback = async (span) => {
        try {
          return await fn(span);
        } catch (e) {
          setSpanError(span, e, options);
          throw e;
        } finally {
          span.end();
        }
      };
      if (context) {
        return tracer.startActiveSpan(name, options, context, callback);
      } else {
        return tracer.startActiveSpan(name, options, callback);
      }
    }
    async function runInSpanContext(span, fn) {
      const otelConfig = getGlobalOtelConfig();
      if (!span || !otelConfig) {
        return fn();
      }
      const ctx = otelConfig.trace.setSpan(otelConfig.context.active(), span);
      return otelConfig.context.with(ctx, fn);
    }
    class AsyncIdQueue {
      openIds = /* @__PURE__ */ new Set();
      queues = /* @__PURE__ */ new Map();
      waiters = /* @__PURE__ */ new Map();
      get length() {
        return this.openIds.size;
      }
      get waiterIds() {
        return Array.from(this.waiters.keys());
      }
      hasBufferedItems(id) {
        return Boolean(this.queues.get(id)?.length);
      }
      open(id) {
        this.openIds.add(id);
      }
      isOpen(id) {
        return this.openIds.has(id);
      }
      push(id, item) {
        this.assertOpen(id);
        const pending = this.waiters.get(id);
        if (pending?.length) {
          pending.shift()[0](item);
          if (pending.length === 0) {
            this.waiters.delete(id);
          }
        } else {
          const items = this.queues.get(id);
          if (items) {
            items.push(item);
          } else {
            this.queues.set(id, [item]);
          }
        }
      }
      async pull(id) {
        this.assertOpen(id);
        const items = this.queues.get(id);
        if (items?.length) {
          const item = items.shift();
          if (items.length === 0) {
            this.queues.delete(id);
          }
          return item;
        }
        return new Promise((resolve, reject) => {
          const waitingPulls = this.waiters.get(id);
          const pending = [resolve, reject];
          if (waitingPulls) {
            waitingPulls.push(pending);
          } else {
            this.waiters.set(id, [pending]);
          }
        });
      }
      close({ id, reason } = {}) {
        if (id === void 0) {
          this.waiters.forEach((pendingPulls, id2) => {
            const error2 =
              reason ??
              new AbortError(
                `[AsyncIdQueue] Queue[${id2}] was closed or aborted while waiting for pulling.`,
              );
            pendingPulls.forEach(([, reject]) => reject(error2));
          });
          this.waiters.clear();
          this.openIds.clear();
          this.queues.clear();
          return;
        }
        const error =
          reason ??
          new AbortError(
            `[AsyncIdQueue] Queue[${id}] was closed or aborted while waiting for pulling.`,
          );
        this.waiters.get(id)?.forEach(([, reject]) => reject(error));
        this.waiters.delete(id);
        this.openIds.delete(id);
        this.queues.delete(id);
      }
      assertOpen(id) {
        if (!this.isOpen(id)) {
          throw new Error(
            `[AsyncIdQueue] Cannot access queue[${id}] because it is not open or aborted.`,
          );
        }
      }
    }
    function isAsyncIteratorObject(maybe) {
      if (!maybe || typeof maybe !== "object") {
        return false;
      }
      return (
        "next" in maybe &&
        typeof maybe.next === "function" &&
        Symbol.asyncIterator in maybe &&
        typeof maybe[Symbol.asyncIterator] === "function"
      );
    }
    const fallbackAsyncDisposeSymbol = Symbol.for("asyncDispose");
    const asyncDisposeSymbol = Symbol.asyncDispose ?? fallbackAsyncDisposeSymbol;
    class AsyncIteratorClass {
      #isDone = false;
      #isExecuteComplete = false;
      #cleanup;
      #next;
      constructor(next, cleanup) {
        this.#cleanup = cleanup;
        this.#next = sequential(async () => {
          if (this.#isDone) {
            return {
              done: true,
              value: void 0,
            };
          }
          try {
            const result = await next();
            if (result.done) {
              this.#isDone = true;
            }
            return result;
          } catch (err) {
            this.#isDone = true;
            throw err;
          } finally {
            if (this.#isDone && !this.#isExecuteComplete) {
              this.#isExecuteComplete = true;
              await this.#cleanup("next");
            }
          }
        });
      }
      next() {
        return this.#next();
      }
      async return(value) {
        this.#isDone = true;
        if (!this.#isExecuteComplete) {
          this.#isExecuteComplete = true;
          await this.#cleanup("return");
        }
        return {
          done: true,
          value,
        };
      }
      async throw(err) {
        this.#isDone = true;
        if (!this.#isExecuteComplete) {
          this.#isExecuteComplete = true;
          await this.#cleanup("throw");
        }
        throw err;
      }
      /**
       * asyncDispose symbol only available in esnext, we should fallback to Symbol.for('asyncDispose')
       */ async [asyncDisposeSymbol]() {
        this.#isDone = true;
        if (!this.#isExecuteComplete) {
          this.#isExecuteComplete = true;
          await this.#cleanup("dispose");
        }
      }
      [Symbol.asyncIterator]() {
        return this;
      }
    }
    function replicateAsyncIterator(source, count) {
      const queue = new AsyncIdQueue();
      const ids = Array.from(
        {
          length: count,
        },
        (_, i) => i.toString(),
      );
      let isSourceFinished = false;
      const start = once(async () => {
        try {
          while (true) {
            const item = await source.next();
            ids.forEach((id) => {
              if (queue.isOpen(id)) {
                queue.push(id, {
                  next: item,
                });
              }
            });
            if (item.done) {
              break;
            }
          }
        } catch (error) {
          ids.forEach((id) => {
            if (queue.isOpen(id)) {
              queue.push(id, {
                error,
              });
            }
          });
        } finally {
          isSourceFinished = true;
        }
      });
      const replicated = ids.map((id) => {
        queue.open(id);
        return new AsyncIteratorClass(
          async () => {
            start();
            const item = await queue.pull(id);
            if (item.next) {
              return item.next;
            }
            throw item.error;
          },
          async (reason) => {
            queue.close({
              id,
            });
            if (reason !== "next" && !queue.length && !isSourceFinished) {
              isSourceFinished = true;
              await source?.return?.();
            }
          },
        );
      });
      return replicated;
    }
    function asyncIteratorWithSpan({ name, ...options }, iterator) {
      let span;
      return new AsyncIteratorClass(
        async () => {
          span ??= startSpan(name);
          try {
            const result = await runInSpanContext(span, () => iterator.next());
            span?.addEvent(result.done ? "completed" : "yielded");
            return result;
          } catch (err) {
            setSpanError(span, err, options);
            throw err;
          }
        },
        async (reason) => {
          try {
            if (reason !== "next") {
              await runInSpanContext(span, () => iterator.return?.());
            }
          } catch (err) {
            setSpanError(span, err, options);
            throw err;
          } finally {
            span?.end();
          }
        },
      );
    }
    class EventPublisher {
      #listenersMap = /* @__PURE__ */ new Map();
      #maxBufferedEvents;
      constructor(options = {}) {
        this.#maxBufferedEvents = options.maxBufferedEvents ?? 100;
      }
      get size() {
        return this.#listenersMap.size;
      }
      /**
       * Emits an event and delivers the payload to all subscribed listeners.
       */ publish(event, payload) {
        const listeners = this.#listenersMap.get(event);
        if (!listeners) {
          return;
        }
        for (const listener of listeners) {
          listener(payload);
        }
      }
      subscribe(event, listenerOrOptions) {
        if (typeof listenerOrOptions === "function") {
          let listeners = this.#listenersMap.get(event);
          if (!listeners) {
            this.#listenersMap.set(event, (listeners = []));
          }
          listeners.push(listenerOrOptions);
          return once(() => {
            listeners.splice(listeners.indexOf(listenerOrOptions), 1);
            if (listeners.length === 0) {
              this.#listenersMap.delete(event);
            }
          });
        }
        const signal = listenerOrOptions?.signal;
        const maxBufferedEvents = listenerOrOptions?.maxBufferedEvents ?? this.#maxBufferedEvents;
        signal?.throwIfAborted();
        const bufferedEvents = [];
        const pullResolvers = [];
        const unsubscribe = this.subscribe(event, (payload) => {
          const resolver = pullResolvers.shift();
          if (resolver) {
            resolver[0]({
              done: false,
              value: payload,
            });
          } else {
            bufferedEvents.push(payload);
            if (bufferedEvents.length > maxBufferedEvents) {
              bufferedEvents.shift();
            }
          }
        });
        const abortListener = (event2) => {
          unsubscribe();
          pullResolvers.forEach((resolver) => resolver[1](event2.target.reason));
          pullResolvers.length = 0;
          bufferedEvents.length = 0;
        };
        signal?.addEventListener("abort", abortListener, {
          once: true,
        });
        return new AsyncIteratorClass(
          async () => {
            if (signal?.aborted) {
              throw signal.reason;
            }
            if (bufferedEvents.length > 0) {
              return {
                done: false,
                value: bufferedEvents.shift(),
              };
            }
            return new Promise((resolve, reject) => {
              pullResolvers.push([resolve, reject]);
            });
          },
          async () => {
            unsubscribe();
            signal?.removeEventListener("abort", abortListener);
            pullResolvers.forEach((resolver) =>
              resolver[0]({
                done: true,
                value: void 0,
              }),
            );
            pullResolvers.length = 0;
            bufferedEvents.length = 0;
          },
        );
      }
    }
    class SequentialIdGenerator {
      index = BigInt(1);
      generate() {
        const id = this.index.toString(36);
        this.index++;
        return id;
      }
    }
    function compareSequentialIds(a, b) {
      if (a.length !== b.length) {
        return a.length - b.length;
      }
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function onStart(callback) {
      return async (options, ...rest) => {
        await callback(options, ...rest);
        return await options.next();
      };
    }
    function onSuccess(callback) {
      return async (options, ...rest) => {
        const result = await options.next();
        await callback(result, options, ...rest);
        return result;
      };
    }
    function onError(callback) {
      return async (options, ...rest) => {
        try {
          return await options.next();
        } catch (error) {
          await callback(error, options, ...rest);
          throw error;
        }
      };
    }
    function onFinish(callback) {
      let state;
      return async (options, ...rest) => {
        try {
          const result = await options.next();
          state = [null, result, true];
          return result;
        } catch (error) {
          state = [error, void 0, false];
          throw error;
        } finally {
          await callback(state, options, ...rest);
        }
      };
    }
    function intercept(interceptors, options, main) {
      const next = (options2, index) => {
        const interceptor = interceptors[index];
        if (!interceptor) {
          return main(options2);
        }
        return interceptor({
          ...options2,
          next: (newOptions = options2) => next(newOptions, index + 1),
        });
      };
      return next(options, 0);
    }
    function parseEmptyableJSON(text) {
      if (!text) {
        return void 0;
      }
      return JSON.parse(text);
    }
    function stringifyJSON(value) {
      return JSON.stringify(value);
    }
    function findDeepMatches(check, payload, segments = [], maps = [], values = []) {
      if (check(payload)) {
        maps.push(segments);
        values.push(payload);
      } else if (Array.isArray(payload)) {
        payload.forEach((v, i) => {
          findDeepMatches(check, v, [...segments, i], maps, values);
        });
      } else if (isObject(payload)) {
        for (const key in payload) {
          findDeepMatches(check, payload[key], [...segments, key], maps, values);
        }
      }
      return {
        maps,
        values,
      };
    }
    function getConstructor(value) {
      if (!isTypescriptObject(value)) {
        return null;
      }
      return Object.getPrototypeOf(value)?.constructor;
    }
    function isObject(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      const proto = Object.getPrototypeOf(value);
      return proto === Object.prototype || !proto || !proto.constructor;
    }
    function isTypescriptObject(value) {
      return !!value && (typeof value === "object" || typeof value === "function");
    }
    function clone(value) {
      if (Array.isArray(value)) {
        return value.map(clone);
      }
      if (isObject(value)) {
        const result = {};
        for (const key in value) {
          result[key] = clone(value[key]);
        }
        for (const sym of Object.getOwnPropertySymbols(value)) {
          result[sym] = clone(value[sym]);
        }
        return result;
      }
      return value;
    }
    function get(object, path) {
      let current = object;
      for (const key of path) {
        if (!isTypescriptObject(current)) {
          return void 0;
        }
        current = current[key];
      }
      return current;
    }
    function isPropertyKey(value) {
      const type = typeof value;
      return type === "string" || type === "number" || type === "symbol";
    }
    const NullProtoObj = /* @__PURE__ */ (() => {
      const e = function () {};
      e.prototype = /* @__PURE__ */ Object.create(null);
      Object.freeze(e.prototype);
      return e;
    })();
    function value(value2, ...args) {
      if (typeof value2 === "function") {
        return value2(...args);
      }
      return value2;
    }
    function fallback(value2, fallback2) {
      return value2 === void 0 ? fallback2 : value2;
    }
    function preventNativeAwait(target) {
      return new Proxy(target, {
        get(target2, prop, receiver) {
          const value2 = Reflect.get(target2, prop, receiver);
          if (prop !== "then" || typeof value2 !== "function") {
            return value2;
          }
          return new Proxy(value2, {
            apply(targetFn, thisArg, args) {
              if (args.length !== 2 || args.some((arg) => !isNativeFunction(arg))) {
                return Reflect.apply(targetFn, thisArg, args);
              }
              let shouldOmit = true;
              args[0].call(
                thisArg,
                preventNativeAwait(
                  new Proxy(target2, {
                    get: (target3, prop2, receiver2) => {
                      if (shouldOmit && prop2 === "then") {
                        shouldOmit = false;
                        return void 0;
                      }
                      return Reflect.get(target3, prop2, receiver2);
                    },
                  }),
                ),
              );
            },
          });
        },
      });
    }
    const NATIVE_FUNCTION_REGEX = /^\s*function\s*\(\)\s*\{\s*\[native code\]\s*\}\s*$/;
    function isNativeFunction(fn) {
      return typeof fn === "function" && NATIVE_FUNCTION_REGEX.test(fn.toString());
    }
    function overlayProxy(target, partial) {
      const proxy = new Proxy(typeof target === "function" ? partial : target, {
        get(_, prop) {
          const targetValue = prop in partial ? partial : value(target);
          const v = Reflect.get(targetValue, prop);
          return typeof v === "function" ? v.bind(targetValue) : v;
        },
        has(_, prop) {
          return Reflect.has(partial, prop) || Reflect.has(value(target), prop);
        },
      });
      return proxy;
    }
    function streamToAsyncIteratorClass(stream) {
      const reader = stream.getReader();
      return new AsyncIteratorClass(
        async () => {
          return reader.read();
        },
        async () => {
          await reader.cancel();
        },
      );
    }
    function asyncIteratorToStream(iterator) {
      return new ReadableStream({
        async pull(controller) {
          const { done, value } = await iterator.next();
          if (done) {
            controller.close();
          } else {
            controller.enqueue(value);
          }
        },
        async cancel() {
          await iterator.return?.();
        },
      });
    }
    function asyncIteratorToUnproxiedDataStream(iterator) {
      return new ReadableStream({
        async pull(controller) {
          const { done, value } = await iterator.next();
          if (done) {
            controller.close();
          } else {
            const unproxied = isObject(value)
              ? {
                  ...value,
                }
              : Array.isArray(value)
                ? value.map((i) => i)
                : value;
            controller.enqueue(unproxied);
          }
        },
        async cancel() {
          await iterator.return?.();
        },
      });
    }
    function tryDecodeURIComponent(value) {
      try {
        return decodeURIComponent(value);
      } catch {
        return value;
      }
    }
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "C",
      () => COMMON_ORPC_ERROR_DEFS,
      "O",
      () => ORPC_CLIENT_PACKAGE_NAME,
      "a",
      () => ORPC_CLIENT_PACKAGE_VERSION,
      "b",
      () => fallbackORPCErrorMessage,
      "c",
      () => ORPCError,
      "d",
      () => isORPCErrorStatus,
      "e",
      () => isORPCErrorJson,
      "f",
      () => fallbackORPCErrorStatus,
      "g",
      () => createORPCErrorFromJson,
      "i",
      () => isDefinedError,
      "t",
      () => toORPCError,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-client] (ecmascript) <locals>",
      );
    const ORPC_CLIENT_PACKAGE_NAME = "@orpc/client";
    const ORPC_CLIENT_PACKAGE_VERSION = "1.13.5";
    const COMMON_ORPC_ERROR_DEFS = {
      BAD_REQUEST: {
        status: 400,
        message: "Bad Request",
      },
      UNAUTHORIZED: {
        status: 401,
        message: "Unauthorized",
      },
      FORBIDDEN: {
        status: 403,
        message: "Forbidden",
      },
      NOT_FOUND: {
        status: 404,
        message: "Not Found",
      },
      METHOD_NOT_SUPPORTED: {
        status: 405,
        message: "Method Not Supported",
      },
      NOT_ACCEPTABLE: {
        status: 406,
        message: "Not Acceptable",
      },
      TIMEOUT: {
        status: 408,
        message: "Request Timeout",
      },
      CONFLICT: {
        status: 409,
        message: "Conflict",
      },
      PRECONDITION_FAILED: {
        status: 412,
        message: "Precondition Failed",
      },
      PAYLOAD_TOO_LARGE: {
        status: 413,
        message: "Payload Too Large",
      },
      UNSUPPORTED_MEDIA_TYPE: {
        status: 415,
        message: "Unsupported Media Type",
      },
      UNPROCESSABLE_CONTENT: {
        status: 422,
        message: "Unprocessable Content",
      },
      TOO_MANY_REQUESTS: {
        status: 429,
        message: "Too Many Requests",
      },
      CLIENT_CLOSED_REQUEST: {
        status: 499,
        message: "Client Closed Request",
      },
      INTERNAL_SERVER_ERROR: {
        status: 500,
        message: "Internal Server Error",
      },
      NOT_IMPLEMENTED: {
        status: 501,
        message: "Not Implemented",
      },
      BAD_GATEWAY: {
        status: 502,
        message: "Bad Gateway",
      },
      SERVICE_UNAVAILABLE: {
        status: 503,
        message: "Service Unavailable",
      },
      GATEWAY_TIMEOUT: {
        status: 504,
        message: "Gateway Timeout",
      },
    };
    function fallbackORPCErrorStatus(code, status) {
      return status ?? COMMON_ORPC_ERROR_DEFS[code]?.status ?? 500;
    }
    function fallbackORPCErrorMessage(code, message) {
      return message || COMMON_ORPC_ERROR_DEFS[code]?.message || code;
    }
    const GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL = Symbol.for(
      `__${ORPC_CLIENT_PACKAGE_NAME}@${ORPC_CLIENT_PACKAGE_VERSION}/error/ORPC_ERROR_CONSTRUCTORS__`,
    );
    void (globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL] ??= /* @__PURE__ */ new WeakSet());
    const globalORPCErrorConstructors = globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL];
    class ORPCError extends Error {
      defined;
      code;
      status;
      data;
      constructor(code, ...rest) {
        const options = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "resolveMaybeOptionalOptions"
        ])(rest);
        if (options.status !== void 0 && !isORPCErrorStatus(options.status)) {
          throw new Error("[ORPCError] Invalid error status code.");
        }
        const message = fallbackORPCErrorMessage(code, options.message);
        super(message, options);
        this.code = code;
        this.status = fallbackORPCErrorStatus(code, options.status);
        this.defined = options.defined ?? false;
        this.data = options.data;
      }
      toJSON() {
        return {
          defined: this.defined,
          code: this.code,
          status: this.status,
          message: this.message,
          data: this.data,
        };
      }
      /**
       * Workaround for Next.js where different contexts use separate
       * dependency graphs, causing multiple ORPCError constructors existing and breaking
       * `instanceof` checks across contexts.
       *
       * This is particularly problematic with "Optimized SSR", where orpc-client
       * executes in one context but is invoked from another. When an error is thrown
       * in the execution context, `instanceof ORPCError` checks fail in the
       * invocation context due to separate class constructors.
       *
       * @todo Remove this and related code if Next.js resolves the multiple dependency graph issue.
       */ static [Symbol.hasInstance](instance) {
        if (globalORPCErrorConstructors.has(this)) {
          const constructor = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "getConstructor"
          ])(instance);
          if (constructor && globalORPCErrorConstructors.has(constructor)) {
            return true;
          }
        }
        return super[Symbol.hasInstance](instance);
      }
    }
    globalORPCErrorConstructors.add(ORPCError);
    function isDefinedError(error) {
      return error instanceof ORPCError && error.defined;
    }
    function toORPCError(error) {
      return error instanceof ORPCError
        ? error
        : new ORPCError("INTERNAL_SERVER_ERROR", {
            message: "Internal server error",
            cause: error,
          });
    }
    function isORPCErrorStatus(status) {
      return status < 200 || status >= 400;
    }
    function isORPCErrorJson(json) {
      if (
        !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "isObject"
        ])(json)
      ) {
        return false;
      }
      const validKeys = ["defined", "code", "status", "message", "data"];
      if (Object.keys(json).some((k) => !validKeys.includes(k))) {
        return false;
      }
      return (
        "defined" in json &&
        typeof json.defined === "boolean" &&
        "code" in json &&
        typeof json.code === "string" &&
        "status" in json &&
        typeof json.status === "number" &&
        isORPCErrorStatus(json.status) &&
        "message" in json &&
        typeof json.message === "string"
      );
    }
    function createORPCErrorFromJson(json, options = {}) {
      return new ORPCError(json.code, {
        ...options,
        ...json,
      });
    }
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["m", () => mapEventIterator]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-client] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-client] (ecmascript)",
      );
    function mapEventIterator(iterator, maps) {
      const mapError = async (error) => {
        let mappedError = await maps.error(error);
        if (mappedError !== error) {
          const meta = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "getEventMeta"
          ])(error);
          if (
            meta &&
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "isTypescriptObject"
            ])(mappedError)
          ) {
            mappedError = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "withEventMeta"
            ])(mappedError, meta);
          }
        }
        return mappedError;
      };
      return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "AsyncIteratorClass"
      ](
        async () => {
          const { done, value } = await (async () => {
            try {
              return await iterator.next();
            } catch (error) {
              throw await mapError(error);
            }
          })();
          let mappedValue = await maps.value(value, done);
          if (mappedValue !== value) {
            const meta = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getEventMeta"
            ])(value);
            if (
              meta &&
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "isTypescriptObject"
              ])(mappedValue)
            ) {
              mappedValue = (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "withEventMeta"
              ])(mappedValue, meta);
            }
          }
          return {
            done,
            value: mappedValue,
          };
        },
        async () => {
          try {
            await iterator.return?.();
          } catch (error) {
            throw await mapError(error);
          }
        },
      );
    }
  },
  "[project]/node_modules/@orpc/client/dist/index.mjs [app-client] (ecmascript) <locals>",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "DynamicLink",
      () => DynamicLink,
      "consumeEventIterator",
      () => consumeEventIterator,
      "createORPCClient",
      () => createORPCClient,
      "createSafeClient",
      () => createSafeClient,
      "resolveFriendlyClientOptions",
      () => resolveFriendlyClientOptions,
      "safe",
      () => safe,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-client] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-client] (ecmascript)",
      );
    async function safe(promise) {
      try {
        const output = await promise;
        return Object.assign([null, output, false, true], {
          error: null,
          data: output,
          isDefined: false,
          isSuccess: true,
        });
      } catch (e) {
        const error = e;
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "i"
          ])(error)
        ) {
          return Object.assign([error, void 0, true, false], {
            error,
            data: void 0,
            isDefined: true,
            isSuccess: false,
          });
        }
        return Object.assign([error, void 0, false, false], {
          error,
          data: void 0,
          isDefined: false,
          isSuccess: false,
        });
      }
    }
    function resolveFriendlyClientOptions(options) {
      return {
        ...options,
        context: options.context ?? {},
      };
    }
    function consumeEventIterator(iterator, options) {
      void (async () => {
        let onFinishState;
        try {
          const resolvedIterator = await iterator;
          while (true) {
            const { done, value } = await resolvedIterator.next();
            if (done) {
              const realValue = value;
              onFinishState = [null, realValue, true];
              options.onSuccess?.(realValue);
              break;
            }
            options.onEvent(value);
          }
        } catch (error) {
          onFinishState = [error, void 0, false];
          if (!options.onError && !options.onFinish) {
            throw error;
          }
          options.onError?.(error);
        } finally {
          options.onFinish?.(onFinishState);
        }
      })();
      return async () => {
        await (await iterator)?.return?.();
      };
    }
    function createORPCClient(link, options = {}) {
      const path = options.path ?? [];
      const procedureClient = async (...[input, options2 = {}]) => {
        return await link.call(path, input, resolveFriendlyClientOptions(options2));
      };
      const recursive = new Proxy(procedureClient, {
        get(target, key) {
          if (typeof key !== "string") {
            return Reflect.get(target, key);
          }
          return createORPCClient(link, {
            ...options,
            path: [...path, key],
          });
        },
      });
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "preventNativeAwait"
      ])(recursive);
    }
    function createSafeClient(client) {
      const proxy = new Proxy((...args) => safe(client(...args)), {
        get(_, prop, receiver) {
          const value = Reflect.get(client, prop, receiver);
          if (typeof prop !== "string") {
            return value;
          }
          if (
            !(0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "isTypescriptObject"
            ])(value)
          ) {
            return value;
          }
          return createSafeClient(value);
        },
      });
      return proxy;
    }
    class DynamicLink {
      constructor(linkResolver) {
        this.linkResolver = linkResolver;
      }
      async call(path, input, options) {
        const resolvedLink = await this.linkResolver(options, path, input);
        const output = await resolvedLink.call(path, input, options);
        return output;
      }
    }
  },
  "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "C",
      () => CompositeStandardLinkPlugin,
      "S",
      () => StandardLink,
      "a",
      () => STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES,
      "b",
      () => StandardRPCJsonSerializer,
      "c",
      () => StandardRPCLink,
      "d",
      () => StandardRPCLinkCodec,
      "e",
      () => StandardRPCSerializer,
      "f",
      () => toStandardHeaders,
      "g",
      () => getMalformedResponseErrorCode,
      "t",
      () => toHttpPath,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-client] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2d$fetch$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server-fetch/dist/index.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs [app-client] (ecmascript)",
      );
    class CompositeStandardLinkPlugin {
      plugins;
      constructor(plugins = []) {
        this.plugins = [...plugins].sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
      }
      init(options) {
        for (const plugin of this.plugins) {
          plugin.init?.(options);
        }
      }
    }
    class StandardLink {
      constructor(codec, sender, options = {}) {
        this.codec = codec;
        this.sender = sender;
        const plugin = new CompositeStandardLinkPlugin(options.plugins);
        plugin.init(options);
        this.interceptors = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "toArray"
        ])(options.interceptors);
        this.clientInterceptors = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "toArray"
        ])(options.clientInterceptors);
      }
      interceptors;
      clientInterceptors;
      call(path, input, options) {
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "runWithSpan"
        ])(
          {
            name: `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ORPC_NAME"]}.${path.join("/")}`,
            signal: options.signal,
          },
          (span) => {
            span?.setAttribute(
              "rpc.system",
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "ORPC_NAME"
              ],
            );
            span?.setAttribute("rpc.method", path.join("."));
            if (
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "isAsyncIteratorObject"
              ])(input)
            ) {
              input = (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "asyncIteratorWithSpan"
              ])(
                {
                  name: "consume_event_iterator_input",
                  signal: options.signal,
                },
                input,
              );
            }
            return (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "intercept"
            ])(
              this.interceptors,
              {
                ...options,
                path,
                input,
              },
              async ({ path: path2, input: input2, ...options2 }) => {
                const otelConfig = (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "getGlobalOtelConfig"
                ])();
                let otelContext;
                const currentSpan = otelConfig?.trace.getActiveSpan() ?? span;
                if (currentSpan && otelConfig) {
                  otelContext = otelConfig?.trace.setSpan(otelConfig.context.active(), currentSpan);
                }
                const request = await (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "runWithSpan"
                ])(
                  {
                    name: "encode_request",
                    context: otelContext,
                  },
                  () => this.codec.encode(path2, input2, options2),
                );
                const response = await (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "intercept"
                ])(
                  this.clientInterceptors,
                  {
                    ...options2,
                    input: input2,
                    path: path2,
                    request,
                  },
                  ({ input: input3, path: path3, request: request2, ...options3 }) => {
                    return (0,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                      "runWithSpan"
                    ])(
                      {
                        name: "send_request",
                        signal: options3.signal,
                        context: otelContext,
                      },
                      () => this.sender.call(request2, options3, path3, input3),
                    );
                  },
                );
                const output = await (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "runWithSpan"
                ])(
                  {
                    name: "decode_response",
                    context: otelContext,
                  },
                  () => this.codec.decode(response, options2, path2, input2),
                );
                if (
                  (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "isAsyncIteratorObject"
                  ])(output)
                ) {
                  return (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "asyncIteratorWithSpan"
                  ])(
                    {
                      name: "consume_event_iterator_output",
                      signal: options2.signal,
                    },
                    output,
                  );
                }
                return output;
              },
            );
          },
        );
      }
    }
    const STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES = {
      BIGINT: 0,
      DATE: 1,
      NAN: 2,
      UNDEFINED: 3,
      URL: 4,
      REGEXP: 5,
      SET: 6,
      MAP: 7,
    };
    class StandardRPCJsonSerializer {
      customSerializers;
      constructor(options = {}) {
        this.customSerializers = options.customJsonSerializers ?? [];
        if (
          this.customSerializers.length !==
          new Set(this.customSerializers.map((custom) => custom.type)).size
        ) {
          throw new Error("Custom serializer type must be unique.");
        }
      }
      serialize(data, segments = [], meta = [], maps = [], blobs = []) {
        for (const custom of this.customSerializers) {
          if (custom.condition(data)) {
            const result = this.serialize(custom.serialize(data), segments, meta, maps, blobs);
            meta.push([custom.type, ...segments]);
            return result;
          }
        }
        if (data instanceof Blob) {
          maps.push(segments);
          blobs.push(data);
          return [data, meta, maps, blobs];
        }
        if (typeof data === "bigint") {
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.BIGINT, ...segments]);
          return [data.toString(), meta, maps, blobs];
        }
        if (data instanceof Date) {
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.DATE, ...segments]);
          if (Number.isNaN(data.getTime())) {
            return [null, meta, maps, blobs];
          }
          return [data.toISOString(), meta, maps, blobs];
        }
        if (Number.isNaN(data)) {
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.NAN, ...segments]);
          return [null, meta, maps, blobs];
        }
        if (data instanceof URL) {
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.URL, ...segments]);
          return [data.toString(), meta, maps, blobs];
        }
        if (data instanceof RegExp) {
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.REGEXP, ...segments]);
          return [data.toString(), meta, maps, blobs];
        }
        if (data instanceof Set) {
          const result = this.serialize(Array.from(data), segments, meta, maps, blobs);
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.SET, ...segments]);
          return result;
        }
        if (data instanceof Map) {
          const result = this.serialize(Array.from(data.entries()), segments, meta, maps, blobs);
          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.MAP, ...segments]);
          return result;
        }
        if (Array.isArray(data)) {
          const json = data.map((v, i) => {
            if (v === void 0) {
              meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.UNDEFINED, ...segments, i]);
              return v;
            }
            return this.serialize(v, [...segments, i], meta, maps, blobs)[0];
          });
          return [json, meta, maps, blobs];
        }
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "isObject"
          ])(data)
        ) {
          const json = {};
          for (const k in data) {
            if (k === "toJSON" && typeof data[k] === "function") {
              continue;
            }
            json[k] = this.serialize(data[k], [...segments, k], meta, maps, blobs)[0];
          }
          return [json, meta, maps, blobs];
        }
        return [data, meta, maps, blobs];
      }
      deserialize(json, meta, maps, getBlob) {
        const ref = {
          data: json,
        };
        if (maps && getBlob) {
          maps.forEach((segments, i) => {
            let currentRef = ref;
            let preSegment = "data";
            segments.forEach((segment) => {
              currentRef = currentRef[preSegment];
              preSegment = segment;
            });
            currentRef[preSegment] = getBlob(i);
          });
        }
        for (const item of meta) {
          const type = item[0];
          let currentRef = ref;
          let preSegment = "data";
          for (let i = 1; i < item.length; i++) {
            currentRef = currentRef[preSegment];
            preSegment = item[i];
          }
          for (const custom of this.customSerializers) {
            if (custom.type === type) {
              currentRef[preSegment] = custom.deserialize(currentRef[preSegment]);
              break;
            }
          }
          switch (type) {
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.BIGINT:
              currentRef[preSegment] = BigInt(currentRef[preSegment]);
              break;
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.DATE:
              currentRef[preSegment] = new Date(currentRef[preSegment] ?? "Invalid Date");
              break;
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.NAN:
              currentRef[preSegment] = Number.NaN;
              break;
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.UNDEFINED:
              currentRef[preSegment] = void 0;
              break;
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.URL:
              currentRef[preSegment] = new URL(currentRef[preSegment]);
              break;
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.REGEXP: {
              const [, pattern, flags] = currentRef[preSegment].match(/^\/(.*)\/([a-z]*)$/);
              currentRef[preSegment] = new RegExp(pattern, flags);
              break;
            }
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.SET:
              currentRef[preSegment] = new Set(currentRef[preSegment]);
              break;
            case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.MAP:
              currentRef[preSegment] = new Map(currentRef[preSegment]);
              break;
          }
        }
        return ref.data;
      }
    }
    function toHttpPath(path) {
      return `/${path.map(encodeURIComponent).join("/")}`;
    }
    function toStandardHeaders(headers) {
      if (typeof headers.forEach === "function") {
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2d$fetch$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "toStandardHeaders"
        ])(headers);
      }
      return headers;
    }
    function getMalformedResponseErrorCode(status) {
      return (
        Object.entries(
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "C"
          ],
        ).find(([, def]) => def.status === status)?.[0] ?? "MALFORMED_ORPC_ERROR_RESPONSE"
      );
    }
    class StandardRPCLinkCodec {
      constructor(serializer, options) {
        this.serializer = serializer;
        this.baseUrl = options.url;
        this.maxUrlLength = options.maxUrlLength ?? 2083;
        this.fallbackMethod = options.fallbackMethod ?? "POST";
        this.expectedMethod = options.method ?? this.fallbackMethod;
        this.headers = options.headers ?? {};
      }
      baseUrl;
      maxUrlLength;
      fallbackMethod;
      expectedMethod;
      headers;
      async encode(path, input, options) {
        let headers = toStandardHeaders(
          await (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "value"
          ])(this.headers, options, path, input),
        );
        if (options.lastEventId !== void 0) {
          headers = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "mergeStandardHeaders"
          ])(headers, {
            "last-event-id": options.lastEventId,
          });
        }
        const expectedMethod = await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "value"
        ])(this.expectedMethod, options, path, input);
        const baseUrl = await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "value"
        ])(this.baseUrl, options, path, input);
        const url = new URL(baseUrl);
        url.pathname = `${url.pathname.replace(/\/$/, "")}${toHttpPath(path)}`;
        const serialized = this.serializer.serialize(input);
        if (
          expectedMethod === "GET" &&
          !(serialized instanceof FormData) &&
          !(0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "isAsyncIteratorObject"
          ])(serialized)
        ) {
          const maxUrlLength = await (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "value"
          ])(this.maxUrlLength, options, path, input);
          const getUrl = new URL(url);
          getUrl.searchParams.append(
            "data",
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "stringifyJSON"
            ])(serialized),
          );
          if (getUrl.toString().length <= maxUrlLength) {
            return {
              body: void 0,
              method: expectedMethod,
              headers,
              url: getUrl,
              signal: options.signal,
            };
          }
        }
        return {
          url,
          method: expectedMethod === "GET" ? this.fallbackMethod : expectedMethod,
          headers,
          body: serialized,
          signal: options.signal,
        };
      }
      async decode(response) {
        const isOk = !(0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "d"
        ])(response.status);
        const deserialized = await (async () => {
          let isBodyOk = false;
          try {
            const body = await response.body();
            isBodyOk = true;
            return this.serializer.deserialize(body);
          } catch (error) {
            if (!isBodyOk) {
              throw new Error(
                "Cannot parse response body, please check the response body and content-type.",
                {
                  cause: error,
                },
              );
            }
            throw new Error("Invalid RPC response format.", {
              cause: error,
            });
          }
        })();
        if (!isOk) {
          if (
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "e"
            ])(deserialized)
          ) {
            throw (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "g"
            ])(deserialized);
          }
          throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "c"
          ](getMalformedResponseErrorCode(response.status), {
            status: response.status,
            data: {
              ...response,
              body: deserialized,
            },
          });
        }
        return deserialized;
      }
    }
    class StandardRPCSerializer {
      constructor(jsonSerializer) {
        this.jsonSerializer = jsonSerializer;
      }
      serialize(data) {
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "isAsyncIteratorObject"
          ])(data)
        ) {
          return (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "m"
          ])(data, {
            value: async (value) => this.#serialize(value, false),
            error: async (e) => {
              return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "ErrorEvent"
              ]({
                data: this.#serialize(
                  (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "t"
                  ])(e).toJSON(),
                  false,
                ),
                cause: e,
              });
            },
          });
        }
        return this.#serialize(data, true);
      }
      #serialize(data, enableFormData) {
        const [json, meta_, maps, blobs] = this.jsonSerializer.serialize(data);
        const meta = meta_.length === 0 ? void 0 : meta_;
        if (!enableFormData || blobs.length === 0) {
          return {
            json,
            meta,
          };
        }
        const form = new FormData();
        form.set(
          "data",
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "stringifyJSON"
          ])({
            json,
            meta,
            maps,
          }),
        );
        blobs.forEach((blob, i) => {
          form.set(i.toString(), blob);
        });
        return form;
      }
      deserialize(data) {
        if (
          (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "isAsyncIteratorObject"
          ])(data)
        ) {
          return (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "m"
          ])(data, {
            value: async (value) => this.#deserialize(value),
            error: async (e) => {
              if (
                !(
                  e instanceof
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "ErrorEvent"
                  ]
                )
              ) {
                return e;
              }
              const deserialized = this.#deserialize(e.data);
              if (
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "e"
                ])(deserialized)
              ) {
                return (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "g"
                ])(deserialized, {
                  cause: e,
                });
              }
              return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "ErrorEvent"
              ]({
                data: deserialized,
                cause: e,
              });
            },
          });
        }
        return this.#deserialize(data);
      }
      #deserialize(data) {
        if (data === void 0) {
          return void 0;
        }
        if (!(data instanceof FormData)) {
          return this.jsonSerializer.deserialize(data.json, data.meta ?? []);
        }
        const serialized = JSON.parse(data.get("data"));
        return this.jsonSerializer.deserialize(
          serialized.json,
          serialized.meta ?? [],
          serialized.maps,
          (i) => data.get(i.toString()),
        );
      }
    }
    class StandardRPCLink extends StandardLink {
      constructor(linkClient, options) {
        const jsonSerializer = new StandardRPCJsonSerializer(options);
        const serializer = new StandardRPCSerializer(jsonSerializer);
        const linkCodec = new StandardRPCLinkCodec(serializer, options);
        super(linkCodec, linkClient, options);
      }
    }
  },
  "[project]/node_modules/@orpc/client/dist/adapters/fetch/index.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["LinkFetchClient", () => LinkFetchClient, "RPCLink", () => RPCLink]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-client] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2d$fetch$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server-fetch/dist/index.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BcDRUyT-.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BF1R3smX$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BF1R3smX.mjs [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BLtwTQUg$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/client/dist/shared/client.BLtwTQUg.mjs [app-client] (ecmascript)",
      );
    class CompositeLinkFetchPlugin
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "C"
      ]
    {
      initRuntimeAdapter(options) {
        for (const plugin of this.plugins) {
          plugin.initRuntimeAdapter?.(options);
        }
      }
    }
    class LinkFetchClient {
      fetch;
      toFetchRequestOptions;
      adapterInterceptors;
      constructor(options) {
        const plugin = new CompositeLinkFetchPlugin(options.plugins);
        plugin.initRuntimeAdapter(options);
        this.fetch = options.fetch ?? globalThis.fetch.bind(globalThis);
        this.toFetchRequestOptions = options;
        this.adapterInterceptors = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "toArray"
        ])(options.adapterInterceptors);
      }
      async call(standardRequest, options, path, input) {
        const request = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2d$fetch$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "toFetchRequest"
        ])(standardRequest, this.toFetchRequestOptions);
        const fetchResponse = await (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "intercept"
        ])(
          this.adapterInterceptors,
          {
            ...options,
            request,
            path,
            input,
            init: {
              redirect: "manual",
            },
          },
          ({ request: request2, path: path2, input: input2, init, ...options2 }) =>
            this.fetch(request2, init, options2, path2, input2),
        );
        const lazyResponse = (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2d$fetch$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "toStandardLazyResponse"
        ])(fetchResponse, {
          signal: request.signal,
        });
        return lazyResponse;
      }
    }
    class RPCLink
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$client$2f$dist$2f$shared$2f$client$2e$BcDRUyT$2d2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "c"
      ]
    {
      constructor(options) {
        const linkClient = new LinkFetchClient(options);
        super(linkClient, options);
      }
    }
  },
  "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "ErrorEvent",
      () => ErrorEvent,
      "EventDecoder",
      () => EventDecoder,
      "EventDecoderError",
      () => EventDecoderError,
      "EventDecoderStream",
      () => EventDecoderStream,
      "EventEncoderError",
      () => EventEncoderError,
      "HibernationEventIterator",
      () => HibernationEventIterator,
      "assertEventComment",
      () => assertEventComment,
      "assertEventId",
      () => assertEventId,
      "assertEventName",
      () => assertEventName,
      "assertEventRetry",
      () => assertEventRetry,
      "decodeEventMessage",
      () => decodeEventMessage,
      "encodeEventComments",
      () => encodeEventComments,
      "encodeEventData",
      () => encodeEventData,
      "encodeEventMessage",
      () => encodeEventMessage,
      "flattenHeader",
      () => flattenHeader,
      "generateContentDisposition",
      () => generateContentDisposition,
      "getEventMeta",
      () => getEventMeta,
      "getFilenameFromContentDisposition",
      () => getFilenameFromContentDisposition,
      "isEventIteratorHeaders",
      () => isEventIteratorHeaders,
      "mergeStandardHeaders",
      () => mergeStandardHeaders,
      "replicateStandardLazyResponse",
      () => replicateStandardLazyResponse,
      "withEventMeta",
      () => withEventMeta,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-client] (ecmascript) <locals>",
      );
    class EventEncoderError extends TypeError {}
    class EventDecoderError extends TypeError {}
    class ErrorEvent extends Error {
      data;
      constructor(options) {
        super(options?.message ?? "An error event was received", options);
        this.data = options?.data;
      }
    }
    function decodeEventMessage(encoded) {
      const lines = encoded.replace(/\n+$/, "").split(/\n/);
      const message = {
        data: void 0,
        event: void 0,
        id: void 0,
        retry: void 0,
        comments: [],
      };
      for (const line of lines) {
        const index = line.indexOf(":");
        const key = index === -1 ? line : line.slice(0, index);
        const value = index === -1 ? "" : line.slice(index + 1).replace(/^\s/, "");
        if (index === 0) {
          message.comments.push(value);
        } else if (key === "data") {
          message.data ??= "";
          message.data += `${value}
`;
        } else if (key === "event") {
          message.event = value;
        } else if (key === "id") {
          message.id = value;
        } else if (key === "retry") {
          const maybeInteger = Number.parseInt(value);
          if (
            Number.isInteger(maybeInteger) &&
            maybeInteger >= 0 &&
            maybeInteger.toString() === value
          ) {
            message.retry = maybeInteger;
          }
        }
      }
      message.data = message.data?.replace(/\n$/, "");
      return message;
    }
    class EventDecoder {
      constructor(options = {}) {
        this.options = options;
      }
      incomplete = "";
      feed(chunk) {
        this.incomplete += chunk;
        const lastCompleteIndex = this.incomplete.lastIndexOf("\n\n");
        if (lastCompleteIndex === -1) {
          return;
        }
        const completes = this.incomplete.slice(0, lastCompleteIndex).split(/\n\n/);
        this.incomplete = this.incomplete.slice(lastCompleteIndex + 2);
        for (const encoded of completes) {
          const message = decodeEventMessage(`${encoded}

`);
          if (this.options.onEvent) {
            this.options.onEvent(message);
          }
        }
      }
      end() {
        if (this.incomplete) {
          throw new EventDecoderError("Event Iterator ended before complete");
        }
      }
    }
    class EventDecoderStream extends TransformStream {
      constructor() {
        let decoder;
        super({
          start(controller) {
            decoder = new EventDecoder({
              onEvent: (event) => {
                controller.enqueue(event);
              },
            });
          },
          transform(chunk) {
            decoder.feed(chunk);
          },
          flush() {
            decoder.end();
          },
        });
      }
    }
    function assertEventId(id) {
      if (id.includes("\n")) {
        throw new EventEncoderError("Event's id must not contain a newline character");
      }
    }
    function assertEventName(event) {
      if (event.includes("\n")) {
        throw new EventEncoderError("Event's event must not contain a newline character");
      }
    }
    function assertEventRetry(retry) {
      if (!Number.isInteger(retry) || retry < 0) {
        throw new EventEncoderError("Event's retry must be a integer and >= 0");
      }
    }
    function assertEventComment(comment) {
      if (comment.includes("\n")) {
        throw new EventEncoderError("Event's comment must not contain a newline character");
      }
    }
    function encodeEventData(data) {
      const lines = data?.split(/\n/) ?? [];
      let output = "";
      for (const line of lines) {
        output += `data: ${line}
`;
      }
      return output;
    }
    function encodeEventComments(comments) {
      let output = "";
      for (const comment of comments ?? []) {
        assertEventComment(comment);
        output += `: ${comment}
`;
      }
      return output;
    }
    function encodeEventMessage(message) {
      let output = "";
      output += encodeEventComments(message.comments);
      if (message.event !== void 0) {
        assertEventName(message.event);
        output += `event: ${message.event}
`;
      }
      if (message.retry !== void 0) {
        assertEventRetry(message.retry);
        output += `retry: ${message.retry}
`;
      }
      if (message.id !== void 0) {
        assertEventId(message.id);
        output += `id: ${message.id}
`;
      }
      output += encodeEventData(message.data);
      output += "\n";
      return output;
    }
    const EVENT_SOURCE_META_SYMBOL = Symbol("ORPC_EVENT_SOURCE_META");
    function withEventMeta(container, meta) {
      if (meta.id === void 0 && meta.retry === void 0 && !meta.comments?.length) {
        return container;
      }
      if (meta.id !== void 0) {
        assertEventId(meta.id);
      }
      if (meta.retry !== void 0) {
        assertEventRetry(meta.retry);
      }
      if (meta.comments !== void 0) {
        for (const comment of meta.comments) {
          assertEventComment(comment);
        }
      }
      return new Proxy(container, {
        get(target, prop, receiver) {
          if (prop === EVENT_SOURCE_META_SYMBOL) {
            return meta;
          }
          return Reflect.get(target, prop, receiver);
        },
      });
    }
    function getEventMeta(container) {
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "isTypescriptObject"
      ])(container)
        ? Reflect.get(container, EVENT_SOURCE_META_SYMBOL)
        : void 0;
    }
    class HibernationEventIterator
      extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "AsyncIteratorClass"
      ]
    {
      /**
       * this property is not transferred to the client, so it should be optional for type safety
       */ hibernationCallback;
      constructor(hibernationCallback) {
        super(
          async () => {
            throw new Error("Cannot iterate over hibernating iterator directly");
          },
          async (reason) => {
            if (reason !== "next") {
              throw new Error("Cannot cleanup hibernating iterator directly");
            }
          },
        );
        this.hibernationCallback = hibernationCallback;
      }
    }
    function generateContentDisposition(filename) {
      const escapedFileName = filename.replace(/"/g, '\\"');
      const encodedFilenameStar = encodeURIComponent(filename)
        .replace(/['()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`)
        .replace(/%(7C|60|5E)/g, (str, hex) => String.fromCharCode(Number.parseInt(hex, 16)));
      return `inline; filename="${escapedFileName}"; filename*=utf-8''${encodedFilenameStar}`;
    }
    function getFilenameFromContentDisposition(contentDisposition) {
      const encodedFilenameStarMatch = contentDisposition.match(/filename\*=(UTF-8'')?([^;]*)/i);
      if (encodedFilenameStarMatch && typeof encodedFilenameStarMatch[2] === "string") {
        return (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "tryDecodeURIComponent"
        ])(encodedFilenameStarMatch[2]);
      }
      const encodedFilenameMatch = contentDisposition.match(/filename="((?:\\"|[^"])*)"/i);
      if (encodedFilenameMatch && typeof encodedFilenameMatch[1] === "string") {
        return encodedFilenameMatch[1].replace(/\\"/g, '"');
      }
    }
    function mergeStandardHeaders(a, b) {
      const merged = {
        ...a,
      };
      for (const key in b) {
        if (Array.isArray(b[key])) {
          merged[key] = [
            ...(0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "toArray"
            ])(merged[key]),
            ...b[key],
          ];
        } else if (b[key] !== void 0) {
          if (Array.isArray(merged[key])) {
            merged[key] = [...merged[key], b[key]];
          } else if (merged[key] !== void 0) {
            merged[key] = [merged[key], b[key]];
          } else {
            merged[key] = b[key];
          }
        }
      }
      return merged;
    }
    function flattenHeader(header) {
      if (typeof header === "string" || header === void 0) {
        return header;
      }
      if (header.length === 0) {
        return void 0;
      }
      return header.join(", ");
    }
    function replicateStandardLazyResponse(response, count) {
      const replicated = [];
      let bodyPromise;
      let replicatedAsyncIteratorObjects;
      for (let i = 0; i < count; i++) {
        replicated.push({
          ...response,
          body: (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "once"
          ])(async () => {
            const body = await (bodyPromise ??= response.body());
            if (
              !(0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "isAsyncIteratorObject"
              ])(body)
            ) {
              return body;
            }
            replicatedAsyncIteratorObjects ??= (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "replicateAsyncIterator"
            ])(body, count);
            return replicatedAsyncIteratorObjects.shift();
          }),
        });
      }
      return replicated;
    }
    function isEventIteratorHeaders(headers) {
      return Boolean(
        flattenHeader(headers["content-type"])?.startsWith("text/event-stream") &&
        flattenHeader(headers["content-disposition"]) === void 0,
      );
    }
  },
  "[project]/node_modules/@orpc/standard-server-fetch/dist/index.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "toEventIterator",
      () => toEventIterator,
      "toEventStream",
      () => toEventStream,
      "toFetchBody",
      () => toFetchBody,
      "toFetchHeaders",
      () => toFetchHeaders,
      "toFetchRequest",
      () => toFetchRequest,
      "toFetchResponse",
      () => toFetchResponse,
      "toStandardBody",
      () => toStandardBody,
      "toStandardHeaders",
      () => toStandardHeaders,
      "toStandardLazyRequest",
      () => toStandardLazyRequest,
      "toStandardLazyResponse",
      () => toStandardLazyResponse,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-client] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/standard-server/dist/index.mjs [app-client] (ecmascript)",
      );
    function toEventIterator(stream, options = {}) {
      const eventStream = stream
        ?.pipeThrough(new TextDecoderStream())
        .pipeThrough(
          new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "EventDecoderStream"
          ](),
        );
      const reader = eventStream?.getReader();
      let span;
      let isCancelled = false;
      return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "AsyncIteratorClass"
      ](
        async () => {
          span ??= (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "startSpan"
          ])("consume_event_iterator_stream");
          try {
            while (true) {
              if (reader === void 0) {
                return {
                  done: true,
                  value: void 0,
                };
              }
              const { done, value: value1 } = await (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "runInSpanContext"
              ])(span, () => reader.read());
              if (done) {
                if (isCancelled) {
                  throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "AbortError"
                  ]("Stream was cancelled");
                }
                return {
                  done: true,
                  value: void 0,
                };
              }
              switch (value1.event) {
                case "message": {
                  let message = (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "parseEmptyableJSON"
                  ])(value1.data);
                  if (
                    (0,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                      "isTypescriptObject"
                    ])(message)
                  ) {
                    message = (0,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                      "withEventMeta"
                    ])(message, value1);
                  }
                  span?.addEvent("message");
                  return {
                    done: false,
                    value: message,
                  };
                }
                case "error": {
                  let error =
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                      "ErrorEvent"
                    ]({
                      data: (0,
                      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                        "parseEmptyableJSON"
                      ])(value1.data),
                    });
                  error = (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "withEventMeta"
                  ])(error, value1);
                  span?.addEvent("error");
                  throw error;
                }
                case "done": {
                  let done2 = (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "parseEmptyableJSON"
                  ])(value1.data);
                  if (
                    (0,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                      "isTypescriptObject"
                    ])(done2)
                  ) {
                    done2 = (0,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                      "withEventMeta"
                    ])(done2, value1);
                  }
                  span?.addEvent("done");
                  return {
                    done: true,
                    value: done2,
                  };
                }
                default: {
                  span?.addEvent("maybe_keepalive");
                }
              }
            }
          } catch (e) {
            if (
              !(
                e instanceof
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "ErrorEvent"
                ]
              )
            ) {
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "setSpanError"
              ])(span, e, options);
            }
            throw e;
          }
        },
        async (reason) => {
          try {
            if (reason !== "next") {
              isCancelled = true;
              span?.addEvent("cancelled");
            }
            await (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "runInSpanContext"
            ])(span, () => reader?.cancel());
          } catch (e) {
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "setSpanError"
            ])(span, e, options);
            throw e;
          } finally {
            span?.end();
          }
        },
      );
    }
    function toEventStream(iterator, options = {}) {
      const keepAliveEnabled = options.eventIteratorKeepAliveEnabled ?? true;
      const keepAliveInterval = options.eventIteratorKeepAliveInterval ?? 5e3;
      const keepAliveComment = options.eventIteratorKeepAliveComment ?? "";
      const initialCommentEnabled = options.eventIteratorInitialCommentEnabled ?? true;
      const initialComment = options.eventIteratorInitialComment ?? "";
      let cancelled = false;
      let timeout;
      let span;
      const stream = new ReadableStream({
        start(controller) {
          span = (0,
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
            "startSpan"
          ])("stream_event_iterator");
          if (initialCommentEnabled) {
            controller.enqueue(
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "encodeEventMessage"
              ])({
                comments: [initialComment],
              }),
            );
          }
        },
        async pull(controller) {
          try {
            if (keepAliveEnabled) {
              timeout = setInterval(() => {
                controller.enqueue(
                  (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "encodeEventMessage"
                  ])({
                    comments: [keepAliveComment],
                  }),
                );
                span?.addEvent("keepalive");
              }, keepAliveInterval);
            }
            const value1 = await (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "runInSpanContext"
            ])(span, () => iterator.next());
            clearInterval(timeout);
            if (cancelled) {
              return;
            }
            const meta = (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "getEventMeta"
            ])(value1.value);
            if (!value1.done || value1.value !== void 0 || meta !== void 0) {
              const event = value1.done ? "done" : "message";
              controller.enqueue(
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "encodeEventMessage"
                ])({
                  ...meta,
                  event,
                  data: (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "stringifyJSON"
                  ])(value1.value),
                }),
              );
              span?.addEvent(event);
            }
            if (value1.done) {
              controller.close();
              span?.end();
            }
          } catch (err) {
            clearInterval(timeout);
            if (cancelled) {
              return;
            }
            if (
              err instanceof
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "ErrorEvent"
              ]
            ) {
              controller.enqueue(
                (0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "encodeEventMessage"
                ])({
                  ...(0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "getEventMeta"
                  ])(err),
                  event: "error",
                  data: (0,
                  __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                    "stringifyJSON"
                  ])(err.data),
                }),
              );
              span?.addEvent("error");
              controller.close();
            } else {
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "setSpanError"
              ])(span, err);
              controller.error(err);
            }
            span?.end();
          }
        },
        async cancel() {
          try {
            cancelled = true;
            clearInterval(timeout);
            span?.addEvent("cancelled");
            await (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "runInSpanContext"
            ])(span, () => iterator.return?.());
          } catch (e) {
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "setSpanError"
            ])(span, e);
            throw e;
          } finally {
            span?.end();
          }
        },
      }).pipeThrough(new TextEncoderStream());
      return stream;
    }
    function toStandardBody(re, options = {}) {
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "runWithSpan"
      ])(
        {
          name: "parse_standard_body",
          signal: options.signal,
        },
        async () => {
          const contentDisposition = re.headers.get("content-disposition");
          if (typeof contentDisposition === "string") {
            const fileName =
              (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "getFilenameFromContentDisposition"
              ])(contentDisposition) ?? "blob";
            const blob2 = await re.blob();
            return new File([blob2], fileName, {
              type: blob2.type,
            });
          }
          const contentType = re.headers.get("content-type");
          if (!contentType || contentType.startsWith("application/json")) {
            const text = await re.text();
            return (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
              "parseEmptyableJSON"
            ])(text);
          }
          if (contentType.startsWith("multipart/form-data")) {
            return await re.formData();
          }
          if (contentType.startsWith("application/x-www-form-urlencoded")) {
            const text = await re.text();
            return new URLSearchParams(text);
          }
          if (contentType.startsWith("text/event-stream")) {
            return toEventIterator(re.body, options);
          }
          if (contentType.startsWith("text/plain")) {
            return await re.text();
          }
          const blob = await re.blob();
          return new File([blob], "blob", {
            type: blob.type,
          });
        },
      );
    }
    function toFetchBody(body, headers, options = {}) {
      const currentContentDisposition = headers.get("content-disposition");
      headers.delete("content-type");
      headers.delete("content-disposition");
      if (body === void 0) {
        return void 0;
      }
      if (body instanceof Blob) {
        headers.set("content-type", body.type);
        headers.set("content-length", body.size.toString());
        headers.set(
          "content-disposition",
          currentContentDisposition ??
            (0,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$standard$2d$server$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "generateContentDisposition"
            ])(body instanceof File ? body.name : "blob"),
        );
        return body;
      }
      if (body instanceof FormData) {
        return body;
      }
      if (body instanceof URLSearchParams) {
        return body;
      }
      if (
        (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "isAsyncIteratorObject"
        ])(body)
      ) {
        headers.set("content-type", "text/event-stream");
        return toEventStream(body, options);
      }
      headers.set("content-type", "application/json");
      return (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "stringifyJSON"
      ])(body);
    }
    function toStandardHeaders(headers, standardHeaders = {}) {
      headers.forEach((value1, key) => {
        if (Array.isArray(standardHeaders[key])) {
          standardHeaders[key].push(value1);
        } else if (standardHeaders[key] !== void 0) {
          standardHeaders[key] = [standardHeaders[key], value1];
        } else {
          standardHeaders[key] = value1;
        }
      });
      return standardHeaders;
    }
    function toFetchHeaders(headers, fetchHeaders = new Headers()) {
      for (const [key, value1] of Object.entries(headers)) {
        if (Array.isArray(value1)) {
          for (const v of value1) {
            fetchHeaders.append(key, v);
          }
        } else if (value1 !== void 0) {
          fetchHeaders.append(key, value1);
        }
      }
      return fetchHeaders;
    }
    function toStandardLazyRequest(request) {
      return {
        url: new URL(request.url),
        signal: request.signal,
        method: request.method,
        body: (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "once"
        ])(() =>
          toStandardBody(request, {
            signal: request.signal,
          }),
        ),
        get headers() {
          const headers = toStandardHeaders(request.headers);
          Object.defineProperty(this, "headers", {
            value: headers,
            writable: true,
          });
          return headers;
        },
        set headers(value) {
          Object.defineProperty(this, "headers", {
            value,
            writable: true,
          });
        },
      };
    }
    function toFetchRequest(request, options = {}) {
      const headers = toFetchHeaders(request.headers);
      const body = toFetchBody(request.body, headers, options);
      return new Request(request.url, {
        signal: request.signal,
        method: request.method,
        headers,
        body,
      });
    }
    function toFetchResponse(response, options = {}) {
      const headers = toFetchHeaders(response.headers);
      const body = toFetchBody(response.body, headers, options);
      return new Response(body, {
        headers,
        status: response.status,
      });
    }
    function toStandardLazyResponse(response, options = {}) {
      return {
        body: (0,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
          "once"
        ])(() => toStandardBody(response, options)),
        status: response.status,
        get headers() {
          const headers = toStandardHeaders(response.headers);
          Object.defineProperty(this, "headers", {
            value: headers,
            writable: true,
          });
          return headers;
        },
        set headers(value) {
          Object.defineProperty(this, "headers", {
            value,
            writable: true,
          });
        },
      };
    }
  },
  "[project]/node_modules/@orpc/tanstack-query/dist/index.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "OPERATION_CONTEXT_SYMBOL",
      () => OPERATION_CONTEXT_SYMBOL,
      "TANSTACK_QUERY_OPERATION_CONTEXT_SYMBOL",
      () => OPERATION_CONTEXT_SYMBOL,
      "createGeneralUtils",
      () => createGeneralUtils,
      "createProcedureUtils",
      () => createProcedureUtils,
      "createRouterUtils",
      () => createRouterUtils,
      "createTanstackQueryUtils",
      () => createRouterUtils,
      "experimental_serializableStreamedQuery",
      () => experimental_serializableStreamedQuery,
      "generateOperationKey",
      () => generateOperationKey,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@orpc/shared/dist/index.mjs [app-client] (ecmascript) <locals>",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/@tanstack/query-core/build/modern/utils.js [app-client] (ecmascript)",
      );
    function generateOperationKey(path, state = {}) {
      return [
        path,
        {
          ...(state.input !== void 0
            ? {
                input: state.input,
              }
            : {}),
          ...(state.type !== void 0
            ? {
                type: state.type,
              }
            : {}),
          ...(state.fnOptions !== void 0
            ? {
                fnOptions: state.fnOptions,
              }
            : {}),
        },
      ];
    }
    function createGeneralUtils(path) {
      return {
        key(options) {
          return generateOperationKey(path, options);
        },
      };
    }
    function experimental_liveQuery(queryFn) {
      return async (context) => {
        const stream = await queryFn(context);
        let last;
        for await (const chunk of stream) {
          if (context.signal.aborted) {
            throw context.signal.reason;
          }
          last = {
            chunk,
          };
          context.client.setQueryData(context.queryKey, chunk);
        }
        if (!last) {
          throw new Error(
            `Live query for ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["stringifyJSON"])(context.queryKey)} did not yield any data. Ensure the query function returns an AsyncIterable with at least one chunk.`,
          );
        }
        return last.chunk;
      };
    }
    function experimental_serializableStreamedQuery(
      queryFn,
      { refetchMode = "reset", maxChunks = Number.POSITIVE_INFINITY } = {},
    ) {
      return async (context) => {
        const query = context.client.getQueryCache().find({
          queryKey: context.queryKey,
          exact: true,
        });
        const hasPreviousData = !!query && query.state.data !== void 0;
        if (hasPreviousData) {
          if (refetchMode === "reset") {
            query.setState({
              status: "pending",
              data: void 0,
              error: null,
              fetchStatus: "fetching",
            });
          } else {
            context.client.setQueryData(context.queryKey, (prev = []) =>
              limitArraySize(prev, maxChunks),
            );
          }
        }
        let result = [];
        const stream = await queryFn(context);
        const shouldUpdateCacheDuringStream = !hasPreviousData || refetchMode !== "replace";
        context.client.setQueryData(context.queryKey, (prev = []) =>
          limitArraySize(prev, maxChunks),
        );
        for await (const chunk of stream) {
          if (context.signal.aborted) {
            throw context.signal.reason;
          }
          result.push(chunk);
          result = limitArraySize(result, maxChunks);
          if (shouldUpdateCacheDuringStream) {
            context.client.setQueryData(context.queryKey, (prev = []) =>
              limitArraySize([...prev, chunk], maxChunks),
            );
          }
        }
        if (!shouldUpdateCacheDuringStream) {
          context.client.setQueryData(context.queryKey, result);
        }
        const cachedData = context.client.getQueryData(context.queryKey);
        if (cachedData) {
          return limitArraySize(cachedData, maxChunks);
        }
        return result;
      };
    }
    function limitArraySize(items, maxSize) {
      if (items.length <= maxSize) {
        return items;
      }
      return items.slice(items.length - maxSize);
    }
    const OPERATION_CONTEXT_SYMBOL = Symbol("ORPC_OPERATION_CONTEXT");
    function createProcedureUtils(client, options) {
      const utils = {
        call: client,
        queryKey(...[optionsIn = {}]) {
          optionsIn = {
            ...options.experimental_defaults?.queryKey,
            ...optionsIn,
          };
          const queryKey =
            optionsIn.queryKey ??
            generateOperationKey(options.path, {
              type: "query",
              input: optionsIn.input,
            });
          return queryKey;
        },
        queryOptions(...[optionsIn = {}]) {
          optionsIn = {
            ...options.experimental_defaults?.queryOptions,
            ...optionsIn,
          };
          const queryKey = utils.queryKey(optionsIn);
          return {
            queryFn: ({ signal }) => {
              if (
                optionsIn.input ===
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "skipToken"
                ]
              ) {
                throw new Error("queryFn should not be called with skipToken used as input");
              }
              return client(optionsIn.input, {
                signal,
                context: {
                  [OPERATION_CONTEXT_SYMBOL]: {
                    key: queryKey,
                    type: "query",
                  },
                  ...optionsIn.context,
                },
              });
            },
            ...(optionsIn.input ===
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "skipToken"
            ]
              ? {
                  enabled: false,
                }
              : {}),
            ...optionsIn,
            queryKey,
          };
        },
        experimental_streamedKey(...[optionsIn = {}]) {
          optionsIn = {
            ...options.experimental_defaults?.experimental_streamedKey,
            ...optionsIn,
          };
          const queryKey =
            optionsIn.queryKey ??
            generateOperationKey(options.path, {
              type: "streamed",
              input: optionsIn.input,
              fnOptions: optionsIn.queryFnOptions,
            });
          return queryKey;
        },
        experimental_streamedOptions(...[optionsIn = {}]) {
          optionsIn = {
            ...options.experimental_defaults?.experimental_streamedOptions,
            ...optionsIn,
          };
          const queryKey = utils.experimental_streamedKey(optionsIn);
          return {
            queryFn: experimental_serializableStreamedQuery(async ({ signal }) => {
              if (
                optionsIn.input ===
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "skipToken"
                ]
              ) {
                throw new Error("queryFn should not be called with skipToken used as input");
              }
              const output = await client(optionsIn.input, {
                signal,
                context: {
                  [OPERATION_CONTEXT_SYMBOL]: {
                    key: queryKey,
                    type: "streamed",
                  },
                  ...optionsIn.context,
                },
              });
              if (
                !(0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "isAsyncIteratorObject"
                ])(output)
              ) {
                throw new Error("streamedQuery requires an event iterator output");
              }
              return output;
            }, optionsIn.queryFnOptions),
            ...(optionsIn.input ===
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "skipToken"
            ]
              ? {
                  enabled: false,
                }
              : {}),
            ...optionsIn,
            queryKey,
          };
        },
        experimental_liveKey(...[optionsIn = {}]) {
          optionsIn = {
            ...options.experimental_defaults?.experimental_liveKey,
            ...optionsIn,
          };
          const queryKey =
            optionsIn.queryKey ??
            generateOperationKey(options.path, {
              type: "live",
              input: optionsIn.input,
            });
          return queryKey;
        },
        experimental_liveOptions(...[optionsIn = {}]) {
          optionsIn = {
            ...options.experimental_defaults?.experimental_liveOptions,
            ...optionsIn,
          };
          const queryKey = utils.experimental_liveKey(optionsIn);
          return {
            queryFn: experimental_liveQuery(async ({ signal }) => {
              if (
                optionsIn.input ===
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "skipToken"
                ]
              ) {
                throw new Error("queryFn should not be called with skipToken used as input");
              }
              const output = await client(optionsIn.input, {
                signal,
                context: {
                  [OPERATION_CONTEXT_SYMBOL]: {
                    key: queryKey,
                    type: "live",
                  },
                  ...optionsIn.context,
                },
              });
              if (
                !(0,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                  "isAsyncIteratorObject"
                ])(output)
              ) {
                throw new Error("liveQuery requires an event iterator output");
              }
              return output;
            }),
            ...(optionsIn.input ===
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "skipToken"
            ]
              ? {
                  enabled: false,
                }
              : {}),
            ...optionsIn,
            queryKey,
          };
        },
        infiniteKey(optionsIn) {
          optionsIn = {
            ...options.experimental_defaults?.infiniteKey,
            ...optionsIn,
          };
          const queryKey =
            optionsIn.queryKey ??
            generateOperationKey(options.path, {
              type: "infinite",
              input:
                optionsIn.input ===
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "skipToken"
                ]
                  ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                      "skipToken"
                    ]
                  : optionsIn.input(optionsIn.initialPageParam),
            });
          return queryKey;
        },
        infiniteOptions(optionsIn) {
          optionsIn = {
            ...options.experimental_defaults?.infiniteOptions,
            ...optionsIn,
          };
          const queryKey = utils.infiniteKey(optionsIn);
          return {
            queryFn: ({ pageParam, signal }) => {
              if (
                optionsIn.input ===
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "skipToken"
                ]
              ) {
                throw new Error("queryFn should not be called with skipToken used as input");
              }
              return client(optionsIn.input(pageParam), {
                signal,
                context: {
                  [OPERATION_CONTEXT_SYMBOL]: {
                    key: queryKey,
                    type: "infinite",
                  },
                  ...optionsIn.context,
                },
              });
            },
            ...(optionsIn.input ===
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$modern$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "skipToken"
            ]
              ? {
                  enabled: false,
                }
              : {}),
            ...optionsIn,
            queryKey,
          };
        },
        mutationKey(...[optionsIn = {}]) {
          optionsIn = {
            ...options.experimental_defaults?.mutationKey,
            ...optionsIn,
          };
          const mutationKey =
            optionsIn.mutationKey ??
            generateOperationKey(options.path, {
              type: "mutation",
            });
          return mutationKey;
        },
        mutationOptions(...[optionsIn = {}]) {
          optionsIn = {
            ...options.experimental_defaults?.mutationOptions,
            ...optionsIn,
          };
          const mutationKey = utils.mutationKey(optionsIn);
          return {
            mutationFn: (input) =>
              client(input, {
                context: {
                  [OPERATION_CONTEXT_SYMBOL]: {
                    key: mutationKey,
                    type: "mutation",
                  },
                  ...optionsIn.context,
                },
              }),
            ...optionsIn,
            mutationKey,
          };
        },
      };
      return utils;
    }
    function createRouterUtils(client, options = {}) {
      const path = (0,
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
        "toArray"
      ])(options.path);
      const generalUtils = createGeneralUtils(path);
      const procedureUtils = createProcedureUtils(client, {
        path,
        experimental_defaults: options.experimental_defaults,
      });
      const recursive = new Proxy(
        {
          ...generalUtils,
          ...procedureUtils,
        },
        {
          get(target, prop) {
            const value = Reflect.get(target, prop);
            if (typeof prop !== "string") {
              return value;
            }
            const nextUtils = createRouterUtils(client[prop], {
              ...options,
              path: [...path, prop],
              experimental_defaults: (0,
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orpc$2f$shared$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__[
                "get"
              ])(options.experimental_defaults, [prop]),
            });
            if (typeof value !== "function") {
              return nextUtils;
            }
            return new Proxy(value, {
              get(_, prop2) {
                return Reflect.get(nextUtils, prop2);
              },
            });
          },
        },
      );
      return recursive;
    }
  },
  "[project]/node_modules/sonner/dist/index.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s([
      "Toaster",
      () => Toaster,
      "toast",
      () => toast,
      "useSonner",
      () => useSonner,
    ]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)",
      );
    ("use client");
    function __insertCSS(code) {
      if (!code || typeof document == "undefined") return;
      let head = document.head || document.getElementsByTagName("head")[0];
      let style = document.createElement("style");
      style.type = "text/css";
      head.appendChild(style);
      style.styleSheet
        ? (style.styleSheet.cssText = code)
        : style.appendChild(document.createTextNode(code));
    }
    const getAsset = (type) => {
      switch (type) {
        case "success":
          return SuccessIcon;
        case "info":
          return InfoIcon;
        case "warning":
          return WarningIcon;
        case "error":
          return ErrorIcon;
        default:
          return null;
      }
    };
    const bars = Array(12).fill(0);
    const Loader = ({ visible, className }) => {
      return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].createElement(
        "div",
        {
          className: ["sonner-loading-wrapper", className].filter(Boolean).join(" "),
          "data-visible": visible,
        },
        /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].createElement(
          "div",
          {
            className: "sonner-spinner",
          },
          bars.map((_, i) =>
            /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "default"
            ].createElement("div", {
              className: "sonner-loading-bar",
              key: `spinner-bar-${i}`,
            }),
          ),
        ),
      );
    };
    const SuccessIcon =
      /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 20 20",
          fill: "currentColor",
          height: "20",
          width: "20",
        },
        /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].createElement("path", {
          fillRule: "evenodd",
          d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
          clipRule: "evenodd",
        }),
      );
    const WarningIcon =
      /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 24 24",
          fill: "currentColor",
          height: "20",
          width: "20",
        },
        /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].createElement("path", {
          fillRule: "evenodd",
          d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
          clipRule: "evenodd",
        }),
      );
    const InfoIcon =
      /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 20 20",
          fill: "currentColor",
          height: "20",
          width: "20",
        },
        /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].createElement("path", {
          fillRule: "evenodd",
          d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
          clipRule: "evenodd",
        }),
      );
    const ErrorIcon =
      /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 20 20",
          fill: "currentColor",
          height: "20",
          width: "20",
        },
        /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].createElement("path", {
          fillRule: "evenodd",
          d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
          clipRule: "evenodd",
        }),
      );
    const CloseIcon =
      /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].createElement(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          width: "12",
          height: "12",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "1.5",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        },
        /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].createElement("line", {
          x1: "18",
          y1: "6",
          x2: "6",
          y2: "18",
        }),
        /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].createElement("line", {
          x1: "6",
          y1: "6",
          x2: "18",
          y2: "18",
        }),
      );
    const useIsDocumentHidden = () => {
      const [isDocumentHidden, setIsDocumentHidden] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useState(document.hidden);
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].useEffect(
        {
          "useIsDocumentHidden.useEffect": () => {
            const callback = {
              "useIsDocumentHidden.useEffect.callback": () => {
                setIsDocumentHidden(document.hidden);
              },
            }["useIsDocumentHidden.useEffect.callback"];
            document.addEventListener("visibilitychange", callback);
            return {
              "useIsDocumentHidden.useEffect": () =>
                window.removeEventListener("visibilitychange", callback),
            }["useIsDocumentHidden.useEffect"];
          },
        }["useIsDocumentHidden.useEffect"],
        [],
      );
      return isDocumentHidden;
    };
    let toastsCounter = 1;
    class Observer {
      constructor() {
        // We use arrow functions to maintain the correct `this` reference
        this.subscribe = (subscriber) => {
          this.subscribers.push(subscriber);
          return () => {
            const index = this.subscribers.indexOf(subscriber);
            this.subscribers.splice(index, 1);
          };
        };
        this.publish = (data) => {
          this.subscribers.forEach((subscriber) => subscriber(data));
        };
        this.addToast = (data) => {
          this.publish(data);
          this.toasts = [...this.toasts, data];
        };
        this.create = (data) => {
          var _data_id;
          const { message, ...rest } = data;
          const id =
            typeof (data == null ? void 0 : data.id) === "number" ||
            ((_data_id = data.id) == null ? void 0 : _data_id.length) > 0
              ? data.id
              : toastsCounter++;
          const alreadyExists = this.toasts.find((toast) => {
            return toast.id === id;
          });
          const dismissible = data.dismissible === undefined ? true : data.dismissible;
          if (this.dismissedToasts.has(id)) {
            this.dismissedToasts.delete(id);
          }
          if (alreadyExists) {
            this.toasts = this.toasts.map((toast) => {
              if (toast.id === id) {
                this.publish({
                  ...toast,
                  ...data,
                  id,
                  title: message,
                });
                return {
                  ...toast,
                  ...data,
                  id,
                  dismissible,
                  title: message,
                };
              }
              return toast;
            });
          } else {
            this.addToast({
              title: message,
              ...rest,
              dismissible,
              id,
            });
          }
          return id;
        };
        this.dismiss = (id) => {
          if (id) {
            this.dismissedToasts.add(id);
            requestAnimationFrame(() =>
              this.subscribers.forEach((subscriber) =>
                subscriber({
                  id,
                  dismiss: true,
                }),
              ),
            );
          } else {
            this.toasts.forEach((toast) => {
              this.subscribers.forEach((subscriber) =>
                subscriber({
                  id: toast.id,
                  dismiss: true,
                }),
              );
            });
          }
          return id;
        };
        this.message = (message, data) => {
          return this.create({
            ...data,
            message,
          });
        };
        this.error = (message, data) => {
          return this.create({
            ...data,
            message,
            type: "error",
          });
        };
        this.success = (message, data) => {
          return this.create({
            ...data,
            type: "success",
            message,
          });
        };
        this.info = (message, data) => {
          return this.create({
            ...data,
            type: "info",
            message,
          });
        };
        this.warning = (message, data) => {
          return this.create({
            ...data,
            type: "warning",
            message,
          });
        };
        this.loading = (message, data) => {
          return this.create({
            ...data,
            type: "loading",
            message,
          });
        };
        this.promise = (promise, data) => {
          if (!data) {
            // Nothing to show
            return;
          }
          let id = undefined;
          if (data.loading !== undefined) {
            id = this.create({
              ...data,
              promise,
              type: "loading",
              message: data.loading,
              description: typeof data.description !== "function" ? data.description : undefined,
            });
          }
          const p = Promise.resolve(promise instanceof Function ? promise() : promise);
          let shouldDismiss = id !== undefined;
          let result;
          const originalPromise = p
            .then(async (response) => {
              result = ["resolve", response];
              const isReactElementResponse =
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                  "default"
                ].isValidElement(response);
              if (isReactElementResponse) {
                shouldDismiss = false;
                this.create({
                  id,
                  type: "default",
                  message: response,
                });
              } else if (isHttpResponse(response) && !response.ok) {
                shouldDismiss = false;
                const promiseData =
                  typeof data.error === "function"
                    ? await data.error(`HTTP error! status: ${response.status}`)
                    : data.error;
                const description =
                  typeof data.description === "function"
                    ? await data.description(`HTTP error! status: ${response.status}`)
                    : data.description;
                const isExtendedResult =
                  typeof promiseData === "object" &&
                  !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "default"
                  ].isValidElement(promiseData);
                const toastSettings = isExtendedResult
                  ? promiseData
                  : {
                      message: promiseData,
                    };
                this.create({
                  id,
                  type: "error",
                  description,
                  ...toastSettings,
                });
              } else if (response instanceof Error) {
                shouldDismiss = false;
                const promiseData =
                  typeof data.error === "function" ? await data.error(response) : data.error;
                const description =
                  typeof data.description === "function"
                    ? await data.description(response)
                    : data.description;
                const isExtendedResult =
                  typeof promiseData === "object" &&
                  !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "default"
                  ].isValidElement(promiseData);
                const toastSettings = isExtendedResult
                  ? promiseData
                  : {
                      message: promiseData,
                    };
                this.create({
                  id,
                  type: "error",
                  description,
                  ...toastSettings,
                });
              } else if (data.success !== undefined) {
                shouldDismiss = false;
                const promiseData =
                  typeof data.success === "function" ? await data.success(response) : data.success;
                const description =
                  typeof data.description === "function"
                    ? await data.description(response)
                    : data.description;
                const isExtendedResult =
                  typeof promiseData === "object" &&
                  !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "default"
                  ].isValidElement(promiseData);
                const toastSettings = isExtendedResult
                  ? promiseData
                  : {
                      message: promiseData,
                    };
                this.create({
                  id,
                  type: "success",
                  description,
                  ...toastSettings,
                });
              }
            })
            .catch(async (error) => {
              result = ["reject", error];
              if (data.error !== undefined) {
                shouldDismiss = false;
                const promiseData =
                  typeof data.error === "function" ? await data.error(error) : data.error;
                const description =
                  typeof data.description === "function"
                    ? await data.description(error)
                    : data.description;
                const isExtendedResult =
                  typeof promiseData === "object" &&
                  !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "default"
                  ].isValidElement(promiseData);
                const toastSettings = isExtendedResult
                  ? promiseData
                  : {
                      message: promiseData,
                    };
                this.create({
                  id,
                  type: "error",
                  description,
                  ...toastSettings,
                });
              }
            })
            .finally(() => {
              if (shouldDismiss) {
                // Toast is still in load state (and will be indefinitely — dismiss it)
                this.dismiss(id);
                id = undefined;
              }
              data.finally == null ? void 0 : data.finally.call(data);
            });
          const unwrap = () =>
            new Promise((resolve, reject) =>
              originalPromise
                .then(() => (result[0] === "reject" ? reject(result[1]) : resolve(result[1])))
                .catch(reject),
            );
          if (typeof id !== "string" && typeof id !== "number") {
            // cannot Object.assign on undefined
            return {
              unwrap,
            };
          } else {
            return Object.assign(id, {
              unwrap,
            });
          }
        };
        this.custom = (jsx, data) => {
          const id = (data == null ? void 0 : data.id) || toastsCounter++;
          this.create({
            jsx: jsx(id),
            id,
            ...data,
          });
          return id;
        };
        this.getActiveToasts = () => {
          return this.toasts.filter((toast) => !this.dismissedToasts.has(toast.id));
        };
        this.subscribers = [];
        this.toasts = [];
        this.dismissedToasts = new Set();
      }
    }
    const ToastState = new Observer();
    // bind this to the toast function
    const toastFunction = (message, data) => {
      const id = (data == null ? void 0 : data.id) || toastsCounter++;
      ToastState.addToast({
        title: message,
        ...data,
        id,
      });
      return id;
    };
    const isHttpResponse = (data) => {
      return (
        data &&
        typeof data === "object" &&
        "ok" in data &&
        typeof data.ok === "boolean" &&
        "status" in data &&
        typeof data.status === "number"
      );
    };
    const basicToast = toastFunction;
    const getHistory = () => ToastState.toasts;
    const getToasts = () => ToastState.getActiveToasts();
    // We use `Object.assign` to maintain the correct types as we would lose them otherwise
    const toast = Object.assign(
      basicToast,
      {
        success: ToastState.success,
        info: ToastState.info,
        warning: ToastState.warning,
        error: ToastState.error,
        custom: ToastState.custom,
        message: ToastState.message,
        promise: ToastState.promise,
        dismiss: ToastState.dismiss,
        loading: ToastState.loading,
      },
      {
        getHistory,
        getToasts,
      },
    );
    __insertCSS(
      "[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}",
    );
    function isAction(action) {
      return action.label !== undefined;
    }
    // Visible toasts amount
    const VISIBLE_TOASTS_AMOUNT = 3;
    // Viewport padding
    const VIEWPORT_OFFSET = "24px";
    // Mobile viewport padding
    const MOBILE_VIEWPORT_OFFSET = "16px";
    // Default lifetime of a toasts (in ms)
    const TOAST_LIFETIME = 4000;
    // Default toast width
    const TOAST_WIDTH = 356;
    // Default gap between toasts
    const GAP = 14;
    // Threshold to dismiss a toast
    const SWIPE_THRESHOLD = 45;
    // Equal to exit animation duration
    const TIME_BEFORE_UNMOUNT = 200;
    function cn(...classes) {
      return classes.filter(Boolean).join(" ");
    }
    function getDefaultSwipeDirections(position) {
      const [y, x] = position.split("-");
      const directions = [];
      if (y) {
        directions.push(y);
      }
      if (x) {
        directions.push(x);
      }
      return directions;
    }
    const Toast = (props) => {
      var _toast_classNames,
        _toast_classNames1,
        _toast_classNames2,
        _toast_classNames3,
        _toast_classNames4,
        _toast_classNames5,
        _toast_classNames6,
        _toast_classNames7,
        _toast_classNames8;
      const {
        invert: ToasterInvert,
        toast,
        unstyled,
        interacting,
        setHeights,
        visibleToasts,
        heights,
        index,
        toasts,
        expanded,
        removeToast,
        defaultRichColors,
        closeButton: closeButtonFromToaster,
        style,
        cancelButtonStyle,
        actionButtonStyle,
        className = "",
        descriptionClassName = "",
        duration: durationFromToaster,
        position,
        gap,
        expandByDefault,
        classNames,
        icons,
        closeButtonAriaLabel = "Close toast",
      } = props;
      const [swipeDirection, setSwipeDirection] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useState(null);
      const [swipeOutDirection, setSwipeOutDirection] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useState(null);
      const [mounted, setMounted] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useState(false);
      const [removed, setRemoved] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useState(false);
      const [swiping, setSwiping] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useState(false);
      const [swipeOut, setSwipeOut] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useState(false);
      const [isSwiped, setIsSwiped] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useState(false);
      const [offsetBeforeRemove, setOffsetBeforeRemove] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useState(0);
      const [initialHeight, setInitialHeight] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useState(0);
      const remainingTime =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useRef(toast.duration || durationFromToaster || TOAST_LIFETIME);
      const dragStartTime =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useRef(null);
      const toastRef =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useRef(null);
      const isFront = index === 0;
      const isVisible = index + 1 <= visibleToasts;
      const toastType = toast.type;
      const dismissible = toast.dismissible !== false;
      const toastClassname = toast.className || "";
      const toastDescriptionClassname = toast.descriptionClassName || "";
      // Height index is used to calculate the offset as it gets updated before the toast array, which means we can calculate the new layout faster.
      const heightIndex =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useMemo(
          {
            "Toast.useMemo[heightIndex]": () =>
              heights.findIndex(
                {
                  "Toast.useMemo[heightIndex]": (height) => height.toastId === toast.id,
                }["Toast.useMemo[heightIndex]"],
              ) || 0,
          }["Toast.useMemo[heightIndex]"],
          [heights, toast.id],
        );
      const closeButton =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useMemo(
          {
            "Toast.useMemo[closeButton]": () => {
              var _toast_closeButton;
              return (_toast_closeButton = toast.closeButton) != null
                ? _toast_closeButton
                : closeButtonFromToaster;
            },
          }["Toast.useMemo[closeButton]"],
          [toast.closeButton, closeButtonFromToaster],
        );
      const duration =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useMemo(
          {
            "Toast.useMemo[duration]": () =>
              toast.duration || durationFromToaster || TOAST_LIFETIME,
          }["Toast.useMemo[duration]"],
          [toast.duration, durationFromToaster],
        );
      const closeTimerStartTimeRef =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useRef(0);
      const offset =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useRef(0);
      const lastCloseTimerStartTimeRef =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useRef(0);
      const pointerStartRef =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useRef(null);
      const [y, x] = position.split("-");
      const toastsHeightBefore =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useMemo(
          {
            "Toast.useMemo[toastsHeightBefore]": () => {
              return heights.reduce(
                {
                  "Toast.useMemo[toastsHeightBefore]": (prev, curr, reducerIndex) => {
                    // Calculate offset up until current toast
                    if (reducerIndex >= heightIndex) {
                      return prev;
                    }
                    return prev + curr.height;
                  },
                }["Toast.useMemo[toastsHeightBefore]"],
                0,
              );
            },
          }["Toast.useMemo[toastsHeightBefore]"],
          [heights, heightIndex],
        );
      const isDocumentHidden = useIsDocumentHidden();
      const invert = toast.invert || ToasterInvert;
      const disabled = toastType === "loading";
      offset.current =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useMemo(
          {
            "Toast.useMemo": () => heightIndex * gap + toastsHeightBefore,
          }["Toast.useMemo"],
          [heightIndex, toastsHeightBefore],
        );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].useEffect(
        {
          "Toast.useEffect": () => {
            remainingTime.current = duration;
          },
        }["Toast.useEffect"],
        [duration],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].useEffect(
        {
          "Toast.useEffect": () => {
            // Trigger enter animation without using CSS animation
            setMounted(true);
          },
        }["Toast.useEffect"],
        [],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].useEffect(
        {
          "Toast.useEffect": () => {
            const toastNode = toastRef.current;
            if (toastNode) {
              const height = toastNode.getBoundingClientRect().height;
              // Add toast height to heights array after the toast is mounted
              setInitialHeight(height);
              setHeights(
                {
                  "Toast.useEffect": (h) => [
                    {
                      toastId: toast.id,
                      height,
                      position: toast.position,
                    },
                    ...h,
                  ],
                }["Toast.useEffect"],
              );
              return {
                "Toast.useEffect": () =>
                  setHeights(
                    {
                      "Toast.useEffect": (h) =>
                        h.filter(
                          {
                            "Toast.useEffect": (height) => height.toastId !== toast.id,
                          }["Toast.useEffect"],
                        ),
                    }["Toast.useEffect"],
                  ),
              }["Toast.useEffect"];
            }
          },
        }["Toast.useEffect"],
        [setHeights, toast.id],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].useLayoutEffect(
        {
          "Toast.useLayoutEffect": () => {
            // Keep height up to date with the content in case it updates
            if (!mounted) return;
            const toastNode = toastRef.current;
            const originalHeight = toastNode.style.height;
            toastNode.style.height = "auto";
            const newHeight = toastNode.getBoundingClientRect().height;
            toastNode.style.height = originalHeight;
            setInitialHeight(newHeight);
            setHeights(
              {
                "Toast.useLayoutEffect": (heights) => {
                  const alreadyExists = heights.find(
                    {
                      "Toast.useLayoutEffect.alreadyExists": (height) =>
                        height.toastId === toast.id,
                    }["Toast.useLayoutEffect.alreadyExists"],
                  );
                  if (!alreadyExists) {
                    return [
                      {
                        toastId: toast.id,
                        height: newHeight,
                        position: toast.position,
                      },
                      ...heights,
                    ];
                  } else {
                    return heights.map(
                      {
                        "Toast.useLayoutEffect": (height) =>
                          height.toastId === toast.id
                            ? {
                                ...height,
                                height: newHeight,
                              }
                            : height,
                      }["Toast.useLayoutEffect"],
                    );
                  }
                },
              }["Toast.useLayoutEffect"],
            );
          },
        }["Toast.useLayoutEffect"],
        [
          mounted,
          toast.title,
          toast.description,
          setHeights,
          toast.id,
          toast.jsx,
          toast.action,
          toast.cancel,
        ],
      );
      const deleteToast =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useCallback(
          {
            "Toast.useCallback[deleteToast]": () => {
              // Save the offset for the exit swipe animation
              setRemoved(true);
              setOffsetBeforeRemove(offset.current);
              setHeights(
                {
                  "Toast.useCallback[deleteToast]": (h) =>
                    h.filter(
                      {
                        "Toast.useCallback[deleteToast]": (height) => height.toastId !== toast.id,
                      }["Toast.useCallback[deleteToast]"],
                    ),
                }["Toast.useCallback[deleteToast]"],
              );
              setTimeout(
                {
                  "Toast.useCallback[deleteToast]": () => {
                    removeToast(toast);
                  },
                }["Toast.useCallback[deleteToast]"],
                TIME_BEFORE_UNMOUNT,
              );
            },
          }["Toast.useCallback[deleteToast]"],
          [toast, removeToast, setHeights, offset],
        );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].useEffect(
        {
          "Toast.useEffect": () => {
            if (
              (toast.promise && toastType === "loading") ||
              toast.duration === Infinity ||
              toast.type === "loading"
            )
              return;
            let timeoutId;
            // Pause the timer on each hover
            const pauseTimer = {
              "Toast.useEffect.pauseTimer": () => {
                if (lastCloseTimerStartTimeRef.current < closeTimerStartTimeRef.current) {
                  // Get the elapsed time since the timer started
                  const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;
                  remainingTime.current = remainingTime.current - elapsedTime;
                }
                lastCloseTimerStartTimeRef.current = new Date().getTime();
              },
            }["Toast.useEffect.pauseTimer"];
            const startTimer = {
              "Toast.useEffect.startTimer": () => {
                // setTimeout(, Infinity) behaves as if the delay is 0.
                // As a result, the toast would be closed immediately, giving the appearance that it was never rendered.
                // See: https://github.com/denysdovhan/wtfjs?tab=readme-ov-file#an-infinite-timeout
                if (remainingTime.current === Infinity) return;
                closeTimerStartTimeRef.current = new Date().getTime();
                // Let the toast know it has started
                timeoutId = setTimeout(
                  {
                    "Toast.useEffect.startTimer": () => {
                      toast.onAutoClose == null ? void 0 : toast.onAutoClose.call(toast, toast);
                      deleteToast();
                    },
                  }["Toast.useEffect.startTimer"],
                  remainingTime.current,
                );
              },
            }["Toast.useEffect.startTimer"];
            if (expanded || interacting || isDocumentHidden) {
              pauseTimer();
            } else {
              startTimer();
            }
            return {
              "Toast.useEffect": () => clearTimeout(timeoutId),
            }["Toast.useEffect"];
          },
        }["Toast.useEffect"],
        [expanded, interacting, toast, toastType, isDocumentHidden, deleteToast],
      );
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].useEffect(
        {
          "Toast.useEffect": () => {
            if (toast.delete) {
              deleteToast();
              toast.onDismiss == null ? void 0 : toast.onDismiss.call(toast, toast);
            }
          },
        }["Toast.useEffect"],
        [deleteToast, toast.delete],
      );
      function getLoadingIcon() {
        var _toast_classNames;
        if (icons == null ? void 0 : icons.loading) {
          var _toast_classNames1;
          return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].createElement(
            "div",
            {
              className: cn(
                classNames == null ? void 0 : classNames.loader,
                toast == null
                  ? void 0
                  : (_toast_classNames1 = toast.classNames) == null
                    ? void 0
                    : _toast_classNames1.loader,
                "sonner-loader",
              ),
              "data-visible": toastType === "loading",
            },
            icons.loading,
          );
        }
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].createElement(Loader, {
          className: cn(
            classNames == null ? void 0 : classNames.loader,
            toast == null
              ? void 0
              : (_toast_classNames = toast.classNames) == null
                ? void 0
                : _toast_classNames.loader,
          ),
          visible: toastType === "loading",
        });
      }
      const icon = toast.icon || (icons == null ? void 0 : icons[toastType]) || getAsset(toastType);
      var _toast_richColors, _icons_close;
      return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].createElement(
        "li",
        {
          tabIndex: 0,
          ref: toastRef,
          className: cn(
            className,
            toastClassname,
            classNames == null ? void 0 : classNames.toast,
            toast == null
              ? void 0
              : (_toast_classNames = toast.classNames) == null
                ? void 0
                : _toast_classNames.toast,
            classNames == null ? void 0 : classNames.default,
            classNames == null ? void 0 : classNames[toastType],
            toast == null
              ? void 0
              : (_toast_classNames1 = toast.classNames) == null
                ? void 0
                : _toast_classNames1[toastType],
          ),
          "data-sonner-toast": "",
          "data-rich-colors":
            (_toast_richColors = toast.richColors) != null ? _toast_richColors : defaultRichColors,
          "data-styled": !Boolean(toast.jsx || toast.unstyled || unstyled),
          "data-mounted": mounted,
          "data-promise": Boolean(toast.promise),
          "data-swiped": isSwiped,
          "data-removed": removed,
          "data-visible": isVisible,
          "data-y-position": y,
          "data-x-position": x,
          "data-index": index,
          "data-front": isFront,
          "data-swiping": swiping,
          "data-dismissible": dismissible,
          "data-type": toastType,
          "data-invert": invert,
          "data-swipe-out": swipeOut,
          "data-swipe-direction": swipeOutDirection,
          "data-expanded": Boolean(expanded || (expandByDefault && mounted)),
          "data-testid": toast.testId,
          style: {
            "--index": index,
            "--toasts-before": index,
            "--z-index": toasts.length - index,
            "--offset": `${removed ? offsetBeforeRemove : offset.current}px`,
            "--initial-height": expandByDefault ? "auto" : `${initialHeight}px`,
            ...style,
            ...toast.style,
          },
          onDragEnd: () => {
            setSwiping(false);
            setSwipeDirection(null);
            pointerStartRef.current = null;
          },
          onPointerDown: (event) => {
            if (event.button === 2) return; // Return early on right click
            if (disabled || !dismissible) return;
            dragStartTime.current = new Date();
            setOffsetBeforeRemove(offset.current);
            // Ensure we maintain correct pointer capture even when going outside of the toast (e.g. when swiping)
            event.target.setPointerCapture(event.pointerId);
            if (event.target.tagName === "BUTTON") return;
            setSwiping(true);
            pointerStartRef.current = {
              x: event.clientX,
              y: event.clientY,
            };
          },
          onPointerUp: () => {
            var _toastRef_current, _toastRef_current1, _dragStartTime_current;
            if (swipeOut || !dismissible) return;
            pointerStartRef.current = null;
            const swipeAmountX = Number(
              ((_toastRef_current = toastRef.current) == null
                ? void 0
                : _toastRef_current.style.getPropertyValue("--swipe-amount-x").replace("px", "")) ||
                0,
            );
            const swipeAmountY = Number(
              ((_toastRef_current1 = toastRef.current) == null
                ? void 0
                : _toastRef_current1.style
                    .getPropertyValue("--swipe-amount-y")
                    .replace("px", "")) || 0,
            );
            const timeTaken =
              new Date().getTime() -
              ((_dragStartTime_current = dragStartTime.current) == null
                ? void 0
                : _dragStartTime_current.getTime());
            const swipeAmount = swipeDirection === "x" ? swipeAmountX : swipeAmountY;
            const velocity = Math.abs(swipeAmount) / timeTaken;
            if (Math.abs(swipeAmount) >= SWIPE_THRESHOLD || velocity > 0.11) {
              setOffsetBeforeRemove(offset.current);
              toast.onDismiss == null ? void 0 : toast.onDismiss.call(toast, toast);
              if (swipeDirection === "x") {
                setSwipeOutDirection(swipeAmountX > 0 ? "right" : "left");
              } else {
                setSwipeOutDirection(swipeAmountY > 0 ? "down" : "up");
              }
              deleteToast();
              setSwipeOut(true);
              return;
            } else {
              var _toastRef_current2, _toastRef_current3;
              (_toastRef_current2 = toastRef.current) == null
                ? void 0
                : _toastRef_current2.style.setProperty("--swipe-amount-x", `0px`);
              (_toastRef_current3 = toastRef.current) == null
                ? void 0
                : _toastRef_current3.style.setProperty("--swipe-amount-y", `0px`);
            }
            setIsSwiped(false);
            setSwiping(false);
            setSwipeDirection(null);
          },
          onPointerMove: (event) => {
            var _window_getSelection, _toastRef_current, _toastRef_current1;
            if (!pointerStartRef.current || !dismissible) return;
            const isHighlighted =
              ((_window_getSelection = window.getSelection()) == null
                ? void 0
                : _window_getSelection.toString().length) > 0;
            if (isHighlighted) return;
            const yDelta = event.clientY - pointerStartRef.current.y;
            const xDelta = event.clientX - pointerStartRef.current.x;
            var _props_swipeDirections;
            const swipeDirections =
              (_props_swipeDirections = props.swipeDirections) != null
                ? _props_swipeDirections
                : getDefaultSwipeDirections(position);
            // Determine swipe direction if not already locked
            if (!swipeDirection && (Math.abs(xDelta) > 1 || Math.abs(yDelta) > 1)) {
              setSwipeDirection(Math.abs(xDelta) > Math.abs(yDelta) ? "x" : "y");
            }
            let swipeAmount = {
              x: 0,
              y: 0,
            };
            const getDampening = (delta) => {
              const factor = Math.abs(delta) / 20;
              return 1 / (1.5 + factor);
            };
            // Only apply swipe in the locked direction
            if (swipeDirection === "y") {
              // Handle vertical swipes
              if (swipeDirections.includes("top") || swipeDirections.includes("bottom")) {
                if (
                  (swipeDirections.includes("top") && yDelta < 0) ||
                  (swipeDirections.includes("bottom") && yDelta > 0)
                ) {
                  swipeAmount.y = yDelta;
                } else {
                  // Smoothly transition to dampened movement
                  const dampenedDelta = yDelta * getDampening(yDelta);
                  // Ensure we don't jump when transitioning to dampened movement
                  swipeAmount.y =
                    Math.abs(dampenedDelta) < Math.abs(yDelta) ? dampenedDelta : yDelta;
                }
              }
            } else if (swipeDirection === "x") {
              // Handle horizontal swipes
              if (swipeDirections.includes("left") || swipeDirections.includes("right")) {
                if (
                  (swipeDirections.includes("left") && xDelta < 0) ||
                  (swipeDirections.includes("right") && xDelta > 0)
                ) {
                  swipeAmount.x = xDelta;
                } else {
                  // Smoothly transition to dampened movement
                  const dampenedDelta = xDelta * getDampening(xDelta);
                  // Ensure we don't jump when transitioning to dampened movement
                  swipeAmount.x =
                    Math.abs(dampenedDelta) < Math.abs(xDelta) ? dampenedDelta : xDelta;
                }
              }
            }
            if (Math.abs(swipeAmount.x) > 0 || Math.abs(swipeAmount.y) > 0) {
              setIsSwiped(true);
            }
            (_toastRef_current = toastRef.current) == null
              ? void 0
              : _toastRef_current.style.setProperty("--swipe-amount-x", `${swipeAmount.x}px`);
            (_toastRef_current1 = toastRef.current) == null
              ? void 0
              : _toastRef_current1.style.setProperty("--swipe-amount-y", `${swipeAmount.y}px`);
          },
        },
        closeButton && !toast.jsx && toastType !== "loading"
          ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "default"
            ].createElement(
              "button",
              {
                "aria-label": closeButtonAriaLabel,
                "data-disabled": disabled,
                "data-close-button": true,
                onClick:
                  disabled || !dismissible
                    ? () => {}
                    : () => {
                        deleteToast();
                        toast.onDismiss == null ? void 0 : toast.onDismiss.call(toast, toast);
                      },
                className: cn(
                  classNames == null ? void 0 : classNames.closeButton,
                  toast == null
                    ? void 0
                    : (_toast_classNames2 = toast.classNames) == null
                      ? void 0
                      : _toast_classNames2.closeButton,
                ),
              },
              (_icons_close = icons == null ? void 0 : icons.close) != null
                ? _icons_close
                : CloseIcon,
            )
          : null,
        (toastType || toast.icon || toast.promise) &&
          toast.icon !== null &&
          ((icons == null ? void 0 : icons[toastType]) !== null || toast.icon)
          ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "default"
            ].createElement(
              "div",
              {
                "data-icon": "",
                className: cn(
                  classNames == null ? void 0 : classNames.icon,
                  toast == null
                    ? void 0
                    : (_toast_classNames3 = toast.classNames) == null
                      ? void 0
                      : _toast_classNames3.icon,
                ),
              },
              toast.promise || (toast.type === "loading" && !toast.icon)
                ? toast.icon || getLoadingIcon()
                : null,
              toast.type !== "loading" ? icon : null,
            )
          : null,
        /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].createElement(
          "div",
          {
            "data-content": "",
            className: cn(
              classNames == null ? void 0 : classNames.content,
              toast == null
                ? void 0
                : (_toast_classNames4 = toast.classNames) == null
                  ? void 0
                  : _toast_classNames4.content,
            ),
          },
          /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].createElement(
            "div",
            {
              "data-title": "",
              className: cn(
                classNames == null ? void 0 : classNames.title,
                toast == null
                  ? void 0
                  : (_toast_classNames5 = toast.classNames) == null
                    ? void 0
                    : _toast_classNames5.title,
              ),
            },
            toast.jsx ? toast.jsx : typeof toast.title === "function" ? toast.title() : toast.title,
          ),
          toast.description
            ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "default"
              ].createElement(
                "div",
                {
                  "data-description": "",
                  className: cn(
                    descriptionClassName,
                    toastDescriptionClassname,
                    classNames == null ? void 0 : classNames.description,
                    toast == null
                      ? void 0
                      : (_toast_classNames6 = toast.classNames) == null
                        ? void 0
                        : _toast_classNames6.description,
                  ),
                },
                typeof toast.description === "function" ? toast.description() : toast.description,
              )
            : null,
        ),
        /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].isValidElement(toast.cancel)
          ? toast.cancel
          : toast.cancel && isAction(toast.cancel)
            ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "default"
              ].createElement(
                "button",
                {
                  "data-button": true,
                  "data-cancel": true,
                  style: toast.cancelButtonStyle || cancelButtonStyle,
                  onClick: (event) => {
                    // We need to check twice because typescript
                    if (!isAction(toast.cancel)) return;
                    if (!dismissible) return;
                    toast.cancel.onClick == null
                      ? void 0
                      : toast.cancel.onClick.call(toast.cancel, event);
                    deleteToast();
                  },
                  className: cn(
                    classNames == null ? void 0 : classNames.cancelButton,
                    toast == null
                      ? void 0
                      : (_toast_classNames7 = toast.classNames) == null
                        ? void 0
                        : _toast_classNames7.cancelButton,
                  ),
                },
                toast.cancel.label,
              )
            : null,
        /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].isValidElement(toast.action)
          ? toast.action
          : toast.action && isAction(toast.action)
            ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "default"
              ].createElement(
                "button",
                {
                  "data-button": true,
                  "data-action": true,
                  style: toast.actionButtonStyle || actionButtonStyle,
                  onClick: (event) => {
                    // We need to check twice because typescript
                    if (!isAction(toast.action)) return;
                    toast.action.onClick == null
                      ? void 0
                      : toast.action.onClick.call(toast.action, event);
                    if (event.defaultPrevented) return;
                    deleteToast();
                  },
                  className: cn(
                    classNames == null ? void 0 : classNames.actionButton,
                    toast == null
                      ? void 0
                      : (_toast_classNames8 = toast.classNames) == null
                        ? void 0
                        : _toast_classNames8.actionButton,
                  ),
                },
                toast.action.label,
              )
            : null,
      );
    };
    function getDocumentDirection() {
      if (typeof window === "undefined") return "ltr";
      if (typeof document === "undefined") return "ltr"; // For Fresh purpose
      const dirAttribute = document.documentElement.getAttribute("dir");
      if (dirAttribute === "auto" || !dirAttribute) {
        return window.getComputedStyle(document.documentElement).direction;
      }
      return dirAttribute;
    }
    function assignOffset(defaultOffset, mobileOffset) {
      const styles = {};
      [defaultOffset, mobileOffset].forEach((offset, index) => {
        const isMobile = index === 1;
        const prefix = isMobile ? "--mobile-offset" : "--offset";
        const defaultValue = isMobile ? MOBILE_VIEWPORT_OFFSET : VIEWPORT_OFFSET;
        function assignAll(offset) {
          ["top", "right", "bottom", "left"].forEach((key) => {
            styles[`${prefix}-${key}`] = typeof offset === "number" ? `${offset}px` : offset;
          });
        }
        if (typeof offset === "number" || typeof offset === "string") {
          assignAll(offset);
        } else if (typeof offset === "object") {
          ["top", "right", "bottom", "left"].forEach((key) => {
            if (offset[key] === undefined) {
              styles[`${prefix}-${key}`] = defaultValue;
            } else {
              styles[`${prefix}-${key}`] =
                typeof offset[key] === "number" ? `${offset[key]}px` : offset[key];
            }
          });
        } else {
          assignAll(defaultValue);
        }
      });
      return styles;
    }
    function useSonner() {
      const [activeToasts, setActiveToasts] =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useState([]);
      __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].useEffect(
        {
          "useSonner.useEffect": () => {
            return ToastState.subscribe(
              {
                "useSonner.useEffect": (toast) => {
                  if (toast.dismiss) {
                    setTimeout(
                      {
                        "useSonner.useEffect": () => {
                          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                            "default"
                          ].flushSync(
                            {
                              "useSonner.useEffect": () => {
                                setActiveToasts(
                                  {
                                    "useSonner.useEffect": (toasts) =>
                                      toasts.filter(
                                        {
                                          "useSonner.useEffect": (t) => t.id !== toast.id,
                                        }["useSonner.useEffect"],
                                      ),
                                  }["useSonner.useEffect"],
                                );
                              },
                            }["useSonner.useEffect"],
                          );
                        },
                      }["useSonner.useEffect"],
                    );
                    return;
                  }
                  // Prevent batching, temp solution.
                  setTimeout(
                    {
                      "useSonner.useEffect": () => {
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                          "default"
                        ].flushSync(
                          {
                            "useSonner.useEffect": () => {
                              setActiveToasts(
                                {
                                  "useSonner.useEffect": (toasts) => {
                                    const indexOfExistingToast = toasts.findIndex(
                                      {
                                        "useSonner.useEffect.indexOfExistingToast": (t) =>
                                          t.id === toast.id,
                                      }["useSonner.useEffect.indexOfExistingToast"],
                                    );
                                    // Update the toast if it already exists
                                    if (indexOfExistingToast !== -1) {
                                      return [
                                        ...toasts.slice(0, indexOfExistingToast),
                                        {
                                          ...toasts[indexOfExistingToast],
                                          ...toast,
                                        },
                                        ...toasts.slice(indexOfExistingToast + 1),
                                      ];
                                    }
                                    return [toast, ...toasts];
                                  },
                                }["useSonner.useEffect"],
                              );
                            },
                          }["useSonner.useEffect"],
                        );
                      },
                    }["useSonner.useEffect"],
                  );
                },
              }["useSonner.useEffect"],
            );
          },
        }["useSonner.useEffect"],
        [],
      );
      return {
        toasts: activeToasts,
      };
    }
    const Toaster =
      /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
        "default"
      ].forwardRef(function Toaster(props, ref) {
        const {
          id,
          invert,
          position = "bottom-right",
          hotkey = ["altKey", "KeyT"],
          expand,
          closeButton,
          className,
          offset,
          mobileOffset,
          theme = "light",
          richColors,
          duration,
          style,
          visibleToasts = VISIBLE_TOASTS_AMOUNT,
          toastOptions,
          dir = getDocumentDirection(),
          gap = GAP,
          icons,
          containerAriaLabel = "Notifications",
        } = props;
        const [toasts, setToasts] =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].useState([]);
        const filteredToasts =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].useMemo(
            {
              "Toaster.Toaster.useMemo[filteredToasts]": () => {
                if (id) {
                  return toasts.filter(
                    {
                      "Toaster.Toaster.useMemo[filteredToasts]": (toast) => toast.toasterId === id,
                    }["Toaster.Toaster.useMemo[filteredToasts]"],
                  );
                }
                return toasts.filter(
                  {
                    "Toaster.Toaster.useMemo[filteredToasts]": (toast) => !toast.toasterId,
                  }["Toaster.Toaster.useMemo[filteredToasts]"],
                );
              },
            }["Toaster.Toaster.useMemo[filteredToasts]"],
            [toasts, id],
          );
        const possiblePositions =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].useMemo(
            {
              "Toaster.Toaster.useMemo[possiblePositions]": () => {
                return Array.from(
                  new Set(
                    [position].concat(
                      filteredToasts
                        .filter(
                          {
                            "Toaster.Toaster.useMemo[possiblePositions]": (toast) => toast.position,
                          }["Toaster.Toaster.useMemo[possiblePositions]"],
                        )
                        .map(
                          {
                            "Toaster.Toaster.useMemo[possiblePositions]": (toast) => toast.position,
                          }["Toaster.Toaster.useMemo[possiblePositions]"],
                        ),
                    ),
                  ),
                );
              },
            }["Toaster.Toaster.useMemo[possiblePositions]"],
            [filteredToasts, position],
          );
        const [heights, setHeights] =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].useState([]);
        const [expanded, setExpanded] =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].useState(false);
        const [interacting, setInteracting] =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].useState(false);
        const [actualTheme, setActualTheme] =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].useState(
            theme !== "system"
              ? theme
              : typeof window !== "undefined"
                ? window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches
                  ? "dark"
                  : "light"
                : "light",
          );
        const listRef =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].useRef(null);
        const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
        const lastFocusedElementRef =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].useRef(null);
        const isFocusWithinRef =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].useRef(false);
        const removeToast =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "default"
          ].useCallback(
            {
              "Toaster.Toaster.useCallback[removeToast]": (toastToRemove) => {
                setToasts(
                  {
                    "Toaster.Toaster.useCallback[removeToast]": (toasts) => {
                      var _toasts_find;
                      if (
                        !((_toasts_find = toasts.find(
                          {
                            "Toaster.Toaster.useCallback[removeToast]": (toast) =>
                              toast.id === toastToRemove.id,
                          }["Toaster.Toaster.useCallback[removeToast]"],
                        )) == null
                          ? void 0
                          : _toasts_find.delete)
                      ) {
                        ToastState.dismiss(toastToRemove.id);
                      }
                      return toasts.filter(
                        {
                          "Toaster.Toaster.useCallback[removeToast]": ({ id }) =>
                            id !== toastToRemove.id,
                        }["Toaster.Toaster.useCallback[removeToast]"],
                      );
                    },
                  }["Toaster.Toaster.useCallback[removeToast]"],
                );
              },
            }["Toaster.Toaster.useCallback[removeToast]"],
            [],
          );
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useEffect(
          {
            "Toaster.Toaster.useEffect": () => {
              return ToastState.subscribe(
                {
                  "Toaster.Toaster.useEffect": (toast) => {
                    if (toast.dismiss) {
                      // Prevent batching of other state updates
                      requestAnimationFrame(
                        {
                          "Toaster.Toaster.useEffect": () => {
                            setToasts(
                              {
                                "Toaster.Toaster.useEffect": (toasts) =>
                                  toasts.map(
                                    {
                                      "Toaster.Toaster.useEffect": (t) =>
                                        t.id === toast.id
                                          ? {
                                              ...t,
                                              delete: true,
                                            }
                                          : t,
                                    }["Toaster.Toaster.useEffect"],
                                  ),
                              }["Toaster.Toaster.useEffect"],
                            );
                          },
                        }["Toaster.Toaster.useEffect"],
                      );
                      return;
                    }
                    // Prevent batching, temp solution.
                    setTimeout(
                      {
                        "Toaster.Toaster.useEffect": () => {
                          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                            "default"
                          ].flushSync(
                            {
                              "Toaster.Toaster.useEffect": () => {
                                setToasts(
                                  {
                                    "Toaster.Toaster.useEffect": (toasts) => {
                                      const indexOfExistingToast = toasts.findIndex(
                                        {
                                          "Toaster.Toaster.useEffect.indexOfExistingToast": (t) =>
                                            t.id === toast.id,
                                        }["Toaster.Toaster.useEffect.indexOfExistingToast"],
                                      );
                                      // Update the toast if it already exists
                                      if (indexOfExistingToast !== -1) {
                                        return [
                                          ...toasts.slice(0, indexOfExistingToast),
                                          {
                                            ...toasts[indexOfExistingToast],
                                            ...toast,
                                          },
                                          ...toasts.slice(indexOfExistingToast + 1),
                                        ];
                                      }
                                      return [toast, ...toasts];
                                    },
                                  }["Toaster.Toaster.useEffect"],
                                );
                              },
                            }["Toaster.Toaster.useEffect"],
                          );
                        },
                      }["Toaster.Toaster.useEffect"],
                    );
                  },
                }["Toaster.Toaster.useEffect"],
              );
            },
          }["Toaster.Toaster.useEffect"],
          [toasts],
        );
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useEffect(
          {
            "Toaster.Toaster.useEffect": () => {
              if (theme !== "system") {
                setActualTheme(theme);
                return;
              }
              if (theme === "system") {
                // check if current preference is dark
                if (
                  window.matchMedia &&
                  window.matchMedia("(prefers-color-scheme: dark)").matches
                ) {
                  // it's currently dark
                  setActualTheme("dark");
                } else {
                  // it's not dark
                  setActualTheme("light");
                }
              }
              if (typeof window === "undefined") return;
              const darkMediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
              try {
                // Chrome & Firefox
                darkMediaQuery.addEventListener(
                  "change",
                  {
                    "Toaster.Toaster.useEffect": ({ matches }) => {
                      if (matches) {
                        setActualTheme("dark");
                      } else {
                        setActualTheme("light");
                      }
                    },
                  }["Toaster.Toaster.useEffect"],
                );
              } catch (error) {
                // Safari < 14
                darkMediaQuery.addListener(
                  {
                    "Toaster.Toaster.useEffect": ({ matches }) => {
                      try {
                        if (matches) {
                          setActualTheme("dark");
                        } else {
                          setActualTheme("light");
                        }
                      } catch (e) {
                        console.error(e);
                      }
                    },
                  }["Toaster.Toaster.useEffect"],
                );
              }
            },
          }["Toaster.Toaster.useEffect"],
          [theme],
        );
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useEffect(
          {
            "Toaster.Toaster.useEffect": () => {
              // Ensure expanded is always false when no toasts are present / only one left
              if (toasts.length <= 1) {
                setExpanded(false);
              }
            },
          }["Toaster.Toaster.useEffect"],
          [toasts],
        );
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useEffect(
          {
            "Toaster.Toaster.useEffect": () => {
              const handleKeyDown = {
                "Toaster.Toaster.useEffect.handleKeyDown": (event) => {
                  var _listRef_current;
                  const isHotkeyPressed = hotkey.every(
                    {
                      "Toaster.Toaster.useEffect.handleKeyDown.isHotkeyPressed": (key) =>
                        event[key] || event.code === key,
                    }["Toaster.Toaster.useEffect.handleKeyDown.isHotkeyPressed"],
                  );
                  if (isHotkeyPressed) {
                    var _listRef_current1;
                    setExpanded(true);
                    (_listRef_current1 = listRef.current) == null
                      ? void 0
                      : _listRef_current1.focus();
                  }
                  if (
                    event.code === "Escape" &&
                    (document.activeElement === listRef.current ||
                      ((_listRef_current = listRef.current) == null
                        ? void 0
                        : _listRef_current.contains(document.activeElement)))
                  ) {
                    setExpanded(false);
                  }
                },
              }["Toaster.Toaster.useEffect.handleKeyDown"];
              document.addEventListener("keydown", handleKeyDown);
              return {
                "Toaster.Toaster.useEffect": () =>
                  document.removeEventListener("keydown", handleKeyDown),
              }["Toaster.Toaster.useEffect"];
            },
          }["Toaster.Toaster.useEffect"],
          [hotkey],
        );
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].useEffect(
          {
            "Toaster.Toaster.useEffect": () => {
              if (listRef.current) {
                return {
                  "Toaster.Toaster.useEffect": () => {
                    if (lastFocusedElementRef.current) {
                      lastFocusedElementRef.current.focus({
                        preventScroll: true,
                      });
                      lastFocusedElementRef.current = null;
                      isFocusWithinRef.current = false;
                    }
                  },
                }["Toaster.Toaster.useEffect"];
              }
            },
          }["Toaster.Toaster.useEffect"],
          [listRef.current],
        );
        return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "default"
        ].createElement(
          "section",
          {
            ref: ref,
            "aria-label": `${containerAriaLabel} ${hotkeyLabel}`,
            tabIndex: -1,
            "aria-live": "polite",
            "aria-relevant": "additions text",
            "aria-atomic": "false",
            suppressHydrationWarning: true,
          },
          possiblePositions.map((position, index) => {
            var _heights_;
            const [y, x] = position.split("-");
            if (!filteredToasts.length) return null;
            return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "default"
            ].createElement(
              "ol",
              {
                key: position,
                dir: dir === "auto" ? getDocumentDirection() : dir,
                tabIndex: -1,
                ref: listRef,
                className: className,
                "data-sonner-toaster": true,
                "data-sonner-theme": actualTheme,
                "data-y-position": y,
                "data-x-position": x,
                style: {
                  "--front-toast-height": `${((_heights_ = heights[0]) == null ? void 0 : _heights_.height) || 0}px`,
                  "--width": `${TOAST_WIDTH}px`,
                  "--gap": `${gap}px`,
                  ...style,
                  ...assignOffset(offset, mobileOffset),
                },
                onBlur: (event) => {
                  if (
                    isFocusWithinRef.current &&
                    !event.currentTarget.contains(event.relatedTarget)
                  ) {
                    isFocusWithinRef.current = false;
                    if (lastFocusedElementRef.current) {
                      lastFocusedElementRef.current.focus({
                        preventScroll: true,
                      });
                      lastFocusedElementRef.current = null;
                    }
                  }
                },
                onFocus: (event) => {
                  const isNotDismissible =
                    event.target instanceof HTMLElement &&
                    event.target.dataset.dismissible === "false";
                  if (isNotDismissible) return;
                  if (!isFocusWithinRef.current) {
                    isFocusWithinRef.current = true;
                    lastFocusedElementRef.current = event.relatedTarget;
                  }
                },
                onMouseEnter: () => setExpanded(true),
                onMouseMove: () => setExpanded(true),
                onMouseLeave: () => {
                  // Avoid setting expanded to false when interacting with a toast, e.g. swiping
                  if (!interacting) {
                    setExpanded(false);
                  }
                },
                onDragEnd: () => setExpanded(false),
                onPointerDown: (event) => {
                  const isNotDismissible =
                    event.target instanceof HTMLElement &&
                    event.target.dataset.dismissible === "false";
                  if (isNotDismissible) return;
                  setInteracting(true);
                },
                onPointerUp: () => setInteracting(false),
              },
              filteredToasts
                .filter((toast) => (!toast.position && index === 0) || toast.position === position)
                .map((toast, index) => {
                  var _toastOptions_duration, _toastOptions_closeButton;
                  return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                    "default"
                  ].createElement(Toast, {
                    key: toast.id,
                    icons: icons,
                    index: index,
                    toast: toast,
                    defaultRichColors: richColors,
                    duration:
                      (_toastOptions_duration =
                        toastOptions == null ? void 0 : toastOptions.duration) != null
                        ? _toastOptions_duration
                        : duration,
                    className: toastOptions == null ? void 0 : toastOptions.className,
                    descriptionClassName:
                      toastOptions == null ? void 0 : toastOptions.descriptionClassName,
                    invert: invert,
                    visibleToasts: visibleToasts,
                    closeButton:
                      (_toastOptions_closeButton =
                        toastOptions == null ? void 0 : toastOptions.closeButton) != null
                        ? _toastOptions_closeButton
                        : closeButton,
                    interacting: interacting,
                    position: position,
                    style: toastOptions == null ? void 0 : toastOptions.style,
                    unstyled: toastOptions == null ? void 0 : toastOptions.unstyled,
                    classNames: toastOptions == null ? void 0 : toastOptions.classNames,
                    cancelButtonStyle:
                      toastOptions == null ? void 0 : toastOptions.cancelButtonStyle,
                    actionButtonStyle:
                      toastOptions == null ? void 0 : toastOptions.actionButtonStyle,
                    closeButtonAriaLabel:
                      toastOptions == null ? void 0 : toastOptions.closeButtonAriaLabel,
                    removeToast: removeToast,
                    toasts: filteredToasts.filter((t) => t.position == toast.position),
                    heights: heights.filter((h) => h.position == toast.position),
                    setHeights: setHeights,
                    expandByDefault: expand,
                    gap: gap,
                    expanded: expanded,
                    swipeDirections: props.swipeDirections,
                  });
                }),
            );
          }),
        );
      });
  },
  "[project]/node_modules/next-themes/dist/index.mjs [app-client] (ecmascript)",
  (__turbopack_context__) => {
    "use strict";

    __turbopack_context__.s(["ThemeProvider", () => J, "useTheme", () => z]);
    var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ =
      __turbopack_context__.i(
        "[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)",
      );
    ("use client");
    var M = (e, i, s, u, m, a, l, h) => {
      let d = document.documentElement,
        w = ["light", "dark"];
      function p(n) {
        ((Array.isArray(e) ? e : [e]).forEach((y) => {
          let k = y === "class",
            S = k && a ? m.map((f) => a[f] || f) : m;
          k
            ? (d.classList.remove(...S), d.classList.add(a && a[n] ? a[n] : n))
            : d.setAttribute(y, n);
        }),
          R(n));
      }
      function R(n) {
        h && w.includes(n) && (d.style.colorScheme = n);
      }
      function c() {
        return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      }
      if (u) p(u);
      else
        try {
          let n = localStorage.getItem(i) || s,
            y = l && n === "system" ? c() : n;
          p(y);
        } catch (n) {}
    };
    var b = ["light", "dark"],
      I = "(prefers-color-scheme: dark)",
      O = typeof window == "undefined",
      x =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "createContext"
        ](void 0),
      U = {
        setTheme: (e) => {},
        themes: [],
      },
      z = () => {
        var e;
        return (e =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "useContext"
          ](x)) != null
          ? e
          : U;
      },
      J = (e) =>
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useContext"
        ](x)
          ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "createElement"
            ](
              __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
                "Fragment"
              ],
              null,
              e.children,
            )
          : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "createElement"
            ](V, {
              ...e,
            }),
      N = ["light", "dark"],
      V = ({
        forcedTheme: e,
        disableTransitionOnChange: i = !1,
        enableSystem: s = !0,
        enableColorScheme: u = !0,
        storageKey: m = "theme",
        themes: a = N,
        defaultTheme: l = s ? "system" : "light",
        attribute: h = "data-theme",
        value: d,
        children: w,
        nonce: p,
        scriptProps: R,
      }) => {
        let [c, n] =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "useState"
            ](
              {
                "V.useState": () => H(m, l),
              }["V.useState"],
            ),
          [T, y] =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "useState"
            ](
              {
                "V.useState": () => (c === "system" ? E() : c),
              }["V.useState"],
            ),
          k = d ? Object.values(d) : a,
          S =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "useCallback"
            ](
              {
                "V.useCallback[S]": (o) => {
                  let r = o;
                  if (!r) return;
                  o === "system" && s && (r = E());
                  let v = d ? d[r] : r,
                    C = i ? W(p) : null,
                    P = document.documentElement,
                    L = {
                      "V.useCallback[S].L": (g) => {
                        g === "class"
                          ? (P.classList.remove(...k), v && P.classList.add(v))
                          : g.startsWith("data-") &&
                            (v ? P.setAttribute(g, v) : P.removeAttribute(g));
                      },
                    }["V.useCallback[S].L"];
                  if ((Array.isArray(h) ? h.forEach(L) : L(h), u)) {
                    let g = b.includes(l) ? l : null,
                      D = b.includes(r) ? r : g;
                    P.style.colorScheme = D;
                  }
                  C == null || C();
                },
              }["V.useCallback[S]"],
              [p],
            ),
          f =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "useCallback"
            ](
              {
                "V.useCallback[f]": (o) => {
                  let r = typeof o == "function" ? o(c) : o;
                  n(r);
                  try {
                    localStorage.setItem(m, r);
                  } catch (v) {}
                },
              }["V.useCallback[f]"],
              [c],
            ),
          A =
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "useCallback"
            ](
              {
                "V.useCallback[A]": (o) => {
                  let r = E(o);
                  (y(r), c === "system" && s && !e && S("system"));
                },
              }["V.useCallback[A]"],
              [c, e],
            );
        (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "useEffect"
        ](
          {
            "V.useEffect": () => {
              let o = window.matchMedia(I);
              return (
                o.addListener(A),
                A(o),
                {
                  "V.useEffect": () => o.removeListener(A),
                }["V.useEffect"]
              );
            },
          }["V.useEffect"],
          [A],
        ),
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "useEffect"
          ](
            {
              "V.useEffect": () => {
                let o = {
                  "V.useEffect.o": (r) => {
                    r.key === m && (r.newValue ? n(r.newValue) : f(l));
                  },
                }["V.useEffect.o"];
                return (
                  window.addEventListener("storage", o),
                  {
                    "V.useEffect": () => window.removeEventListener("storage", o),
                  }["V.useEffect"]
                );
              },
            }["V.useEffect"],
            [f],
          ),
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "useEffect"
          ](
            {
              "V.useEffect": () => {
                S(e != null ? e : c);
              },
            }["V.useEffect"],
            [e, c],
          ));
        let Q =
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "useMemo"
          ](
            {
              "V.useMemo[Q]": () => ({
                theme: c,
                setTheme: f,
                forcedTheme: e,
                resolvedTheme: c === "system" ? T : c,
                themes: s ? [...a, "system"] : a,
                systemTheme: s ? T : void 0,
              }),
            }["V.useMemo[Q]"],
            [c, f, e, T, s, a],
          );
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "createElement"
        ](
          x.Provider,
          {
            value: Q,
          },
          __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
            "createElement"
          ](_, {
            forcedTheme: e,
            storageKey: m,
            attribute: h,
            enableSystem: s,
            enableColorScheme: u,
            defaultTheme: l,
            value: d,
            themes: a,
            nonce: p,
            scriptProps: R,
          }),
          w,
        );
      },
      _ =
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
          "memo"
        ](
          ({
            forcedTheme: e,
            storageKey: i,
            attribute: s,
            enableSystem: u,
            enableColorScheme: m,
            defaultTheme: a,
            value: l,
            themes: h,
            nonce: d,
            scriptProps: w,
          }) => {
            let p = JSON.stringify([s, i, a, e, h, l, u, m]).slice(1, -1);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__[
              "createElement"
            ]("script", {
              ...w,
              suppressHydrationWarning: !0,
              nonce: typeof window == "undefined" ? d : "",
              dangerouslySetInnerHTML: {
                __html: `(${M.toString()})(${p})`,
              },
            });
          },
        ),
      H = (e, i) => {
        if (O) return;
        let s;
        try {
          s = localStorage.getItem(e) || void 0;
        } catch (u) {}
        return s || i;
      },
      W = (e) => {
        let i = document.createElement("style");
        return (
          e && i.setAttribute("nonce", e),
          i.appendChild(
            document.createTextNode(
              "*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}",
            ),
          ),
          document.head.appendChild(i),
          () => {
            (window.getComputedStyle(document.body),
              setTimeout(() => {
                document.head.removeChild(i);
              }, 1));
          }
        );
      },
      E = (e) => (e || (e = window.matchMedia(I)), e.matches ? "dark" : "light");
  },
]);

//# sourceMappingURL=node_modules_21a6b95e._.js.map
