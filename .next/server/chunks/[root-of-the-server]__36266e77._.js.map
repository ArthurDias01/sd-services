{"version":3,"sources":["../../../src/app/api/upload/route.ts","../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../src/lib/r2.ts","../../../node_modules/nanostores/listen-keys/index.js","../../../node_modules/better-auth/src/client/focus-manager.ts","../../../node_modules/better-auth/src/client/broadcast-channel.ts","../../../node_modules/next/src/build/templates/app-route.ts","../../../node_modules/better-auth/src/client/online-manager.ts","../../../node_modules/nanostores/atom/index.js","../../../node_modules/nanostores/lifecycle/index.js","../../../node_modules/better-auth/src/client/fetch-plugins.ts","../../../node_modules/better-auth/src/client/parser.ts","../../../node_modules/better-auth/src/utils/is-atom.ts","../../../node_modules/better-auth/src/client/query.ts","../../../node_modules/better-auth/src/client/proxy.ts","../../../node_modules/better-auth/src/client/session-atom.ts","../../../node_modules/better-auth/src/client/session-refresh.ts","../../../src/lib/auth-client.ts","../../../node_modules/better-auth/src/client/react/index.ts","../../../node_modules/better-auth/src/client/config.ts","../../../node_modules/better-auth/src/client/react/react-store.ts"],"sourcesContent":["import { headers } from \"next/headers\";\nimport { NextResponse } from \"next/server\";\n\nimport { authClient } from \"@/lib/auth-client\";\nimport { uploadFile } from \"@/lib/r2\";\n\nasync function getAdminSession() {\n  type SessionData = { user?: { email?: string | null } } | null;\n  let session: SessionData = null;\n  try {\n    const result = await authClient.getSession({\n      fetchOptions: { headers: await headers(), throw: false },\n    });\n    session =\n      result && typeof result === \"object\" && \"data\" in result\n        ? (result as { data: SessionData }).data\n        : null;\n  } catch {\n    return null;\n  }\n\n  if (!session?.user) return null;\n\n  const allowed = process.env.CMS_ALLOWED_EMAILS;\n  if (allowed) {\n    const emails = allowed.split(\",\").map((e) => e.trim().toLowerCase());\n    if (!emails.includes(session.user.email?.toLowerCase() ?? \"\")) return null;\n  }\n\n  return session;\n}\n\nexport async function POST(request: Request) {\n  const session = await getAdminSession();\n  if (!session) {\n    return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n  }\n\n  let formData: FormData;\n  try {\n    formData = await request.formData();\n  } catch {\n    return NextResponse.json({ error: \"Invalid form data\" }, { status: 400 });\n  }\n\n  // Accept either a single \"file\" or multiple \"files[]\"\n  const rawFiles = formData.getAll(\"files\");\n  const single = formData.get(\"file\");\n  const allFiles: File[] = [\n    ...(rawFiles.filter((f) => f instanceof File) as File[]),\n    ...(single instanceof File ? [single] : []),\n  ];\n\n  if (allFiles.length === 0) {\n    return NextResponse.json({ error: \"No files provided\" }, { status: 400 });\n  }\n\n  try {\n    const results = await Promise.all(\n      allFiles.map((file) => uploadFile(file, \"uploads\")),\n    );\n    // Single file → { url } for backwards compat; multiple → { urls }\n    if (allFiles.length === 1) {\n      return NextResponse.json({ url: results[0]!.url, urls: [results[0]!.url] });\n    }\n    return NextResponse.json({ urls: results.map((r) => r.url) });\n  } catch (err) {\n    console.error(\"Upload error:\", err);\n    return NextResponse.json({ error: \"Upload failed\" }, { status: 500 });\n  }\n}\n","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/upload/route\",\n        pathname: \"/api/upload\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/upload/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/upload/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        const silenceLog = false;\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, silenceLog, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","import { PutObjectCommand, S3Client } from \"@aws-sdk/client-s3\";\n\nfunction getR2Client(): S3Client | null {\n  const accountId = process.env.R2_ACCOUNT_ID;\n  const accessKeyId = process.env.R2_ACCESS_KEY_ID;\n  const secretAccessKey = process.env.R2_SECRET_ACCESS_KEY;\n\n  if (!accountId || !accessKeyId || !secretAccessKey) return null;\n\n  return new S3Client({\n    region: \"auto\",\n    // The S3-compatible API endpoint — used only for writes, never for public reads.\n    endpoint: `https://${accountId}.r2.cloudflarestorage.com`,\n    credentials: { accessKeyId, secretAccessKey },\n    // Force path-style so the SDK routes correctly: endpoint/{bucket}/{key}\n    forcePathStyle: true,\n  });\n}\n\nexport type UploadResult = { url: string };\n\n/**\n * Upload a file buffer to R2. Falls back to local /public/uploads when R2\n * env vars are not configured (development convenience).\n *\n * R2_PUBLIC_URL must be the **public** URL root for your bucket, e.g.:\n *   - https://pub-<hash>.r2.dev          (R2 managed public access)\n *   - https://images.yourdomain.com      (custom domain)\n *\n * Do NOT set it to the S3-compatible storage endpoint\n * (*.r2.cloudflarestorage.com) — that requires auth and browsers cannot\n * load images from it directly.\n */\nexport async function uploadFile(\n  file: File,\n  folder = \"uploads\",\n): Promise<UploadResult> {\n  const ext = file.name.includes(\".\")\n    ? file.name.split(\".\").pop()!.toLowerCase()\n    : \"bin\";\n  const key = `${folder}/${crypto.randomUUID()}.${ext}`;\n  const buffer = Buffer.from(await file.arrayBuffer());\n\n  const r2 = getR2Client();\n\n  if (r2) {\n    const bucket = process.env.R2_BUCKET_NAME;\n    const publicUrl = process.env.R2_PUBLIC_URL;\n\n    if (!bucket || !publicUrl) {\n      throw new Error(\n        \"R2_BUCKET_NAME and R2_PUBLIC_URL must be set when using R2\",\n      );\n    }\n\n    // Guard against accidentally using the private API endpoint as the public URL\n    if (publicUrl.includes(\"r2.cloudflarestorage.com\")) {\n      throw new Error(\n        \"R2_PUBLIC_URL must be your bucket's public URL (pub-xxx.r2.dev or custom domain), \" +\n          \"not the S3-compatible API endpoint (*.r2.cloudflarestorage.com). \" +\n          \"Enable public access in your R2 bucket settings to get the public URL.\",\n      );\n    }\n\n    await r2.send(\n      new PutObjectCommand({\n        Bucket: bucket,\n        Key: key,\n        Body: buffer,\n        ContentType: file.type || \"application/octet-stream\",\n        ContentLength: buffer.byteLength,\n      }),\n    );\n\n    const base = publicUrl.replace(/\\/$/, \"\");\n    return { url: `${base}/${key}` };\n  }\n\n  // Local fallback — save to public/uploads/\n  const { writeFile, mkdir } = await import(\"node:fs/promises\");\n  const nodePath = await import(\"node:path\");\n  const uploadDir = nodePath.join(process.cwd(), \"public\", \"uploads\");\n  await mkdir(uploadDir, { recursive: true });\n  const fileName = `${crypto.randomUUID()}.${ext}`;\n  await writeFile(nodePath.join(uploadDir, fileName), buffer);\n  return { url: `/uploads/${fileName}` };\n}\n","export function listenKeys($store, keys, listener) {\n  let keysSet = new Set(keys).add(undefined)\n  return $store.listen((value, oldValue, changed) => {\n    if (keysSet.has(changed)) {\n      listener(value, oldValue, changed)\n    }\n  })\n}\n\nexport function subscribeKeys($store, keys, listener) {\n  let unbind = listenKeys($store, keys, listener)\n  listener($store.value)\n  return unbind\n}\n","export type FocusListener = (focused: boolean) => void;\n\nexport const kFocusManager = Symbol.for(\"better-auth:focus-manager\");\n\nexport interface FocusManager {\n\tsetFocused(focused: boolean): void;\n\tsubscribe(listener: FocusListener): () => void;\n\tsetup(): () => void;\n}\n\nclass WindowFocusManager implements FocusManager {\n\tlisteners = new Set<FocusListener>();\n\n\tsubscribe(listener: FocusListener) {\n\t\tthis.listeners.add(listener);\n\t\treturn () => {\n\t\t\tthis.listeners.delete(listener);\n\t\t};\n\t}\n\n\tsetFocused(focused: boolean) {\n\t\tthis.listeners.forEach((listener) => listener(focused));\n\t}\n\n\tsetup() {\n\t\tif (\n\t\t\ttypeof window === \"undefined\" ||\n\t\t\ttypeof document === \"undefined\" ||\n\t\t\ttypeof window.addEventListener === \"undefined\"\n\t\t) {\n\t\t\treturn () => {};\n\t\t}\n\n\t\tconst visibilityHandler = () => {\n\t\t\tif (document.visibilityState === \"visible\") {\n\t\t\t\tthis.setFocused(true);\n\t\t\t}\n\t\t};\n\n\t\tdocument.addEventListener(\"visibilitychange\", visibilityHandler, false);\n\n\t\treturn () => {\n\t\t\tdocument.removeEventListener(\n\t\t\t\t\"visibilitychange\",\n\t\t\t\tvisibilityHandler,\n\t\t\t\tfalse,\n\t\t\t);\n\t\t};\n\t}\n}\n\nexport function getGlobalFocusManager() {\n\tif (!(globalThis as any)[kFocusManager]) {\n\t\t(globalThis as any)[kFocusManager] = new WindowFocusManager();\n\t}\n\treturn (globalThis as any)[kFocusManager] as FocusManager;\n}\n","export interface BroadcastMessage {\n\tevent?: \"session\" | undefined;\n\tdata?: { trigger?: \"signout\" | \"getSession\" | \"updateUser\" } | undefined;\n\tclientId: string;\n\ttimestamp: number;\n}\n\nexport type BroadcastListener = (message: BroadcastMessage) => void;\n\nexport const kBroadcastChannel = Symbol.for(\"better-auth:broadcast-channel\");\n\nconst now = () => Math.floor(Date.now() / 1000);\n\nexport interface BroadcastChannel {\n\tpost(message: Record<string, unknown>): void;\n\tsubscribe(listener: BroadcastListener): () => void;\n\tsetup(): () => void;\n}\n\nclass WindowBroadcastChannel implements BroadcastChannel {\n\tlisteners = new Set<BroadcastListener>();\n\tprivate name: string;\n\n\tconstructor(name = \"better-auth.message\") {\n\t\tthis.name = name;\n\t}\n\n\tsubscribe(listener: BroadcastListener) {\n\t\tthis.listeners.add(listener);\n\t\treturn () => {\n\t\t\tthis.listeners.delete(listener);\n\t\t};\n\t}\n\n\tpost(message: Record<string, unknown>) {\n\t\tif (typeof window === \"undefined\") return;\n\t\ttry {\n\t\t\tlocalStorage.setItem(\n\t\t\t\tthis.name,\n\t\t\t\tJSON.stringify({ ...message, timestamp: now() }),\n\t\t\t);\n\t\t} catch {}\n\t}\n\n\tsetup() {\n\t\tif (\n\t\t\ttypeof window === \"undefined\" ||\n\t\t\ttypeof window.addEventListener === \"undefined\"\n\t\t) {\n\t\t\treturn () => {};\n\t\t}\n\n\t\tconst handler = (event: StorageEvent) => {\n\t\t\tif (event.key !== this.name) return;\n\t\t\tconst message: BroadcastMessage = JSON.parse(event.newValue ?? \"{}\");\n\t\t\tif (message?.event !== \"session\" || !message?.data) return;\n\n\t\t\tthis.listeners.forEach((listener) => listener(message));\n\t\t};\n\n\t\twindow.addEventListener(\"storage\", handler);\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"storage\", handler);\n\t\t};\n\t}\n}\n\nexport function getGlobalBroadcastChannel(name = \"better-auth.message\") {\n\tif (!(globalThis as any)[kBroadcastChannel]) {\n\t\t(globalThis as any)[kBroadcastChannel] = new WindowBroadcastChannel(name);\n\t}\n\treturn (globalThis as any)[kBroadcastChannel] as BroadcastChannel;\n}\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setManifestsSingleton } from '../../server/app-render/manifests-singleton'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (\n        error,\n        _request,\n        errorContext,\n        silenceLog\n      ) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          silenceLog,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            const silenceLog = false\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              silenceLog,\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      const silenceLog = false\n      await routeModule.onRequestError(\n        req,\n        err,\n        {\n          routerKind: 'App Router',\n          routePath: normalizedSrcPage,\n          routeType: 'route',\n          revalidateReason: getRevalidateReason({\n            isStaticGeneration,\n            isOnDemandRevalidate,\n          }),\n        },\n        silenceLog,\n        routerServerContext\n      )\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n","export type OnlineListener = (online: boolean) => void;\n\nexport const kOnlineManager = Symbol.for(\"better-auth:online-manager\");\n\nexport interface OnlineManager {\n\tsetOnline(online: boolean): void;\n\tisOnline: boolean;\n\n\tsubscribe(listener: OnlineListener): () => void;\n\tsetup(): () => void;\n}\n\nclass WindowOnlineManager implements OnlineManager {\n\tlisteners = new Set<OnlineListener>();\n\tisOnline = typeof navigator !== \"undefined\" ? navigator.onLine : true;\n\n\tsubscribe(listener: OnlineListener) {\n\t\tthis.listeners.add(listener);\n\t\treturn () => {\n\t\t\tthis.listeners.delete(listener);\n\t\t};\n\t}\n\n\tsetOnline(online: boolean) {\n\t\tthis.isOnline = online;\n\t\tthis.listeners.forEach((listener) => listener(online));\n\t}\n\n\tsetup() {\n\t\tif (\n\t\t\ttypeof window === \"undefined\" ||\n\t\t\ttypeof window.addEventListener === \"undefined\"\n\t\t) {\n\t\t\treturn () => {};\n\t\t}\n\n\t\tconst onOnline = () => this.setOnline(true);\n\t\tconst onOffline = () => this.setOnline(false);\n\n\t\twindow.addEventListener(\"online\", onOnline, false);\n\t\twindow.addEventListener(\"offline\", onOffline, false);\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"online\", onOnline, false);\n\t\t\twindow.removeEventListener(\"offline\", onOffline, false);\n\t\t};\n\t}\n}\n\nexport function getGlobalOnlineManager() {\n\tif (!(globalThis as any)[kOnlineManager]) {\n\t\t(globalThis as any)[kOnlineManager] = new WindowOnlineManager();\n\t}\n\treturn (globalThis as any)[kOnlineManager] as OnlineManager;\n}\n","import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\nlet lqIndex = 0\nconst QUEUE_ITEMS_PER_LISTENER = 4\nexport let epoch = 0\n\n/* @__NO_SIDE_EFFECTS__ */\nexport const atom = initialValue => {\n  let listeners = []\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})()\n      }\n      return $atom.value\n    },\n    lc: 0,\n    listen(listener) {\n      $atom.lc = listeners.push(listener)\n\n      return () => {\n        for (\n          let i = lqIndex + QUEUE_ITEMS_PER_LISTENER;\n          i < listenerQueue.length;\n\n        ) {\n          if (listenerQueue[i] === listener) {\n            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER)\n          } else {\n            i += QUEUE_ITEMS_PER_LISTENER\n          }\n        }\n\n        let index = listeners.indexOf(listener)\n        if (~index) {\n          listeners.splice(index, 1)\n          if (!--$atom.lc) $atom.off()\n        }\n      }\n    },\n    notify(oldValue, changedKey) {\n      epoch++\n      let runListenerQueue = !listenerQueue.length\n      for (let listener of listeners) {\n        listenerQueue.push(listener, $atom.value, oldValue, changedKey)\n      }\n\n      if (runListenerQueue) {\n        for (\n          lqIndex = 0;\n          lqIndex < listenerQueue.length;\n          lqIndex += QUEUE_ITEMS_PER_LISTENER\n        ) {\n          listenerQueue[lqIndex](\n            listenerQueue[lqIndex + 1],\n            listenerQueue[lqIndex + 2],\n            listenerQueue[lqIndex + 3]\n          )\n        }\n        listenerQueue.length = 0\n      }\n    },\n    /* It will be called on last listener unsubscribing.\n       We will redefine it in onMount and onStop. */\n    off() {},\n    set(newValue) {\n      let oldValue = $atom.value\n      if (oldValue !== newValue) {\n        $atom.value = newValue\n        $atom.notify(oldValue)\n      }\n    },\n    subscribe(listener) {\n      let unbind = $atom.listen(listener)\n      listener($atom.value)\n      return unbind\n    },\n    value: initialValue\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = []\n      $atom.lc = 0\n      $atom.off()\n    }\n  }\n\n  return $atom\n}\n\nexport const readonlyType = store => store\n","import { clean } from '../clean-stores/index.js'\n\nconst START = 0\nconst STOP = 1\nconst SET = 2\nconst NOTIFY = 3\nconst MOUNT = 5\nconst UNMOUNT = 6\nconst REVERT_MUTATION = 10\n\nexport let on = (object, listener, eventKey, mutateStore) => {\n  object.events = object.events || {}\n  if (!object.events[eventKey + REVERT_MUTATION]) {\n    object.events[eventKey + REVERT_MUTATION] = mutateStore(eventProps => {\n      // eslint-disable-next-line no-sequences\n      object.events[eventKey].reduceRight((event, l) => (l(event), event), {\n        shared: {},\n        ...eventProps\n      })\n    })\n  }\n  object.events[eventKey] = object.events[eventKey] || []\n  object.events[eventKey].push(listener)\n  return () => {\n    let currentListeners = object.events[eventKey]\n    let index = currentListeners.indexOf(listener)\n    currentListeners.splice(index, 1)\n    if (!currentListeners.length) {\n      delete object.events[eventKey]\n      object.events[eventKey + REVERT_MUTATION]()\n      delete object.events[eventKey + REVERT_MUTATION]\n    }\n  }\n}\n\nexport let onStart = ($store, listener) =>\n  on($store, listener, START, runListeners => {\n    let originListen = $store.listen\n    $store.listen = arg => {\n      if (!$store.lc && !$store.starting) {\n        $store.starting = true\n        runListeners()\n        delete $store.starting\n      }\n      return originListen(arg)\n    }\n    return () => {\n      $store.listen = originListen\n    }\n  })\n\nexport let onStop = ($store, listener) =>\n  on($store, listener, STOP, runListeners => {\n    let originOff = $store.off\n    $store.off = () => {\n      runListeners()\n      originOff()\n    }\n    return () => {\n      $store.off = originOff\n    }\n  })\n\nexport let onSet = ($store, listener) =>\n  on($store, listener, SET, runListeners => {\n    let originSet = $store.set\n    let originSetKey = $store.setKey\n    if ($store.setKey) {\n      $store.setKey = (changed, changedValue) => {\n        let isAborted\n        let abort = () => {\n          isAborted = true\n        }\n\n        runListeners({\n          abort,\n          changed,\n          newValue: { ...$store.value, [changed]: changedValue }\n        })\n        if (!isAborted) return originSetKey(changed, changedValue)\n      }\n    }\n    $store.set = newValue => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, newValue })\n      if (!isAborted) return originSet(newValue)\n    }\n    return () => {\n      $store.set = originSet\n      $store.setKey = originSetKey\n    }\n  })\n\nexport let onNotify = ($store, listener) =>\n  on($store, listener, NOTIFY, runListeners => {\n    let originNotify = $store.notify\n    $store.notify = (oldValue, changed) => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, changed, oldValue })\n      if (!isAborted) return originNotify(oldValue, changed)\n    }\n    return () => {\n      $store.notify = originNotify\n    }\n  })\n\nexport let STORE_UNMOUNT_DELAY = 1000\n\nexport let onMount = ($store, initialize) => {\n  let listener = payload => {\n    let destroy = initialize(payload)\n    if (destroy) $store.events[UNMOUNT].push(destroy)\n  }\n  return on($store, listener, MOUNT, runListeners => {\n    let originListen = $store.listen\n    $store.listen = (...args) => {\n      if (!$store.lc && !$store.active) {\n        $store.active = true\n        runListeners()\n      }\n      return originListen(...args)\n    }\n\n    let originOff = $store.off\n    $store.events[UNMOUNT] = []\n    $store.off = () => {\n      originOff()\n      setTimeout(() => {\n        if ($store.active && !$store.lc) {\n          $store.active = false\n          for (let destroy of $store.events[UNMOUNT]) destroy()\n          $store.events[UNMOUNT] = []\n        }\n      }, STORE_UNMOUNT_DELAY)\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      let originClean = $store[clean]\n      $store[clean] = () => {\n        for (let destroy of $store.events[UNMOUNT]) destroy()\n        $store.events[UNMOUNT] = []\n        $store.active = false\n        originClean()\n      }\n    }\n\n    return () => {\n      $store.listen = originListen\n      $store.off = originOff\n    }\n  })\n}\n","import type { BetterFetchPlugin } from \"@better-fetch/fetch\";\n\nexport const redirectPlugin = {\n\tid: \"redirect\",\n\tname: \"Redirect\",\n\thooks: {\n\t\tonSuccess(context) {\n\t\t\tif (context.data?.url && context.data?.redirect) {\n\t\t\t\tif (typeof window !== \"undefined\" && window.location) {\n\t\t\t\t\tif (window.location) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twindow.location.href = context.data.url;\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t},\n} satisfies BetterFetchPlugin;\n","const PROTO_POLLUTION_PATTERNS = {\n\tproto:\n\t\t/\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/,\n\tconstructor:\n\t\t/\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/,\n\tprotoShort: /\"__proto__\"\\s*:/,\n\tconstructorShort: /\"constructor\"\\s*:/,\n} as const;\n\nconst JSON_SIGNATURE =\n\t/^\\s*[\"[{]|^\\s*-?\\d{1,16}(\\.\\d{1,17})?([Ee][+-]?\\d+)?\\s*$/;\n\nconst SPECIAL_VALUES = {\n\ttrue: true,\n\tfalse: false,\n\tnull: null,\n\tundefined: undefined,\n\tnan: Number.NaN,\n\tinfinity: Number.POSITIVE_INFINITY,\n\t\"-infinity\": Number.NEGATIVE_INFINITY,\n} as const;\n\nconst ISO_DATE_REGEX =\n\t/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{1,7}))?(?:Z|([+-])(\\d{2}):(\\d{2}))$/;\n\ntype ParseOptions = {\n\t/** Throw errors instead of returning the original value */\n\tstrict?: boolean | undefined;\n\t/** Log warnings when suspicious patterns are detected */\n\twarnings?: boolean | undefined;\n\t/** Custom reviver function */\n\treviver?: ((key: string, value: any) => any) | undefined;\n\t/** Automatically convert ISO date strings to Date objects */\n\tparseDates?: boolean | undefined;\n};\n\nfunction isValidDate(date: Date): boolean {\n\treturn date instanceof Date && !isNaN(date.getTime());\n}\n\nfunction parseISODate(value: string): Date | null {\n\tconst match = ISO_DATE_REGEX.exec(value);\n\tif (!match) return null;\n\n\tconst [\n\t\t,\n\t\tyear,\n\t\tmonth,\n\t\tday,\n\t\thour,\n\t\tminute,\n\t\tsecond,\n\t\tms,\n\t\toffsetSign,\n\t\toffsetHour,\n\t\toffsetMinute,\n\t] = match;\n\n\tconst date = new Date(\n\t\tDate.UTC(\n\t\t\tparseInt(year!, 10),\n\t\t\tparseInt(month!, 10) - 1,\n\t\t\tparseInt(day!, 10),\n\t\t\tparseInt(hour!, 10),\n\t\t\tparseInt(minute!, 10),\n\t\t\tparseInt(second!, 10),\n\t\t\tms ? parseInt(ms.padEnd(3, \"0\"), 10) : 0,\n\t\t),\n\t);\n\n\tif (offsetSign) {\n\t\tconst offset =\n\t\t\t(parseInt(offsetHour!, 10) * 60 + parseInt(offsetMinute!, 10)) *\n\t\t\t(offsetSign === \"+\" ? -1 : 1);\n\t\tdate.setUTCMinutes(date.getUTCMinutes() + offset);\n\t}\n\n\treturn isValidDate(date) ? date : null;\n}\n\nfunction betterJSONParse<T = unknown>(\n\tvalue: unknown,\n\toptions: ParseOptions = {},\n): T {\n\tconst {\n\t\tstrict = false,\n\t\twarnings = false,\n\t\treviver,\n\t\tparseDates = true,\n\t} = options;\n\n\tif (typeof value !== \"string\") {\n\t\treturn value as T;\n\t}\n\n\tconst trimmed = value.trim();\n\n\tif (\n\t\ttrimmed.length > 0 &&\n\t\ttrimmed[0] === '\"' &&\n\t\ttrimmed.endsWith('\"') &&\n\t\t!trimmed.slice(1, -1).includes('\"')\n\t) {\n\t\treturn trimmed.slice(1, -1) as T;\n\t}\n\n\tconst lowerValue = trimmed.toLowerCase();\n\tif (lowerValue.length <= 9 && lowerValue in SPECIAL_VALUES) {\n\t\treturn SPECIAL_VALUES[lowerValue as keyof typeof SPECIAL_VALUES] as T;\n\t}\n\n\tif (!JSON_SIGNATURE.test(trimmed)) {\n\t\tif (strict) {\n\t\t\tthrow new SyntaxError(\"[better-json] Invalid JSON\");\n\t\t}\n\t\treturn value as T;\n\t}\n\n\tconst hasProtoPattern = Object.entries(PROTO_POLLUTION_PATTERNS).some(\n\t\t([key, pattern]) => {\n\t\t\tconst matches = pattern.test(trimmed);\n\t\t\tif (matches && warnings) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[better-json] Detected potential prototype pollution attempt using ${key} pattern`,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn matches;\n\t\t},\n\t);\n\n\tif (hasProtoPattern && strict) {\n\t\tthrow new Error(\n\t\t\t\"[better-json] Potential prototype pollution attempt detected\",\n\t\t);\n\t}\n\n\ttry {\n\t\tconst secureReviver = (key: string, value: any) => {\n\t\t\tif (\n\t\t\t\tkey === \"__proto__\" ||\n\t\t\t\t(key === \"constructor\" &&\n\t\t\t\t\tvalue &&\n\t\t\t\t\ttypeof value === \"object\" &&\n\t\t\t\t\t\"prototype\" in value)\n\t\t\t) {\n\t\t\t\tif (warnings) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[better-json] Dropping \"${key}\" key to prevent prototype pollution`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (parseDates && typeof value === \"string\") {\n\t\t\t\tconst date = parseISODate(value);\n\t\t\t\tif (date) {\n\t\t\t\t\treturn date;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reviver ? reviver(key, value) : value;\n\t\t};\n\n\t\treturn JSON.parse(trimmed, secureReviver);\n\t} catch (error) {\n\t\tif (strict) {\n\t\t\tthrow error;\n\t\t}\n\t\treturn value as T;\n\t}\n}\n\nexport function parseJSON<T = unknown>(\n\tvalue: unknown,\n\toptions: ParseOptions = { strict: true },\n): T {\n\treturn betterJSONParse<T>(value, options);\n}\n","import type { Atom } from \"nanostores\";\n\nexport function isAtom(value: unknown): value is Atom<unknown> {\n\treturn (\n\t\ttypeof value === \"object\" &&\n\t\tvalue !== null &&\n\t\t\"get\" in value &&\n\t\ttypeof (value as any).get === \"function\" &&\n\t\t\"lc\" in value &&\n\t\ttypeof (value as any).lc === \"number\"\n\t);\n}\n","import type { ClientFetchOption } from \"@better-auth/core\";\nimport type { BetterFetch, BetterFetchError } from \"@better-fetch/fetch\";\nimport type { PreinitializedWritableAtom } from \"nanostores\";\nimport { atom, onMount } from \"nanostores\";\nimport type { SessionQueryParams } from \"./types\";\n\n// SSR detection\nconst isServer = () => typeof window === \"undefined\";\n\nexport type AuthQueryAtom<T> = PreinitializedWritableAtom<{\n\tdata: null | T;\n\terror: null | BetterFetchError;\n\tisPending: boolean;\n\tisRefetching: boolean;\n\trefetch: (\n\t\tqueryParams?: { query?: SessionQueryParams } | undefined,\n\t) => Promise<void>;\n}>;\n\nexport const useAuthQuery = <T>(\n\tinitializedAtom:\n\t\t| PreinitializedWritableAtom<any>\n\t\t| PreinitializedWritableAtom<any>[],\n\tpath: string,\n\t$fetch: BetterFetch,\n\toptions?:\n\t\t| (\n\t\t\t\t| ((value: {\n\t\t\t\t\t\tdata: null | T;\n\t\t\t\t\t\terror: null | BetterFetchError;\n\t\t\t\t\t\tisPending: boolean;\n\t\t\t\t  }) => ClientFetchOption)\n\t\t\t\t| ClientFetchOption\n\t\t  )\n\t\t| undefined,\n) => {\n\tconst value: AuthQueryAtom<T> = atom({\n\t\tdata: null,\n\t\terror: null,\n\t\tisPending: true,\n\t\tisRefetching: false,\n\t\trefetch: (queryParams) => fn(queryParams),\n\t});\n\n\tconst fn = async (\n\t\tqueryParams?: { query?: SessionQueryParams } | undefined,\n\t) => {\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tconst opts =\n\t\t\t\ttypeof options === \"function\"\n\t\t\t\t\t? options({\n\t\t\t\t\t\t\tdata: value.get().data,\n\t\t\t\t\t\t\terror: value.get().error,\n\t\t\t\t\t\t\tisPending: value.get().isPending,\n\t\t\t\t\t\t})\n\t\t\t\t\t: options;\n\n\t\t\t$fetch<T>(path, {\n\t\t\t\t...opts,\n\t\t\t\tquery: {\n\t\t\t\t\t...opts?.query,\n\t\t\t\t\t...queryParams?.query,\n\t\t\t\t},\n\t\t\t\tasync onSuccess(context) {\n\t\t\t\t\tvalue.set({\n\t\t\t\t\t\tdata: context.data,\n\t\t\t\t\t\terror: null,\n\t\t\t\t\t\tisPending: false,\n\t\t\t\t\t\tisRefetching: false,\n\t\t\t\t\t\trefetch: value.value.refetch,\n\t\t\t\t\t});\n\t\t\t\t\tawait opts?.onSuccess?.(context);\n\t\t\t\t},\n\t\t\t\tasync onError(context) {\n\t\t\t\t\tconst { request } = context;\n\t\t\t\t\tconst retryAttempts =\n\t\t\t\t\t\ttypeof request.retry === \"number\"\n\t\t\t\t\t\t\t? request.retry\n\t\t\t\t\t\t\t: request.retry?.attempts;\n\t\t\t\t\tconst retryAttempt = request.retryAttempt || 0;\n\t\t\t\t\tif (retryAttempts && retryAttempt < retryAttempts) return;\n\t\t\t\t\tvalue.set({\n\t\t\t\t\t\terror: context.error,\n\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\tisPending: false,\n\t\t\t\t\t\tisRefetching: false,\n\t\t\t\t\t\trefetch: value.value.refetch,\n\t\t\t\t\t});\n\t\t\t\t\tawait opts?.onError?.(context);\n\t\t\t\t},\n\t\t\t\tasync onRequest(context) {\n\t\t\t\t\tconst currentValue = value.get();\n\t\t\t\t\tvalue.set({\n\t\t\t\t\t\tisPending: currentValue.data === null,\n\t\t\t\t\t\tdata: currentValue.data,\n\t\t\t\t\t\terror: null,\n\t\t\t\t\t\tisRefetching: true,\n\t\t\t\t\t\trefetch: value.value.refetch,\n\t\t\t\t\t});\n\t\t\t\t\tawait opts?.onRequest?.(context);\n\t\t\t\t},\n\t\t\t})\n\t\t\t\t.catch((error) => {\n\t\t\t\t\tvalue.set({\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\tisPending: false,\n\t\t\t\t\t\tisRefetching: false,\n\t\t\t\t\t\trefetch: value.value.refetch,\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.finally(() => {\n\t\t\t\t\tresolve(void 0);\n\t\t\t\t});\n\t\t});\n\t};\n\tinitializedAtom = Array.isArray(initializedAtom)\n\t\t? initializedAtom\n\t\t: [initializedAtom];\n\tlet isMounted = false;\n\n\tfor (const initAtom of initializedAtom) {\n\t\tinitAtom.subscribe(async () => {\n\t\t\tif (isServer()) {\n\t\t\t\t// On server, don't trigger fetch\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isMounted) {\n\t\t\t\tawait fn();\n\t\t\t} else {\n\t\t\t\tonMount(value, () => {\n\t\t\t\t\tconst timeoutId = setTimeout(async () => {\n\t\t\t\t\t\tif (!isMounted) {\n\t\t\t\t\t\t\tawait fn();\n\t\t\t\t\t\t\tisMounted = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 0);\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tvalue.off();\n\t\t\t\t\t\tinitAtom.off();\n\t\t\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\treturn value;\n};\n","import type {\n\tBetterAuthClientPlugin,\n\tClientAtomListener,\n\tClientFetchOption,\n} from \"@better-auth/core\";\nimport type { BetterFetch } from \"@better-fetch/fetch\";\nimport type { Atom } from \"nanostores\";\nimport { isAtom } from \"../utils/is-atom\";\nimport type { ProxyRequest } from \"./path-to-object\";\n\nfunction getMethod(\n\tpath: string,\n\tknownPathMethods: Record<string, \"POST\" | \"GET\">,\n\targs:\n\t\t| {\n\t\t\t\tfetchOptions?: ClientFetchOption | undefined;\n\t\t\t\tquery?: Record<string, any> | undefined;\n\t\t  }\n\t\t| undefined,\n) {\n\tconst method = knownPathMethods[path];\n\tconst { fetchOptions, query: _query, ...body } = args || {};\n\tif (method) {\n\t\treturn method;\n\t}\n\tif (fetchOptions?.method) {\n\t\treturn fetchOptions.method;\n\t}\n\tif (body && Object.keys(body).length > 0) {\n\t\treturn \"POST\";\n\t}\n\treturn \"GET\";\n}\n\nexport function createDynamicPathProxy<T extends Record<string, any>>(\n\troutes: T,\n\tclient: BetterFetch,\n\tknownPathMethods: Record<string, \"POST\" | \"GET\">,\n\tatoms: Record<string, Atom>,\n\tatomListeners: BetterAuthClientPlugin[\"atomListeners\"],\n): T {\n\tfunction createProxy(path: string[] = []): any {\n\t\treturn new Proxy(function () {}, {\n\t\t\tget(_, prop) {\n\t\t\t\tif (typeof prop !== \"string\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (prop === \"then\" || prop === \"catch\" || prop === \"finally\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tconst fullPath = [...path, prop];\n\t\t\t\tlet current: any = routes;\n\t\t\t\tfor (const segment of fullPath) {\n\t\t\t\t\tif (current && typeof current === \"object\" && segment in current) {\n\t\t\t\t\t\tcurrent = current[segment];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent = undefined;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (typeof current === \"function\") {\n\t\t\t\t\treturn current;\n\t\t\t\t}\n\t\t\t\tif (isAtom(current)) {\n\t\t\t\t\treturn current;\n\t\t\t\t}\n\t\t\t\treturn createProxy(fullPath);\n\t\t\t},\n\t\t\tapply: async (_, __, args) => {\n\t\t\t\tconst routePath =\n\t\t\t\t\t\"/\" +\n\t\t\t\t\tpath\n\t\t\t\t\t\t.map((segment) =>\n\t\t\t\t\t\t\tsegment.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`),\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.join(\"/\");\n\t\t\t\tconst arg = (args[0] || {}) as ProxyRequest;\n\t\t\t\tconst fetchOptions = (args[1] || {}) as ClientFetchOption;\n\t\t\t\tconst { query, fetchOptions: argFetchOptions, ...body } = arg;\n\t\t\t\tconst options = {\n\t\t\t\t\t...fetchOptions,\n\t\t\t\t\t...argFetchOptions,\n\t\t\t\t} as ClientFetchOption;\n\t\t\t\tconst method = getMethod(routePath, knownPathMethods, arg);\n\t\t\t\treturn await client(routePath, {\n\t\t\t\t\t...options,\n\t\t\t\t\tbody:\n\t\t\t\t\t\tmethod === \"GET\"\n\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t...body,\n\t\t\t\t\t\t\t\t\t...(options?.body || {}),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\tquery: query || options?.query,\n\t\t\t\t\tmethod,\n\t\t\t\t\tasync onSuccess(context) {\n\t\t\t\t\t\tawait options?.onSuccess?.(context);\n\t\t\t\t\t\tif (!atomListeners || options.disableSignal) return;\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * We trigger listeners\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst matches = atomListeners.filter((s) => s.matcher(routePath));\n\t\t\t\t\t\tif (!matches.length) return;\n\n\t\t\t\t\t\tconst visited = new Set<ClientAtomListener[\"signal\"]>();\n\t\t\t\t\t\tfor (const match of matches) {\n\t\t\t\t\t\t\tconst signal = atoms[match.signal as any];\n\t\t\t\t\t\t\tif (!signal) return;\n\t\t\t\t\t\t\tif (visited.has(match.signal)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvisited.add(match.signal);\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * To avoid race conditions we set the signal in a setTimeout\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst val = signal.get();\n\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\t\t\t\tsignal.set(!val);\n\t\t\t\t\t\t\t}, 10);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t},\n\t\t});\n\t}\n\treturn createProxy() as T;\n}\n","import type { BetterAuthClientOptions } from \"@better-auth/core\";\nimport type { BetterFetch } from \"@better-fetch/fetch\";\nimport { atom, onMount } from \"nanostores\";\nimport type { Session, User } from \"../types\";\nimport type { AuthQueryAtom } from \"./query\";\nimport { useAuthQuery } from \"./query\";\nimport { createSessionRefreshManager } from \"./session-refresh\";\n\nexport type SessionAtom = AuthQueryAtom<{\n\tuser: User;\n\tsession: Session;\n}>;\n\nexport function getSessionAtom(\n\t$fetch: BetterFetch,\n\toptions?: BetterAuthClientOptions | undefined,\n) {\n\tconst $signal = atom<boolean>(false);\n\tconst session: SessionAtom = useAuthQuery<{\n\t\tuser: User;\n\t\tsession: Session;\n\t}>($signal, \"/get-session\", $fetch, {\n\t\tmethod: \"GET\",\n\t});\n\n\tonMount(session, () => {\n\t\tconst refreshManager = createSessionRefreshManager({\n\t\t\tsessionAtom: session,\n\t\t\tsessionSignal: $signal,\n\t\t\t$fetch,\n\t\t\toptions,\n\t\t});\n\n\t\trefreshManager.init();\n\n\t\treturn () => {\n\t\t\trefreshManager.cleanup();\n\t\t};\n\t});\n\n\treturn {\n\t\tsession,\n\t\t$sessionSignal: $signal,\n\t};\n}\n","import type { BetterAuthClientOptions } from \"@better-auth/core\";\nimport type { Session, User } from \"@better-auth/core/db\";\nimport type { BetterFetch, BetterFetchError } from \"@better-fetch/fetch\";\nimport type { WritableAtom } from \"nanostores\";\nimport { getGlobalBroadcastChannel } from \"./broadcast-channel\";\nimport { getGlobalFocusManager } from \"./focus-manager\";\nimport { getGlobalOnlineManager } from \"./online-manager\";\nimport type { AuthQueryAtom } from \"./query\";\n\nconst now = () => Math.floor(Date.now() / 1000);\n\n/**\n * Rate limit: don't refetch on focus if a session request was made within this many seconds\n */\nconst FOCUS_REFETCH_RATE_LIMIT_SECONDS = 5;\n\nexport interface SessionRefreshOptions {\n\tsessionAtom: AuthQueryAtom<{\n\t\tuser: User;\n\t\tsession: Session;\n\t}>;\n\tsessionSignal: WritableAtom<boolean>;\n\t$fetch: BetterFetch;\n\toptions?: BetterAuthClientOptions | undefined;\n}\n\ninterface SessionRefreshState {\n\tlastSync: number;\n\tlastSessionRequest: number;\n\tcachedSession: any;\n\tpollInterval?: ReturnType<typeof setInterval> | undefined;\n\tunsubscribeBroadcast?: (() => void) | undefined;\n\tunsubscribeFocus?: (() => void) | undefined;\n\tunsubscribeOnline?: (() => void) | undefined;\n}\n\nexport function createSessionRefreshManager(opts: SessionRefreshOptions) {\n\tconst { sessionAtom, sessionSignal, $fetch, options = {} } = opts;\n\n\tconst refetchInterval = options.sessionOptions?.refetchInterval ?? 0;\n\tconst refetchOnWindowFocus =\n\t\toptions.sessionOptions?.refetchOnWindowFocus ?? true;\n\tconst refetchWhenOffline =\n\t\toptions.sessionOptions?.refetchWhenOffline ?? false;\n\n\tconst state: SessionRefreshState = {\n\t\tlastSync: 0,\n\t\tlastSessionRequest: 0,\n\t\tcachedSession: undefined,\n\t};\n\n\tconst shouldRefetch = (): boolean => {\n\t\treturn refetchWhenOffline || getGlobalOnlineManager().isOnline;\n\t};\n\n\tconst triggerRefetch = (\n\t\tevent?:\n\t\t\t| {\n\t\t\t\t\tevent?: \"poll\" | \"visibilitychange\" | \"storage\";\n\t\t\t  }\n\t\t\t| undefined,\n\t) => {\n\t\tif (!shouldRefetch()) return;\n\n\t\tif (event?.event === \"storage\") {\n\t\t\tstate.lastSync = now();\n\t\t\tsessionSignal.set(!sessionSignal.get());\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentSession = sessionAtom.get();\n\n\t\tif (event?.event === \"poll\") {\n\t\t\tstate.lastSessionRequest = now();\n\t\t\t$fetch<{\n\t\t\t\tuser: User;\n\t\t\t\tsession: Session;\n\t\t\t}>(\"/get-session\")\n\t\t\t\t.then((res) => {\n\t\t\t\t\tif (res.error) {\n\t\t\t\t\t\tsessionAtom.set({\n\t\t\t\t\t\t\t...currentSession,\n\t\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\t\terror: res.error as BetterFetchError | null,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsessionAtom.set({\n\t\t\t\t\t\t\t...currentSession,\n\t\t\t\t\t\t\tdata: res.data,\n\t\t\t\t\t\t\terror: null,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tstate.lastSync = now();\n\t\t\t\t\tsessionSignal.set(!sessionSignal.get());\n\t\t\t\t})\n\t\t\t\t.catch(() => {});\n\t\t\treturn;\n\t\t}\n\n\t\t// Rate limit: don't refetch on focus if a session request was made recently\n\t\tif (event?.event === \"visibilitychange\") {\n\t\t\tconst timeSinceLastRequest = now() - state.lastSessionRequest;\n\t\t\tif (timeSinceLastRequest < FOCUS_REFETCH_RATE_LIMIT_SECONDS) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstate.lastSessionRequest = now();\n\t\t}\n\n\t\tif (\n\t\t\tcurrentSession?.data === null ||\n\t\t\tcurrentSession?.data === undefined ||\n\t\t\tevent?.event === \"visibilitychange\"\n\t\t) {\n\t\t\tstate.lastSync = now();\n\t\t\tsessionSignal.set(!sessionSignal.get());\n\t\t}\n\t};\n\n\tconst broadcastSessionUpdate = (\n\t\ttrigger: \"signout\" | \"getSession\" | \"updateUser\",\n\t) => {\n\t\tgetGlobalBroadcastChannel().post({\n\t\t\tevent: \"session\",\n\t\t\tdata: { trigger },\n\t\t\tclientId: Math.random().toString(36).substring(7),\n\t\t});\n\t};\n\n\tconst setupPolling = () => {\n\t\tif (refetchInterval && refetchInterval > 0) {\n\t\t\tstate.pollInterval = setInterval(() => {\n\t\t\t\tconst currentSession = sessionAtom.get();\n\t\t\t\tif (currentSession?.data) {\n\t\t\t\t\ttriggerRefetch({ event: \"poll\" });\n\t\t\t\t}\n\t\t\t}, refetchInterval * 1000);\n\t\t}\n\t};\n\n\tconst setupBroadcast = () => {\n\t\tstate.unsubscribeBroadcast = getGlobalBroadcastChannel().subscribe(() => {\n\t\t\ttriggerRefetch({ event: \"storage\" });\n\t\t});\n\t};\n\n\tconst setupFocusRefetch = () => {\n\t\tif (!refetchOnWindowFocus) return;\n\n\t\tstate.unsubscribeFocus = getGlobalFocusManager().subscribe(() => {\n\t\t\ttriggerRefetch({ event: \"visibilitychange\" });\n\t\t});\n\t};\n\n\tconst setupOnlineRefetch = () => {\n\t\tstate.unsubscribeOnline = getGlobalOnlineManager().subscribe((online) => {\n\t\t\tif (online) {\n\t\t\t\ttriggerRefetch({ event: \"visibilitychange\" });\n\t\t\t}\n\t\t});\n\t};\n\n\tconst init = () => {\n\t\tsetupPolling();\n\t\tsetupBroadcast();\n\t\tsetupFocusRefetch();\n\t\tsetupOnlineRefetch();\n\n\t\tgetGlobalBroadcastChannel().setup();\n\t\tgetGlobalFocusManager().setup();\n\t\tgetGlobalOnlineManager().setup();\n\t};\n\n\tconst cleanup = () => {\n\t\tif (state.pollInterval) {\n\t\t\tclearInterval(state.pollInterval);\n\t\t\tstate.pollInterval = undefined;\n\t\t}\n\t\tif (state.unsubscribeBroadcast) {\n\t\t\tstate.unsubscribeBroadcast();\n\t\t\tstate.unsubscribeBroadcast = undefined;\n\t\t}\n\t\tif (state.unsubscribeFocus) {\n\t\t\tstate.unsubscribeFocus();\n\t\t\tstate.unsubscribeFocus = undefined;\n\t\t}\n\t\tif (state.unsubscribeOnline) {\n\t\t\tstate.unsubscribeOnline();\n\t\t\tstate.unsubscribeOnline = undefined;\n\t\t}\n\t\tstate.lastSync = 0;\n\t\tstate.lastSessionRequest = 0;\n\t\tstate.cachedSession = undefined;\n\t};\n\n\treturn {\n\t\tinit,\n\t\tcleanup,\n\t\ttriggerRefetch,\n\t\tbroadcastSessionUpdate,\n\t};\n}\n","import { createAuthClient } from \"better-auth/react\";\n\n/**\n * Always use same-origin for auth (no external server).\n * Explicit baseURL in the browser ensures the client never uses a cached or env-based old server URL.\n */\nexport const authClient = createAuthClient({\n  ...(typeof window !== \"undefined\" && { baseURL: window.location.origin }),\n});\n","import type {\n\tBetterAuthClientOptions,\n\tBetterAuthClientPlugin,\n} from \"@better-auth/core\";\nimport type { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { capitalizeFirstLetter } from \"@better-auth/core/utils\";\nimport type {\n\tBetterFetchError,\n\tBetterFetchResponse,\n} from \"@better-fetch/fetch\";\nimport type { PrettifyDeep, UnionToIntersection } from \"../../types/helper\";\nimport { getClientConfig } from \"../config\";\nimport { createDynamicPathProxy } from \"../proxy\";\nimport type {\n\tInferActions,\n\tInferClientAPI,\n\tInferErrorCodes,\n\tIsSignal,\n\tSessionQueryParams,\n} from \"../types\";\nimport { useStore } from \"./react-store\";\n\nfunction getAtomKey(str: string) {\n\treturn `use${capitalizeFirstLetter(str)}`;\n}\n\ntype InferResolvedHooks<O extends BetterAuthClientOptions> = O extends {\n\tplugins: Array<infer Plugin>;\n}\n\t? UnionToIntersection<\n\t\t\tPlugin extends BetterAuthClientPlugin\n\t\t\t\t? Plugin[\"getAtoms\"] extends (fetch: any) => infer Atoms\n\t\t\t\t\t? Atoms extends Record<string, any>\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t[key in keyof Atoms as IsSignal<key> extends true\n\t\t\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t\t\t: key extends string\n\t\t\t\t\t\t\t\t\t\t? `use${Capitalize<key>}`\n\t\t\t\t\t\t\t\t\t\t: never]: () => ReturnType<Atoms[key][\"get\"]>;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {}\n\t\t\t\t\t: {}\n\t\t\t\t: {}\n\t\t>\n\t: {};\n\nexport function createAuthClient<Option extends BetterAuthClientOptions>(\n\toptions?: Option | undefined,\n) {\n\tconst {\n\t\tpluginPathMethods,\n\t\tpluginsActions,\n\t\tpluginsAtoms,\n\t\t$fetch,\n\t\t$store,\n\t\tatomListeners,\n\t} = getClientConfig(options);\n\tconst resolvedHooks: Record<string, any> = {};\n\tfor (const [key, value] of Object.entries(pluginsAtoms)) {\n\t\tresolvedHooks[getAtomKey(key)] = () => useStore(value);\n\t}\n\n\tconst routes = {\n\t\t...pluginsActions,\n\t\t...resolvedHooks,\n\t\t$fetch,\n\t\t$store,\n\t};\n\tconst proxy = createDynamicPathProxy(\n\t\troutes,\n\t\t$fetch,\n\t\tpluginPathMethods,\n\t\tpluginsAtoms,\n\t\tatomListeners,\n\t);\n\n\ttype ClientAPI = InferClientAPI<Option>;\n\ttype Session = ClientAPI extends {\n\t\tgetSession: () => Promise<infer Res>;\n\t}\n\t\t? Res extends BetterFetchResponse<infer S>\n\t\t\t? S\n\t\t\t: Res\n\t\t: never;\n\treturn proxy as UnionToIntersection<InferResolvedHooks<Option>> &\n\t\tClientAPI &\n\t\tInferActions<Option> & {\n\t\t\tuseSession: () => {\n\t\t\t\tdata: Session;\n\t\t\t\tisPending: boolean;\n\t\t\t\tisRefetching: boolean;\n\t\t\t\terror: BetterFetchError | null;\n\t\t\t\trefetch: (\n\t\t\t\t\tqueryParams?: { query?: SessionQueryParams } | undefined,\n\t\t\t\t) => Promise<void>;\n\t\t\t};\n\t\t\t$Infer: {\n\t\t\t\tSession: NonNullable<Session>;\n\t\t\t};\n\t\t\t$fetch: typeof $fetch;\n\t\t\t$store: typeof $store;\n\t\t\t$ERROR_CODES: PrettifyDeep<\n\t\t\t\tInferErrorCodes<Option> & typeof BASE_ERROR_CODES\n\t\t\t>;\n\t\t};\n}\n\nexport { useStore };\nexport type * from \"@better-fetch/fetch\";\nexport type * from \"nanostores\";\nexport type * from \"../../types/helper\";\nexport type { UnionToIntersection } from \"../../types/helper\";\n","import type {\n\tBetterAuthClientOptions,\n\tClientAtomListener,\n} from \"@better-auth/core\";\nimport { createFetch } from \"@better-fetch/fetch\";\nimport { defu } from \"defu\";\nimport type { WritableAtom } from \"nanostores\";\nimport { getBaseURL } from \"../utils/url\";\nimport { redirectPlugin } from \"./fetch-plugins\";\nimport { parseJSON } from \"./parser\";\nimport { getSessionAtom } from \"./session-atom\";\n\nexport const getClientConfig = (\n\toptions?: BetterAuthClientOptions | undefined,\n\tloadEnv?: boolean | undefined,\n) => {\n\t/* check if the credentials property is supported. Useful for cf workers */\n\tconst isCredentialsSupported = \"credentials\" in Request.prototype;\n\tconst baseURL =\n\t\tgetBaseURL(options?.baseURL, options?.basePath, undefined, loadEnv) ??\n\t\t\"/api/auth\";\n\tconst pluginsFetchPlugins =\n\t\toptions?.plugins\n\t\t\t?.flatMap((plugin) => plugin.fetchPlugins)\n\t\t\t.filter((pl) => pl !== undefined) || [];\n\tconst lifeCyclePlugin = {\n\t\tid: \"lifecycle-hooks\",\n\t\tname: \"lifecycle-hooks\",\n\t\thooks: {\n\t\t\tonSuccess: options?.fetchOptions?.onSuccess,\n\t\t\tonError: options?.fetchOptions?.onError,\n\t\t\tonRequest: options?.fetchOptions?.onRequest,\n\t\t\tonResponse: options?.fetchOptions?.onResponse,\n\t\t},\n\t};\n\tconst {\n\t\tonSuccess: _onSuccess,\n\t\tonError: _onError,\n\t\tonRequest: _onRequest,\n\t\tonResponse: _onResponse,\n\t\t...restOfFetchOptions\n\t} = options?.fetchOptions || {};\n\tconst $fetch = createFetch({\n\t\tbaseURL,\n\t\t...(isCredentialsSupported ? { credentials: \"include\" } : {}),\n\t\tmethod: \"GET\",\n\t\tjsonParser(text) {\n\t\t\tif (!text) {\n\t\t\t\treturn null as any;\n\t\t\t}\n\t\t\treturn parseJSON(text, {\n\t\t\t\tstrict: false,\n\t\t\t});\n\t\t},\n\t\tcustomFetchImpl: fetch,\n\t\t...restOfFetchOptions,\n\t\tplugins: [\n\t\t\tlifeCyclePlugin,\n\t\t\t...(restOfFetchOptions.plugins || []),\n\t\t\t...(options?.disableDefaultFetchPlugins ? [] : [redirectPlugin]),\n\t\t\t...pluginsFetchPlugins,\n\t\t],\n\t});\n\tconst { $sessionSignal, session } = getSessionAtom($fetch, options);\n\tconst plugins = options?.plugins || [];\n\tlet pluginsActions = {} as Record<string, any>;\n\tconst pluginsAtoms = {\n\t\t$sessionSignal,\n\t\tsession,\n\t} as Record<string, WritableAtom<any>>;\n\tconst pluginPathMethods: Record<string, \"POST\" | \"GET\"> = {\n\t\t\"/sign-out\": \"POST\",\n\t\t\"/revoke-sessions\": \"POST\",\n\t\t\"/revoke-other-sessions\": \"POST\",\n\t\t\"/delete-user\": \"POST\",\n\t};\n\tconst atomListeners: ClientAtomListener[] = [\n\t\t{\n\t\t\tsignal: \"$sessionSignal\",\n\t\t\tmatcher(path) {\n\t\t\t\tconst matchesCommonPaths =\n\t\t\t\t\tpath === \"/sign-out\" ||\n\t\t\t\t\tpath === \"/update-user\" ||\n\t\t\t\t\tpath === \"/sign-up/email\" ||\n\t\t\t\t\tpath === \"/sign-in/email\" ||\n\t\t\t\t\tpath === \"/delete-user\" ||\n\t\t\t\t\tpath === \"/verify-email\" ||\n\t\t\t\t\tpath === \"/revoke-sessions\" ||\n\t\t\t\t\tpath === \"/revoke-session\" ||\n\t\t\t\t\tpath === \"/change-email\";\n\n\t\t\t\treturn matchesCommonPaths;\n\t\t\t},\n\t\t},\n\t];\n\n\tfor (const plugin of plugins) {\n\t\tif (plugin.getAtoms) {\n\t\t\tObject.assign(pluginsAtoms, plugin.getAtoms?.($fetch));\n\t\t}\n\t\tif (plugin.pathMethods) {\n\t\t\tObject.assign(pluginPathMethods, plugin.pathMethods);\n\t\t}\n\t\tif (plugin.atomListeners) {\n\t\t\tatomListeners.push(...plugin.atomListeners);\n\t\t}\n\t}\n\n\tconst $store = {\n\t\tnotify: (\n\t\t\tsignal?: (Omit<string, \"$sessionSignal\"> | \"$sessionSignal\") | undefined,\n\t\t) => {\n\t\t\tpluginsAtoms[signal as keyof typeof pluginsAtoms]!.set(\n\t\t\t\t!pluginsAtoms[signal as keyof typeof pluginsAtoms]!.get(),\n\t\t\t);\n\t\t},\n\t\tlisten: (\n\t\t\tsignal: Omit<string, \"$sessionSignal\"> | \"$sessionSignal\",\n\t\t\tlistener: (value: boolean, oldValue?: boolean | undefined) => void,\n\t\t) => {\n\t\t\tpluginsAtoms[signal as keyof typeof pluginsAtoms]!.subscribe(listener);\n\t\t},\n\t\tatoms: pluginsAtoms,\n\t};\n\n\tfor (const plugin of plugins) {\n\t\tif (plugin.getActions) {\n\t\t\tpluginsActions = defu(\n\t\t\t\tplugin.getActions?.($fetch, $store, options) ?? {},\n\t\t\t\tpluginsActions,\n\t\t\t);\n\t\t}\n\t}\n\treturn {\n\t\tget baseURL() {\n\t\t\treturn baseURL;\n\t\t},\n\t\tpluginsActions,\n\t\tpluginsAtoms,\n\t\tpluginPathMethods,\n\t\tatomListeners,\n\t\t$fetch,\n\t\t$store,\n\t};\n};\n","import type { Store, StoreValue } from \"nanostores\";\nimport { listenKeys } from \"nanostores\";\nimport type { DependencyList } from \"react\";\nimport { useCallback, useRef, useSyncExternalStore } from \"react\";\n\ntype StoreKeys<T> = T extends { setKey: (k: infer K, v: any) => unknown }\n\t? K\n\t: never;\n\nexport interface UseStoreOptions<SomeStore> {\n\t/**\n\t * @default\n\t * ```ts\n\t * [store, options.keys]\n\t * ```\n\t */\n\tdeps?: DependencyList | undefined;\n\n\t/**\n\t * Will re-render components only on specific key changes.\n\t */\n\tkeys?: StoreKeys<SomeStore>[] | undefined;\n}\n\n/**\n * Subscribe to store changes and get store's value.\n *\n * Can be used with store builder too.\n *\n * ```js\n * import { useStore } from 'nanostores/react'\n *\n * import { router } from '../store/router'\n *\n * export const Layout = () => {\n *   let page = useStore(router)\n *   if (page.route === 'home') {\n *     return <HomePage />\n *   } else {\n *     return <Error404 />\n *   }\n * }\n * ```\n *\n * @param store Store instance.\n * @returns Store value.\n */\nexport function useStore<SomeStore extends Store>(\n\tstore: SomeStore,\n\toptions: UseStoreOptions<SomeStore> = {},\n): StoreValue<SomeStore> {\n\tconst snapshotRef = useRef<StoreValue<SomeStore>>(store.get());\n\n\tconst { keys, deps = [store, keys] } = options;\n\n\tconst subscribe = useCallback((onChange: () => void) => {\n\t\tconst emitChange = (value: StoreValue<SomeStore>) => {\n\t\t\tif (snapshotRef.current === value) return;\n\t\t\tsnapshotRef.current = value;\n\t\t\tonChange();\n\t\t};\n\n\t\temitChange(store.value);\n\t\tif (keys?.length) {\n\t\t\treturn listenKeys(store as any, keys, emitChange);\n\t\t}\n\t\treturn store.listen(emitChange);\n\t}, deps);\n\n\tconst get = () => snapshotRef.current as StoreValue<SomeStore>;\n\n\treturn useSyncExternalStore(subscribe, get, get);\n}\n"],"names":["NodeNextResponse","NEXT_CACHE_TAGS_HEADER","state: SessionRefreshState","message: BroadcastMessage","env","__NEXT_RELATIVE_DIST_DIR","value","atomListeners: ClientAtomListener[]","process","__NEXT_MULTI_ZONE_DRAFT_MODE"],"mappings":"gKCAA,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,OAAA,IAAA,EAAA,EAAA,CAAA,CAAA,KDhBA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,2BUEC,GAAI,gBACE,kBAEL,UAAU,CAAA,EACL,EAAQ,IAAA,EAAM,KAAO,EAAQ,IAAA,EAAM,UACtC,WCNF,gJAEA,+MAEiB,uBAIlB,6DAEsB,OAChB,SACC,6BAGP,IAAA,IACA,SAAU,EPQD,KORQ,UACJ,KAGR,EACL,AAJoB,+FHjBjB,EAAgB,EAAE,CAClB,EAAU,EAEH,EAAQ,EAGN,EAAO,IAClB,IAAI,EAAY,EAAE,CACd,EAAQ,KACV,KACM,AAAC,EAAM,EAAE,EAAE,AACb,EAAM,MAAM,CAAC,KAAO,KAEf,EAAM,KAAK,EAEpB,GAAI,SACJ,AAAO,IACL,EAAM,EADO,AACL,CAAG,EAAU,IAAI,CAAC,GAEnB,KACL,IACE,IAAI,EAAI,IACR,EAAI,EAAc,EADA,IACM,EAExB,AACI,CAAa,CAAC,EAAE,GAAK,EACvB,EAAc,MAAM,AADa,CACZ,GAAG,EAExB,GA1BqB,EA0BhB,AAIT,IAAI,EAAQ,EAAU,OAAO,CAAC,EAC1B,EAAC,IACH,EAAU,CADA,KACM,CAAC,EAAO,GACpB,AAAC,EAAE,EAAM,EAAE,EAAE,EAAM,GAAG,GAE9B,GAEF,OAAO,CAAQ,CAAE,CAAU,EACzB,IACA,IAAI,EAAmB,CAAC,EAAc,MAAM,CAC5C,IAAK,IAAI,KAAY,EACnB,EAAc,IAAI,CAAC,CADW,CACD,EAAM,KAAK,CAAE,EAAU,GAGtD,GAAI,EAAkB,CACpB,IACE,EAAU,EACV,EAAU,EAAc,MAAM,CAC9B,KAEA,CAAa,CAAC,EAAQ,CACpB,CAHS,AAGI,CAAC,EAAU,EAAE,CAC1B,CAAa,CAAC,EAAU,EAAE,CAC1B,CAAa,CAAC,EAAU,EAAE,EAG9B,EAAc,EAPZ,IAOkB,CAAG,CACzB,CACF,EAGA,MAAO,EACP,IAAI,CAAQ,EACV,IAAI,EAAW,EAAM,KAAK,CACtB,IAAa,IACf,EAAM,IADmB,CACd,CAAG,EACd,EAAM,MAAM,CAAC,GAEjB,EACA,UAAU,CAAQ,EAChB,IAAI,EAAS,EAAM,MAAM,CAAC,GAE1B,OADA,EAAS,EAAM,KAAK,EACb,CACT,EACA,MAAO,CACT,EAUA,OAAO,CACT,EKnFM,EAAA,IAAA,CAAA,eREsC,eCJO,SFHiB,EGAE,MFOM,+FAkBjE,CKfG,CAAA,wCLkBN,SAAA,CAAA,MAAA,CAAA,gCAmBQ,iBAmBiC,qBAAA,oBACvB,EAAA,GACvB,UAAA,CAAmB,EQUkC,CRVb,IAAI,AQUS,ERVc,EAAA,CAAK,qBDpE9C,OAAO,GAAA,CAAA,mCAQpC,kCAGW,CAAA,CAAA,uBACM,GAAA,CAAA,uBAEC,MAAA,CAAO,CUUvB,ARdwBA,cFQd,CAAA,CAAkB,wBACJ,GAAa,EAAA,YASpC,MAAA,KAAa,CAAA,YAqBA,IAIf,kBAHyB,EAAA,GACvB,UAAA,CAAmB,EAAA,CAAA,IAAqB,CAAA,EAE1C,UAAA,CAAA,EAAA,sDG3CD,iCAEiC,IAArB,OAAO,WAA4B,UAAU,MAAA,ADLqB,EO0BzE,CNrB6D,EDLY,MCOnE,CAAA,CAAA,2BACU,aAEb,SAAA,CAAU,MAAA,CAAA,cAIP,CAAA,CAAiB,gCAEX,OAAA,CAAA,AAAS,GAAa,EAAS,YAQ7C,MAAA,KAAa,CAAA,uBAiBX,UAAA,CAAA,EAAA,EAAA,CAAA,UAAA,CACiB,EFGiD,CAAL,AEH1B,GIuBW,CJvBP,CFG2B,AEH3B,CAAqB,CAExD,UAAA,CAAA,EAAA,sBS5CoB,KAAA,GAAA,GAAa,IAAK,wECHxC,IAAM,EAAa,SCyCzB,CAAA,8DAKC,CAAA,CACA,QAAA,QACA,CAAA,eACA,CCpCmE,CAAA,CDqChE,ICrCgE,qBJDpE,IID+B,gBAAiB,QAAQ,SAAA,MAEvD,EAAA,UAAA,EAAA,GAAA,QAAA,GAAsC,SAAU,KAAA,WAChD,cAEA,GAAA,SACG,QAAA,GAAoB,EAAO,YAAA,EAAA,OAAA,AACpB,GAAO,AAAO,KAAA,EAAU,MAAI,EAAE,8BAGlC,yBAEL,UAAW,CJMC,EAAA,cINsB,EZElC,OHIC,AGJM,0BYDyB,kBACrB,EdME,CcNO,CdOnB,acPiC,GdQ5B,CEFgC,kCYLH,aAG/B,CAAA,UACM,CAAA,CACX,QAAA,CAAA,CACA,KZKsD,KYL3C,CAAA,CACX,WAAY,CAAA,CACZ,GAAG,EAAA,CACA,GAAS,cAAgB,CAAA,CAAE,MAChB,EAAA,WAAA,EAAY,cAEtB,EAAyB,aAAe,CdGpC,UcHkD,CAAA,CAAA,yBAE1D,AAAW,GACL,CdOCG,GcPF,EACH,KR4HY,AACf,CAAA,CACA,EAAwB,CAAE,OAAQ,GAAM,EAExC,OAAA,SAhGQ,AACR,CAAA,CACA,EAAwB,CAAA,CAAE,CNtBkB,CMuBxC,AACJ,GAAA,QACC,EAAA,CAAA,CAAA,CAAA,SAAA,GACW,CEfwB,AGOlB,GAAA,MLSjB,CAAA,YACA,GAAa,CAAA,CAAA,CACV,KAEA,AAAiB,iBAAjB,EAAiB,OACb,EN7BgC,AMgCxC,IAAA,EAAgB,ENhCgC,AMgC1B,IAAA,MAGrB,EAAA,MAAA,CAAA,GACe,MAAf,CAAA,CAAQ,EAAA,EAAO,EACP,QAAA,CAAS,KAAI,CACrB,CAAC,EAAQ,KAAA,CAAM,EAAG,CAAA,EAAG,CAAC,QAAA,CAAS,KAAI,AAEnC,CAAA,MAAO,EAAQ,KAAA,CAAM,EAAG,CAAA,EAAG,CAG5B,IAAM,EAAA,EAAqB,WAAA,mBACG,ESzCE,GAAA,EAAA,OT0CxB,CAAA,CAAe,EAAA,KAGlB,EAAA,IAAA,CAAA,GAAA,IACA,EACH,MAAM,YAAgB,qCAEhB,KAGgB,OAAO,OAAA,CAAQ,GAA0B,IAAA,CAAA,CAC/D,CAAC,EAAK,EAAA,KAAa,GACb,EAAA,EAAA,IAAA,CAAuB,aACd,GAAA,QACN,IAAA,CAAA,CAAA,mEAAA,EAC+D,EAAI,QAAA,CAAA,CAC1E,CAEK,KAIc,EACtB,MAAM,MACL,gEAIF,GAAI,QA2BI,KAAK,KAAA,CAAM,KA1BkB,IA0BT,qBAvBhB,gBAAR,GACAG,GACiB,UAAjB,OAAOA,EKvCR,CLwCC,cAAeA,EACf,YAEQ,IAAA,CACP,CAAA,wBAAA,EAA2B,EAAI,oCAAA,CAAA,CAC/B,WAKC,CL3DDE,EK2DgC,UAAjB,OAAOF,EAAoB,CAC5C,IAAA,EAAA,SAlHK,CAAA,QACM,EAAA,IAAA,CAAoB,KJEK,EIDlC,EAAO,OAAO,KAEnB,GAAA,EAEC,EACA,EACA,EAAA,EKcoB,ALdpB,EAGA,EAAA,EAEA,EACA,EACA,EAAA,CACG,EAEE,EAAO,IAAA,KAAA,KACP,CEIsB,EAAA,CAAA,SAAA,EFHV,IAChB,CNdc,QAAA,EMcG,IAAA,EACjB,QPT4D,COSnD,EAAM,IACf,INda,KMcJ,EAAO,GAAG,CACnB,SAAS,EAAS,GAAG,CACrB,SAAS,EAAS,GAAG,CACrB,EAAK,SAAS,EAAG,MAAA,CAAO,EAAG,IAAI,CAAE,GAAG,CAAG,EACvC,CACD,IAEG,EAAA,QQxBc,GR0Bf,CQ1Be,QAAA,EAAA,IR0BkB,SAAS,EAAe,GAAA,CAAG,EAC5D,AAAe,EAD6C,MACvC,CAAA,GAAK,CAAA,6CApCtB,aAAgB,MAAA,CAAS,EGgB5B,IHhBkC,EAAK,EJEE,KAAA,IIsClB,CGDE,CAAA,MH8EAA,QAEzB,OAAA,aAIuB,EAAA,GAAcA,CKxCpC,WL4CW,YAER,EAEP,OAAO,IAQkB,EAAO,IQ9Hd,CbEDF,CaFO,CACtB,OAAA,CAAA,IAHO,qBAMQ,MACjB,GAAA,CAAA,CACA,QAAA,MAEK,EAAA,OAAA,EAA8B,EAAA,IAC9B,GAAS,2BAA6B,EAAE,CAAG,GAAgB,MAE/D,mBAEM,CAAA,CAAA,QAAA,CAAA,CAAA,EJ7CR,EAAA,MFMA,EACA,KEJG,MFe6B,EAAA,CAC/B,KAAM,2CAGQ,eACe,OAGnB,MACV,eAE0B,UAEL,YAAnB,OAAO,CTvBU,CEDIH,AOyBlB,EAAA,CACA,KAAA,EAAY,GAAA,GAAM,CElBF,GAAA,OFmBT,EAAA,GAAA,GAAA,KAAA,CACP,UAAW,EAAA,GAAA,GAAY,GNjBA,MAAA,GMmBvB,MAEY,CACf,GAAA,CAAA,OACO,IACH,GAAM,KAAA,OACO,KAAA,kBAED,CAAA,QACL,CACT,CRZC,IQYK,EAAA,IAAA,uBAEK,EACX,aAAA,CAAA,UACS,EAAM,KAAA,CAAM,OAAA,YAEV,YAAY,UAEnB,QAAQ,CAAA,KACP,CAAA,QAAA,CAAA,CAAA,CAAc,EACd,EAAA,AACoB,UADpB,OACE,EAAQ,KAAA,CACZ,EAAQ,KAAA,CACR,EAAQ,KAAA,EAAO,2BAC0B,OACT,UAC1B,KADyC,UAGlD,KAAA,gBACW,gBACG,UACL,EAAM,KAAA,CAAM,OAAA,SAEhB,GAAM,UAAA,WAEP,UAAU,CAAA,EACf,IAAM,EAAA,EAAqB,GAAA,EAAK,MAC1B,CAAI,EFsDV,SErDkC,OAAtB,EAAa,IAAA,MAClB,EAAA,IAAA,CACN,MAAO,KACP,cAAc,EACd,QAAA,EAAe,KAAA,CAAA,OAAA,YAEJ,YAAA,kBAIN,GAAA,CAAI,OACT,EACA,KAAA,KACA,UAAA,CAAA,EACA,aAAA,CAAA,EACA,QAAS,EAAM,KAAA,CAAA,OAAA,oBAIR,KAAK,eASN,KALX,EAAkB,ECUE,GDLG,CALC,KMUvB,EAAA,CNV+B,GAAA,EAE7B,GAAiB,CAInB,EAAS,SAAA,CAAU,UAClB,GAAA,IAEC,UGqByB,MHArB,MEjIS,GAAc,GAIlB,CGE2B,eHFX,CAAQ,CACnC,OAAA,KAAQ,CACR,ATX6E,CSW5E,CN6F2B,aM1FL,+DCWoB,EAAA,CAAA,CAAY,CVlBA,CUkBK,sBAEb,iBAAmB,EAC7D,EAAA,EAAA,cAAA,EACmB,CThB6B,CAAC,qBSgBN,IAEhD,EAAQ,GZhBP,WAAA,EYgBuB,GVlB6B,iBAAA,CAAA,EUoBhDC,EAAAA,CACL,SAAU,CXXC,AELH,oCSkBO,KAAA,KAQf,QAMK,IAVwB,IAAyB,QAAA,EAUjD,+BAE2B,GACzB,QAAA,CAAW,MACH,GAAA,CAAA,CAAK,EAAA,GAAA,iBAIG,EAAY,GAAA,SAExB,QAAU,OAAQ,4CAM1B,IAAA,CAAA,AAAM,YAEL,EAAY,GAAA,CAAI,wBAGJ,KAAA,aAIR,CAAA,CACH,KAAM,EAAI,IAAA,gBAIN,QAAA,CAAA,MACQ,EVrBN,CAAA,CAAA,CUqBW,EAAA,GAAA,iBAEP,aAKX,GAAO,QAAA,mBAA8B,UACG,kBAAA,CAvFL,EAwFX,AAC1B,SAEK,kBAAA,CAAqB,KAI3B,GAAgB,OAAS,MACzB,GAAgB,OAAS,KAAA,GACzB,GAAO,QAAU,kBAAA,GAChB,GACK,QAAA,CAAA,UACY,CAAC,EAAA,GAAA,MAgFrB,MAAO,MAjCD,KAhCD,GAAA,EAAqC,EACxC,CAAA,CAAA,EAAA,YAAA,CAAqB,YAAA,KACG,CADe,CACH,GAAA,IACf,MAAA,EACJ,CAAE,MAAO,MAAA,CAAQ,CAAC,YAO9B,oBAAA,CAAuB,IAA4B,SAAA,CAAA,OACzC,CAAE,MAAO,cAKpB,IAEL,EAAM,gBAFqB,AAErB,CAAA,IAA2C,SAAA,CAAA,OACjC,CAAE,MAAO,CHnBF,2CGwBG,IAAyB,SAAA,CAAA,AAAW,IACzD,GACH,EAAe,CAAE,CAFsD,KAEtD,kBAAO,CAAoB,CAAC,GAW/C,CHvBE,GGuB0B,KAAA,EAAO,CACnC,IAAwB,KAAA,EAAO,CAC/B,IAAyB,KAAA,EAAO,EA2BhC,QAxBK,KACD,EAAM,YAAA,EAAc,CACvB,cAAc,EAAA,YAAM,CAAa,CACjC,EAAM,YAAA,CAAe,KAAA,GAElB,EAAM,oBAAA,EAAsB,CAC/B,EAAM,oBAAA,GACN,EAAM,oBAAA,CAAuB,KAAA,GAE9B,EAAU,gBAAA,EAAkB,CAC3B,EAAM,gBAAA,EAAkB,CACxB,EAAM,gBAAA,CAAA,KAAmB,GAEtB,EAAM,iBAAA,EAAmB,CAC5B,EAAM,iBAAA,GACN,EAAM,iBAAA,CAAoB,KAAA,GAE3B,EAAM,QAAA,CAAW,EACjB,EAAA,kBAAA,CAA2B,EAC3B,EAAA,aAAA,CAAsB,KAAA,kBAMtB,yBA9EA,QAE4B,IAAA,CAAK,CAChC,MAAA,eACM,SAAE,GACR,SAAU,KAAK,MAAA,GAAA,QAAA,CAAkB,GAAG,CAAC,SAAA,CAAU,EAAE,MDlGC,CAClD,YAAA,kBAEA,OIkCiD,EJjCjD,QIiCyD,KRkDN,GQlDc,KJ9BnD,IAAA,UAGC,OAAA,KN1BO,EA2GR,IACb,IAAI,AA5G2B,EA4GjB,EAAW,GACrB,GAAS,EAAO,MAAM,CAAC,EAAQ,CAAC,IAAI,CAAC,EAC3C,EA9G2C,EA+GR,IACjC,IAAI,EAAe,EAAO,MAAM,AAChC,GAAO,MAAM,CAAG,CAAC,GAAG,KACb,EAAO,EAAE,EAAK,EAAD,AAAQ,MAAM,EAAE,CAChC,EAAO,MAAM,EAAG,EAChB,KAEK,KAAgB,IAGzB,IAAI,EAAY,EAAO,GAAG,QAC1B,EAAO,MAAM,CAAC,EAAQ,CAAG,EAAE,CAC3B,EAAO,GAAG,CAAG,KACX,IACA,WAAW,KACT,GAAI,EAAO,MAAM,EAAI,CAAC,EAAO,EAAE,CAAE,CAE/B,IAAK,IAAI,KADT,EAAO,MAAM,EAAG,EACI,EAAO,MAAM,CAAC,EAAQ,EAAE,GAC5C,GAAO,MAAM,CApIP,AAoIQ,EAAQ,CAAG,EAAE,AAC7B,CACF,EA3B2B,CA2BxB,GACL,EAYO,KACL,EAAO,MAAM,CAAG,EAChB,EAAO,GAAG,CAAG,CACf,CACF,EAnJA,EAAO,MAAM,CAAG,EAAO,MAAM,EAAI,CAAC,EAC9B,AAAC,EAAO,MAAM,CAAC,GAA2B,EAAE,CAC9C,EAAO,GADqB,GACf,CAAC,GAA2B,CAAG,EAAY,IAEtD,CAFuB,CAEhB,MAAM,CAAC,EAAS,CAAC,WAAW,CAAC,CAAC,EAAO,IAAM,CAAC,EAAE,GAAQ,CAAA,CAAK,CAAG,CACnE,OAAQ,CAAC,EACT,GAAG,CAAU,AACf,EACF,EAAA,EAEF,EAAO,MAAM,CAAC,EAAS,CAAG,EAAO,MAAM,CAAC,EAAS,EAAI,EAAE,CACvD,EAAO,MAAM,CAAC,AAhBF,EAgBW,CAAC,IAAI,CAAC,GMkBvB,0BAEU,IIsBX,EAAA,GAAA,SAA8B,EAAE,CACtC,EAAqB,CAAA,EACf,EAAe,6BAIrB,EAAA,aACc,OACb,mBAAoB,OACpB,yBAA0B,OAC1B,eAAgB,QAEXK,EAAsC,CAC3C,CACC,OAAA,4BAGW,cAAT,GAAS,AACA,iBADA,GAEA,mBAAT,GACS,mBAAT,GACS,iBAAT,GACA,AAAS,qBACA,qBAAT,GACS,oBAAT,GACS,kBAAT,IAOJ,IAAA,IAAW,KAAU,EAChB,EAAA,QAAA,EAAA,OACI,MAAA,CAAO,EAAc,AbEMH,EaFC,CbEE,CACnCK,AK8DsC,MQjEL,GAAW,EbGhB,EaD3B,EAAA,CAFkD,CAAC,SAEnD,EAAA,OACI,MAAA,CAAO,EAAmB,EAAO,WAAA,CAAY,CAEjD,EAAA,aAAA,EACH,EAAc,IAAA,CAAK,GAAA,EAAU,aAAA,CAAc,KAIvC,EAAA,CACL,OAAA,IAGC,CAAA,CAAa,EAAA,CAAA,GAAA,CACZ,CAAC,CAAA,CAAa,EAAA,CAAsC,GAAA,oBAOrD,CAAA,CAAa,EAAA,CAAsC,SAAA,CAAU,SAAS,CAEhE,OAGH,IAAM,KAAU,EAChB,EAAA,IAAJ,MAAI,GACH,EAAA,CAAA,EAAA,EAAA,IAAA,EAAA,EACQ,UAAA,GAAa,EAAQ,EAAQ,IAAY,CAAA,CAAE,CAClD,EAAA,CACA,QAIF,IAAA,SAAc,0BAGd,eACA,CNPG,CGmBD,yDE9FiB,MACuB,EADf,QAEhB,EAAA,EAAA,GAAe,OAAA,OAAA,CAAe,GACzC,CAAA,CAAc,kCAAW,IAAI,CAAA,CAAA,IAAU,CZpCV,Wc0B9B,EAAsC,CAAA,CAAE,EAExC,IAAA,EAAA,CAAA,EAAA,EAAA,MAAA,EAAkD,EfGH,GAAA,iBeDjC,CfEC,CAAA,CeFO,CdDD,CAACJ,AcCO,EAAK,CAAA,CAAK,EAEjC,EAAA,CAAA,EAAY,EAAA,WAAA,EAAA,IACjB,IAAM,EAAA,IACD,EAAA,OAAA,GAAwB,OAAO,kBAKpC,CDHC,CAAA,ECGgB,KAAA,EACb,GAAA,OAAA,OAAA,OACI,AjB/DJ,EAAU,IAAI,IAAI,AiB+DW,GjB/DL,GAAG,MAAC,GACzB,AiB8DY,EjB9DL,MAAM,CAAC,CAAC,EAAO,EAAU,KACjC,EAAQ,GAAG,CAAC,IACd,AiB4DmC,EjB5D1B,EAAO,EAAU,AADF,EAG5B,EiB0DuC,qBAGrC,GAEG,EAAA,IAAA,EAAwB,OAAA,kCAEF,EAAA,EAAgB,IAAI,CFZC,MAAM,IJxBvD,MI4BI,CAAA,CJ3BJ,GI4BI,CAAA,oBJvBJ,EAHA,OACA,AAEA,EAAqB,EAAiB,EAAE,mBACtB,WAAA,EAAA,KACZ,CAAA,CAAG,CAAA,+BAIO,YAAU,UAAA,GAA6B,MRhBpB,CFIhB,GUaf,CAAA,CVboB,AUYsB,KVZtC,CGJ6B,AAArB,OOmBP,EAAA,GPjBP,GOiB4B,EAAK,GACb,CPfiB,CDHA,ICGK,AOgBpC,IAAA,KAAiB,EAAA,GACjB,GAA8B,UAAnB,CPdgC,CIFC,CAAC,IGgB3B,GAAwB,KAAW,EACxD,EAAU,CAAA,CAAQ,EAAlB,AAAkB,KACZ,sBAKe,YACtB,OADU,EACH,EFzDH,IE2DD,aF3DC,EE2DM,IF1DH,OAAV,EPMqC,COLrC,QAAS,GACqB,YAA9B,OAAQ,EAAc,GAAA,EACtB,OAAQ,GACqB,UAA7B,OAAQ,EAAc,EAAA,CEsDT,EAGJ,EAAY,IAEpB,MAAO,MAAA,EAAU,EAAA,WAEf,IAAA,EAEE,GAAA,CAAA,AAAK,CTjB2B,ESkBhC,EAAQ,OAAA,CAAQ,SAAA,AAAW,GAAW,CAAA,CAAA,EAAI,EAAO,WAAA,EAAa,CAAA,CAAA,CAAG,CACjE,CACA,IAAA,CAAK,IAAI,CACN,EAAO,CAAA,CAAK,EAAA,EAAM,CAAA,EAClB,EAAgB,CAAA,CAAK,EAAA,EAAM,CAAA,CAAE,CAC7B,OAAE,CAAA,CAAA,aAAqB,CTlBI,CWaF,AFKe,EMrBZ,AfGD,CSkBgB,EAAA,CAAS,IAC1C,SAEZ,CAAA,EAEJ,EAAA,aAtEH,CAAA,MAOM,EAAS,CRXE,CAAA,EAAA,iBQYK,MAAA,CAAA,CAAA,GAAA,EAAA,CAA2B,GAAA,CAAQ,CAAE,QACvD,IAGA,GAAc,OACV,ERhB0E,AQgB7D,MAAA,CAEjB,GAAA,OAAA,IAAA,CAAA,GAA0B,MAAA,CAAS,CJjBG,CIkBzC,AAAO,CAAP,ARdsB,GaAnB,GLgBG,ERfD,MQmEsB,EIZ3B,EJYwD,IAAI,AMnBV,GNmBZ,CHuBC,gBGrBjC,CAAA,CACH,KAAA,QAAA,EAEI,KRxEqD,AQwErD,EACA,CACA,GAAA,CAAA,IACI,GAAS,MAAQ,CAAA,CAAE,EAE3B,MAAO,GAAA,GAAkB,aACzB,EACA,MAAM,UAAA,CAAA,WACC,GAAA,YAAA,GACF,CAAC,AIxBT,EXpC6C,CO4DpC,AV1DqC,EU0DZ,AT1DjB,SamCjB,IJuBkC,CAAe,GV1DgB,MAAM,EU8D7D,EAAU,EAAc,MAAA,CAAA,AAAQ,GAAM,EAAE,OAAA,CAAQ,OAClD,CAAC,EAAQ,AADmD,CAAC,KACpD,CAAQ,WAEf,EAAA,IAAc,KAAmC,GAClD,IAAA,KAAA,EAAwB,CAC5B,IAAA,EAAe,AIlCpB,CJkCoB,CAAM,EAAA,ATnExB,MSmEwB,CAAA,IACjB,CAAC,EAAQ,UACT,EAAQ,GAAA,CAAI,EAAM,MAAA,EACrB,GHmD+B,QGjDxB,GAAA,CAAI,EAAM,MAAA,EAIlB,IAAM,EAAM,EAAO,GAAA,qBAGX,GAAA,CAAI,CAAA,IACT,eGjHiC,CACzC,IAAI,CAAkB,AACxB,GfRA,CeOuC,GfPvC,EAAA,EAAA,CAAA,CAAA,OAiCO,eAAe,EACpB,CAAU,CACV,EAAS,Qe5Ba,Cf4BJ,EAElB,MAjCM,EACA,EAgCA,EAAM,EAAK,IAAI,CAAC,QAAQ,CAAC,KAC3B,EAAK,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,GAAI,WAAW,GACvC,MACE,EAAM,CAAA,EAAG,EAAO,CAAC,EAAE,OAAO,UAAU,GAAG,CAAC,EAAE,EAAA,CAAK,CAC/C,EAAS,OAAO,IAAI,CAAC,MAAM,EAAK,WAAW,IAE3C,GAxCA,EAAY,AAwCP,QAxCe,GAAG,CAAC,aAAa,GACvB,QAAQ,GAAG,CAAC,gBAAgB,GACxB,QAAQ,GAAG,CAAC,oBAAoB,CAExD,AAAI,AAAC,GAAc,GAAgB,EAE5B,IAAI,CAFO,CAEP,IAFuB,IAEf,CAFiC,AAEhC,CAClB,OAAQ,OAER,SAAU,CAAC,QAAQ,EAAE,EAAU,yBAAyB,CAAC,CACzD,YAAa,CAAE,8BAAa,CAAgB,EAE5C,gBAAgB,CAClB,GAT2D,MAsC3D,GAAI,EAAI,CACN,IAAM,EAAS,QAAQ,GAAG,CAAC,cAAc,CACnC,EAAY,QAAQ,GAAG,CAAC,aAAa,CAE3C,GAAI,CAAC,GAAU,CAAC,EACd,MAAM,AAAI,GADe,GAEvB,8DAKJ,GAAI,EAAU,QAAQ,CAAC,4BACrB,CADkD,KAC5C,AAAI,MACR,uFACE,sEACA,+DAIN,OAAM,EAAG,IAAI,CACX,IAAI,EAAA,gBAAgB,CAAC,CACnB,OAAQ,EACR,IAAK,EACL,KAAM,EACN,YAAa,EAAK,IAAI,EAAI,2BAC1B,cAAe,EAAO,UAAU,AAClC,IAGF,IAAM,EAAO,EAAU,OAAO,CAAC,MAAO,IACtC,MAAO,CAAE,IAAK,CAAA,EAAG,EAAK,CAAC,EAAE,EAAA,CAAK,AAAC,CACjC,CAGA,GAAM,WAAE,CAAS,OAAE,CAAK,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OACvB,EAAW,MAAA,EAAA,CAAA,CAAA,OACX,EAAY,EAAS,IAAI,CAAC,QAAQ,GAAG,GAAI,SAAU,UACzD,OAAM,EAAM,EAAW,CAAE,WAAW,CAAK,GACzC,IAAM,EAAW,CAAA,EAAG,OAAO,UAAU,GAAG,CAAC,EAAE,EAAA,CAAK,CAEhD,OADA,MAAM,EAAU,EAAS,IAAI,CAAC,EAAW,GAAW,GAC7C,CAAE,IAAK,CAAC,SAAS,EAAE,EAAA,CAAU,AAAC,CACvC,CFhFA,eAAe,IAEb,IAAI,EAAuB,KAC3B,GAAI,CACF,IAAM,EAAS,MAAM,EAAW,UAAU,CAAC,CACzC,aAAc,CAAE,QAAS,MAAM,CAAA,EAAA,EAAA,OAAA,AAAO,IAAI,OAAO,CAAM,CACzD,GACA,EACE,GAA4B,UAAlB,OAAO,GAAuB,SAAU,EAC7C,EAAiC,IAAI,CACtC,IACR,CAAE,KAAM,CACN,OAAO,IACT,CAEA,GAAI,CAAC,GAAS,KAAM,OAAO,KAE3B,IAAM,EAAU,QAAQ,GAAG,CAAC,kBAAkB,QAC9C,AAAI,GAEE,CAAC,AADU,EAAQ,GADZ,EACiB,CAAC,KAAK,GAAG,CAAC,AAAC,GAAM,EAAE,IAAI,GAAG,WAAW,IACrD,QAAQ,CAAC,EAAQ,IAAI,CAAC,KAAK,EAAE,eAAiB,IAAY,CAAP,IAG1D,CACT,CAEO,eAAe,EAAK,CAAgB,MAMrC,EAJJ,GAAI,CADY,AACX,MADiB,GACR,CACZ,OAAO,EAAA,YAAY,CAAC,IAAI,CAAC,CAAE,MAAO,cAAe,EAAG,CAAE,OAAQ,GAAI,GAIpE,GAAI,CACF,EAAW,MAAM,EAAQ,QAAQ,EACnC,CAAE,KAAM,CACN,OAAO,EAAA,YAAY,CAAC,IAAI,CAAC,CAAE,MAAO,mBAAoB,EAAG,CAAE,OAAQ,GAAI,EACzE,CAGA,IAAM,EAAW,EAAS,MAAM,CAAC,SAC3B,EAAS,EAAS,GAAG,CAAC,QACtB,EAAmB,IACnB,EAAS,MAAM,CAAC,AAAC,GAAM,aAAa,SACpC,aAAkB,KAAO,CAAC,EAAO,CAAG,EAAE,CAC3C,CAED,GAAwB,GAAG,CAAvB,EAAS,MAAM,CACjB,OAAO,EAAA,YAAY,CAAC,IAAI,CAAC,CAAE,MAAO,mBAAoB,EAAG,CAAE,OAAQ,GAAI,GAGzE,GAAI,CACF,IAAM,EAAU,MAAM,QAAQ,GAAG,CAC/B,EAAS,GAAG,CAAC,AAAC,GAAS,EAAW,EAAM,aAG1C,GAAwB,GAAG,CAAvB,EAAS,MAAM,CACjB,OAAO,EAAA,YAAY,CAAC,IAAI,CAAC,CAAE,IAAK,CAAO,CAAC,EAAE,CAAE,GAAG,CAAE,KAAM,CAAC,CAAO,CAAC,EAAE,CAAE,GAAG,CAAC,AAAC,GAE3E,OAAO,EAAA,YAAY,CAAC,IAAI,CAAC,CAAE,KAAM,EAAQ,GAAG,CAAC,AAAC,GAAM,EAAE,GAAG,CAAE,EAC7D,CAAE,MAAO,EAAK,CAEZ,OADA,QAAQ,KAAK,CAAC,gBAAiB,GACxB,EAAA,YAAY,CAAC,IAAI,CAAC,CAAE,MAAO,eAAgB,EAAG,CAAE,OAAQ,GAAI,EACrE,CACF,2BCrDA,IAAA,EAAA,EAAA,CAAA,CAAA,OAIA,IAAM,EAAc,IAAI,EAAA,mBAAmB,CAAC,CACxC,WAAY,CACR,KAAM,EAAA,SAAS,CAAC,SAAS,CACzB,KAAM,oBACN,SAAU,cACV,SAAU,QACV,WAAY,EAChB,EACA,QAAS,CAAA,OACT,IADiD,eACc,CAA3C,EACpB,iBAAkB,wCAClB,iBAZqB,GAarB,SAAA,CACJ,GAIM,kBAAE,CAAgB,CAAE,sBAAoB,CAAE,cAAW,CAAE,CAAG,EAChE,SAAS,KACL,MAAO,CAAA,EAAA,EAAA,UAAW,AAAX,EAAY,kBACf,uBACA,CACJ,EACJ,CAEO,eAAe,GAAQ,CAAG,CAAE,CAAG,CAAE,CAAG,EACnC,EAAY,KAAK,EAAE,AACnB,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,+BAAgC,QAAQ,MAAM,CAAC,MAAM,IAE7E,IAAI,EAAU,oBAKV,EAAU,EAAQ,OAAO,CAAC,WAAY,KAAO,IAMjD,IAAM,EAAgB,MAAM,EAAY,OAAO,CAAC,EAAK,EAAK,SACtD,EACA,mBAHE,CAAA,CAIN,GACA,GAAI,CAAC,EAID,OAHA,EAAI,IADY,MACF,CAAG,IACjB,EAAI,GAAG,CAAC,eACS,MAAjB,CAAwB,CAApB,IAAyB,KAAhB,EAAoB,EAAI,SAAS,CAAC,IAAI,CAAC,EAAK,QAAQ,OAAO,IACjE,KAEX,GAAM,SAAE,CAAO,QAAE,CAAM,YAAE,CAAU,WAAE,CAAS,aAAE,CAAW,CAAE,mBAAiB,qBAAE,CAAmB,sBAAE,CAAoB,yBAAE,CAAuB,kBAAE,CAAgB,yBAAE,CAAuB,uBAAE,CAAqB,CAAE,CAAG,EACnN,EAAoB,CAAA,EAAA,EAAA,gBAAgB,AAAhB,EAAiB,GACvC,EAAQ,GAAQ,EAAkB,aAAa,CAAC,EAAkB,EAAI,EAAkB,MAAM,CAAC,EAAA,AAAiB,EAC9G,EAAY,WAEa,MAAvB,EAA8B,KAAK,EAAI,EAAoB,SAAA,AAAS,EAAE,AACtE,MAAM,EAAoB,SAAS,CAAC,EAAK,EAAK,GAAW,GAEzD,EAAI,GAAG,CAAC,gCAEL,MAEX,GAAI,GAAS,CAAC,EAAa,CACvB,IAAM,GAAgB,CAAQ,EAAkB,MAAM,CAAC,EAAiB,CAClE,EAAgB,EAAkB,aAAa,CAAC,EAAkB,CACxE,GAAI,IAC+B,IAA3B,EAAc,KADH,GACW,EAAc,CAAC,EAAe,CACpD,GAAI,EAAW,YAAY,CAAC,WAAW,CACnC,CADqC,MAC9B,MAAM,GAEjB,OAAM,IAAI,EAAA,eAAe,AAC7B,CAER,CACA,IAAI,EAAW,MACX,GAAU,EAAY,IAAb,CAAkB,EAAK,EAAD,EAG/B,EAAW,AAAa,OAHqB,KAC7C,EAAW,CAAA,EAEwB,IAAM,CAAA,EAE7C,IAAM,GACgB,IAAtB,EAAY,EAAkB,GAAb,EAEjB,CAAC,EAKK,EAAqB,GAAS,CAAC,EAIjC,GAAyB,GACzB,CAAA,EAAA,EAAA,iBADkD,IAClD,AAAqB,EAAC,CAClB,KAAM,aAbqF,aAc3F,wBACA,CACJ,GAEJ,IAAM,EAAS,EAAI,MAAM,EAAI,MACvB,EAAS,CAAA,EAAA,EAAA,SAAS,AAAT,IACT,EAAa,EAAO,kBAAkB,GACtC,EAAU,QACZ,oBACA,EACA,WAAY,CACR,aAAc,CACV,gBAAgB,CAAQ,EAAW,YAAY,CAAC,cAAc,AAClE,EACA,iBAAiB,CAAQ,EAAW,eAAe,yBACnD,EACA,iBAAkB,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,EAAK,oBACtC,kBAAmB,EAAW,SAAS,CACvC,UAAW,EAAI,SAAS,CACxB,QAAS,AAAC,IACN,EAAI,EAAE,CAAC,QAAS,EACpB,EACA,sBAAkB,EAClB,8BAA+B,CAAC,EAAO,EAAU,EAAc,IAAa,EAAY,cAAc,CAAC,EAAK,EAAO,EAAc,EAAY,EACjJ,EACA,cAAe,SACX,CACJ,CACJ,EACM,EAAc,IAAI,EAAA,eAAe,CAAC,GAClC,EAAc,IAAI,EAAA,gBAAgB,CAAC,GACnC,EAAU,EAAA,kBAAkB,CAAC,mBAAmB,CAAC,EAAa,CAAA,EAAA,EAAA,sBAAA,AAAsB,EAAC,IAC3F,GAAI,CACA,IAAM,EAAoB,MAAO,GACtB,EAAY,MAAM,CAAC,EAAS,GAAS,OAAO,CAAC,KAChD,GAAI,CAAC,EAAM,OACX,EAAK,aAAa,CAAC,CACf,mBAAoB,EAAI,UAAU,CAClC,WAAY,EAChB,GACA,IAAM,EAAqB,EAAO,qBAAqB,GAEvD,GAAI,CAAC,EACD,OAEJ,GAAI,EAAmB,GAAG,CAAC,EAHF,kBAGwB,EAAA,cAAc,CAAC,aAAa,CAAE,YAC3E,QAAQ,IAAI,CAAC,CAAC,2BAA2B,EAAE,EAAmB,GAAG,CAAC,kBAAkB,qEAAqE,CAAC,EAG9J,IAAM,EAAQ,EAAmB,GAAG,CAAC,cACrC,GAAI,EAAO,CACP,IAAM,EAAO,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAO,CACjC,EAAK,aAAa,CAAC,CACf,aAAc,EACd,aAAc,EACd,iBAAkB,CACtB,GACA,EAAK,UAAU,CAAC,EACpB,MACI,CADG,CACE,UAAU,CAAC,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAS,CAE9C,GAEE,GAAgB,CAAoC,CAAA,EAAA,EAAA,EAA5B,YAA4B,AAAc,EAAC,EAAK,eACxE,EAAiB,MAAO,QACtB,EA4FI,EA3FR,IAAM,EAAoB,MAAO,oBAAE,CAAkB,CAAE,IACnD,GAAI,CACA,GAAI,CAAC,GAAiB,GAAwB,GAA2B,CAAC,EAKtE,OAJA,EAAI,SADsF,CAC5E,CAAG,IAEjB,EAAI,SAAS,CAAC,iBAAkB,eAChC,EAAI,GAAG,CAAC,gCACD,KAEX,IAAM,EAAW,MAAM,EAAkB,GACzC,EAAI,YAAY,CAAG,EAAQ,UAAU,CAAC,YAAY,CAClD,IAAI,EAAmB,EAAQ,UAAU,CAAC,gBAAgB,CAGtD,GACI,EAAI,SAAS,EAAE,CACf,CAFc,CAEV,SAAS,CAAC,GACd,OAAmB,GAG3B,IAAM,EAAY,EAAQ,UAAU,CAAC,aAAa,CAGlD,IAAI,EA6BA,OADA,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAa,EAAa,EAAU,EAAQ,UAAU,CAAC,gBAAgB,EACnF,IA7BA,EACP,IAAM,EAAO,MAAM,EAAS,IAAI,GAE1B,EAAU,CAAA,EAAA,EAAA,yBAAA,AAAyB,EAAC,EAAS,OAAO,EACtD,IACA,CAAO,CAAC,EAAA,GADG,mBACmB,CAAC,CAAG,CAAA,EAElC,CAAC,CAAO,CAAC,eAAe,EAAI,EAAK,IAAI,EAAE,CACvC,CAAO,CAAC,eAAe,CAAG,EAAK,IAAA,AAAI,EAEvC,IAAM,EAAa,KAAkD,IAA3C,EAAQ,UAAU,CAAC,mBAAmB,IAAoB,EAAQ,UAAU,CAAC,mBAAmB,EAAI,EAAA,cAAA,AAAc,GAAG,AAAQ,EAAQ,UAAU,CAAC,mBAAmB,CACvL,EAAS,KAA8C,IAAvC,EAAQ,UAAU,CAAC,eAAe,EAAoB,EAAQ,UAAU,CAAC,eAAe,EAAI,EAAA,cAAc,MAAG,EAAY,EAAQ,UAAU,CAAC,eAAe,CAcjL,MAZmB,CAYZ,AAXH,MAAO,CACH,KAAM,EAAA,eAAe,CAAC,SAAS,CAC/B,OAAQ,EAAS,MAAM,CACvB,KAAM,OAAO,IAAI,CAAC,MAAM,EAAK,WAAW,YACxC,CACJ,EACA,aAAc,YACV,SACA,CACJ,CACJ,CAEJ,CAKJ,CAAE,KALS,CAKF,EAAK,CAeV,MAZ0B,MAAtB,EAA6B,KAAK,EAAI,EAAmB,OAAA,AAAO,EAAE,CAElE,MAAM,EAAY,cAAc,CAAC,EAAK,EAAK,CACvC,WAAY,aACZ,UAAW,EACX,UAAW,QACX,iBAAkB,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,oBAClC,uBACA,CACJ,EACJ,GAAG,AATgB,EASJ,GAEb,CACV,CACJ,EACM,EAAa,MAAM,EAAY,cAAc,CAAC,KAChD,aACA,WACA,EACA,UAAW,EAAA,SAAS,CAAC,SAAS,CAC9B,YAAY,oBACZ,EACA,mBAAmB,uBACnB,0BACA,oBACA,EACA,UAAW,EAAI,SAAS,eACxB,CACJ,GAEA,GAAI,CAAC,EACD,KADQ,EACD,KAEX,GAAI,CAAe,MAAd,CAAqB,EAAS,AAA0C,GAA9C,IAAK,EAAoB,EAAW,KAAK,AAAL,EAAiB,KAAK,EAAI,EAAkB,IAAI,IAAM,EAAA,eAAe,CAAC,SAAS,CAE9I,CAFgJ,KAE1I,OAAO,cAAc,CAAC,AAAI,MAAM,CAAC,kDAAkD,EAAgB,MAAd,CAAqB,EAAS,AAA2C,GAA/C,IAAK,EAAqB,EAAW,KAAA,AAAK,EAAY,KAAK,EAAI,EAAmB,IAAI,CAAA,CAAE,EAAG,oBAAqB,CACjO,MAAO,OACP,YAAY,EACZ,cAAc,CAClB,EAEA,CAAC,GACD,EAAI,SAAS,CADG,AACF,iBAAkB,EAAuB,cAAgB,EAAW,MAAM,CAAG,OAAS,EAAW,OAAO,CAAG,QAAU,OAGnI,GACA,EAAI,QADS,CACA,CAAC,gBAAiB,2DAEnC,IAAM,EAAU,CAAA,EAAA,EAAA,2BAA2B,AAA3B,EAA4B,EAAW,KAAK,CAAC,OAAO,EAcpE,OAbI,AAAE,CAAD,EAAkB,GACnB,EADwB,AAChB,GADmB,GACb,CAAC,EAAA,sBAAsB,GAIrC,EAAW,YAAY,EAAK,EAAI,AAAL,SAAc,CAAC,kBAAqB,EAAD,AAAS,GAAG,CAAC,kBAAkB,AAC7F,EAAQ,GAAG,CAAC,gBAAiB,CAAA,EAAA,EAAA,qBAAA,AAAqB,EAAC,EAAW,YAAY,GAE9E,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAa,EAChC,IAAI,SAAS,EAAW,KAAK,CAAC,IAAI,CAAE,SAChC,EACA,OAAQ,EAAW,KAAK,CAAC,MAAM,EAAI,GACvC,IACO,IACX,EAGI,EACA,MAAM,EAAe,EADT,CAGZ,MAAM,EAAO,qBAAqB,CAAC,EAAI,OAAO,CAAE,IAAI,EAAO,KAAK,CAAC,EAAA,cAAc,CAAC,aAAa,CAAE,CACvF,SAAU,CAAA,EAAG,EAAO,CAAC,EAAE,EAAA,CAAS,CAChC,KAAM,EAAA,QAAQ,CAAC,MAAM,CACrB,WAAY,CACR,cAAe,EACf,cAAe,EAAI,GAAG,AAC1B,CACJ,EAAG,GAEf,CAAE,MAAO,EAAK,CAeV,GAdM,aAAe,EAAA,eAAe,EAEhC,CAFmC,KAE7B,EAAY,cAAc,CAAC,EAAK,EAAK,CACvC,WAAY,aACZ,UAAW,EACX,UAAW,QACX,iBAAkB,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,CAClC,qBACA,sBACJ,EACJ,GAAG,AATgB,EASJ,GAIf,EAAO,MAAM,EAKjB,OAHA,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EAAa,EAAa,IAAI,SAAS,KAAM,CAC5D,OAAQ,GACZ,IACO,IACX,CACJ,EAEA,qCAAqC","ignoreList":[1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,18,19,20]}