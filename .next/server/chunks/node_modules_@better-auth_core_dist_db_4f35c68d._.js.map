{"version":3,"sources":["../../../node_modules/%40better-auth/core/src/db/get-tables.ts","../../../node_modules/%40better-auth/core/src/db/adapter/utils.ts","../../../node_modules/%40better-auth/core/src/db/adapter/get-model-name.ts","../../../node_modules/%40better-auth/core/src/db/adapter/get-default-model-name.ts","../../../node_modules/%40better-auth/core/src/db/adapter/get-field-name.ts","../../../node_modules/%40better-auth/core/src/db/adapter/get-default-field-name.ts","../../../node_modules/%40better-auth/core/src/db/adapter/get-field-attributes.ts","../../../node_modules/%40better-auth/core/src/db/adapter/get-id-field.ts","../../../node_modules/%40better-auth/core/dist/db/adapter/index.mjs","../../../node_modules/%40better-auth/core/src/db/adapter/factory.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"../types\";\nimport type { BetterAuthDBSchema, DBFieldAttribute } from \"./type\";\n\nexport const getAuthTables = (\n\toptions: BetterAuthOptions,\n): BetterAuthDBSchema => {\n\tconst pluginSchema = (options.plugins ?? []).reduce(\n\t\t(acc, plugin) => {\n\t\t\tconst schema = plugin.schema;\n\t\t\tif (!schema) return acc;\n\t\t\tfor (const [key, value] of Object.entries(schema)) {\n\t\t\t\tacc[key] = {\n\t\t\t\t\tfields: {\n\t\t\t\t\t\t...acc[key]?.fields,\n\t\t\t\t\t\t...value.fields,\n\t\t\t\t\t},\n\t\t\t\t\tmodelName: value.modelName || key,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn acc;\n\t\t},\n\t\t{} as Record<\n\t\t\tstring,\n\t\t\t{ fields: Record<string, DBFieldAttribute>; modelName: string }\n\t\t>,\n\t);\n\n\tconst shouldAddRateLimitTable = options.rateLimit?.storage === \"database\";\n\tconst rateLimitTable = {\n\t\trateLimit: {\n\t\t\tmodelName: options.rateLimit?.modelName || \"rateLimit\",\n\t\t\tfields: {\n\t\t\t\tkey: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tunique: true,\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.rateLimit?.fields?.key || \"key\",\n\t\t\t\t},\n\t\t\t\tcount: {\n\t\t\t\t\ttype: \"number\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.rateLimit?.fields?.count || \"count\",\n\t\t\t\t},\n\t\t\t\tlastRequest: {\n\t\t\t\t\ttype: \"number\",\n\t\t\t\t\tbigint: true,\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.rateLimit?.fields?.lastRequest || \"lastRequest\",\n\t\t\t\t\tdefaultValue: () => Date.now(),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t} satisfies BetterAuthDBSchema;\n\n\tconst { user, session, account, verification, ...pluginTables } =\n\t\tpluginSchema;\n\n\tconst sessionTable = {\n\t\tsession: {\n\t\t\tmodelName: options.session?.modelName || \"session\",\n\t\t\tfields: {\n\t\t\t\texpiresAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.session?.fields?.expiresAt || \"expiresAt\",\n\t\t\t\t},\n\t\t\t\ttoken: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.session?.fields?.token || \"token\",\n\t\t\t\t\tunique: true,\n\t\t\t\t},\n\t\t\t\tcreatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.session?.fields?.createdAt || \"createdAt\",\n\t\t\t\t\tdefaultValue: () => new Date(),\n\t\t\t\t},\n\t\t\t\tupdatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.session?.fields?.updatedAt || \"updatedAt\",\n\t\t\t\t\tonUpdate: () => new Date(),\n\t\t\t\t},\n\t\t\t\tipAddress: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tfieldName: options.session?.fields?.ipAddress || \"ipAddress\",\n\t\t\t\t},\n\t\t\t\tuserAgent: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tfieldName: options.session?.fields?.userAgent || \"userAgent\",\n\t\t\t\t},\n\t\t\t\tuserId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tfieldName: options.session?.fields?.userId || \"userId\",\n\t\t\t\t\treferences: {\n\t\t\t\t\t\tmodel: options.user?.modelName || \"user\",\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tonDelete: \"cascade\",\n\t\t\t\t\t},\n\t\t\t\t\trequired: true,\n\t\t\t\t\tindex: true,\n\t\t\t\t},\n\t\t\t\t...session?.fields,\n\t\t\t\t...options.session?.additionalFields,\n\t\t\t},\n\t\t\torder: 2,\n\t\t},\n\t} satisfies BetterAuthDBSchema;\n\n\treturn {\n\t\tuser: {\n\t\t\tmodelName: options.user?.modelName || \"user\",\n\t\t\tfields: {\n\t\t\t\tname: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.user?.fields?.name || \"name\",\n\t\t\t\t\tsortable: true,\n\t\t\t\t},\n\t\t\t\temail: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\tunique: true,\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.user?.fields?.email || \"email\",\n\t\t\t\t\tsortable: true,\n\t\t\t\t},\n\t\t\t\temailVerified: {\n\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\tdefaultValue: false,\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.user?.fields?.emailVerified || \"emailVerified\",\n\t\t\t\t\tinput: false,\n\t\t\t\t},\n\t\t\t\timage: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tfieldName: options.user?.fields?.image || \"image\",\n\t\t\t\t},\n\t\t\t\tcreatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\tdefaultValue: () => new Date(),\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.user?.fields?.createdAt || \"createdAt\",\n\t\t\t\t},\n\t\t\t\tupdatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\tdefaultValue: () => new Date(),\n\t\t\t\t\tonUpdate: () => new Date(),\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.user?.fields?.updatedAt || \"updatedAt\",\n\t\t\t\t},\n\t\t\t\t...user?.fields,\n\t\t\t\t...options.user?.additionalFields,\n\t\t\t},\n\t\t\torder: 1,\n\t\t},\n\t\t//only add session table if it's not stored in secondary storage\n\t\t...(!options.secondaryStorage || options.session?.storeSessionInDatabase\n\t\t\t? sessionTable\n\t\t\t: {}),\n\t\taccount: {\n\t\t\tmodelName: options.account?.modelName || \"account\",\n\t\t\tfields: {\n\t\t\t\taccountId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.account?.fields?.accountId || \"accountId\",\n\t\t\t\t},\n\t\t\t\tproviderId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.account?.fields?.providerId || \"providerId\",\n\t\t\t\t},\n\t\t\t\tuserId: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\treferences: {\n\t\t\t\t\t\tmodel: options.user?.modelName || \"user\",\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tonDelete: \"cascade\",\n\t\t\t\t\t},\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.account?.fields?.userId || \"userId\",\n\t\t\t\t\tindex: true,\n\t\t\t\t},\n\t\t\t\taccessToken: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\treturned: false,\n\t\t\t\t\tfieldName: options.account?.fields?.accessToken || \"accessToken\",\n\t\t\t\t},\n\t\t\t\trefreshToken: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\treturned: false,\n\t\t\t\t\tfieldName: options.account?.fields?.refreshToken || \"refreshToken\",\n\t\t\t\t},\n\t\t\t\tidToken: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\treturned: false,\n\t\t\t\t\tfieldName: options.account?.fields?.idToken || \"idToken\",\n\t\t\t\t},\n\t\t\t\taccessTokenExpiresAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\treturned: false,\n\t\t\t\t\tfieldName:\n\t\t\t\t\t\toptions.account?.fields?.accessTokenExpiresAt ||\n\t\t\t\t\t\t\"accessTokenExpiresAt\",\n\t\t\t\t},\n\t\t\t\trefreshTokenExpiresAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\treturned: false,\n\t\t\t\t\tfieldName:\n\t\t\t\t\t\toptions.account?.fields?.refreshTokenExpiresAt ||\n\t\t\t\t\t\t\"refreshTokenExpiresAt\",\n\t\t\t\t},\n\t\t\t\tscope: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\tfieldName: options.account?.fields?.scope || \"scope\",\n\t\t\t\t},\n\t\t\t\tpassword: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: false,\n\t\t\t\t\treturned: false,\n\t\t\t\t\tfieldName: options.account?.fields?.password || \"password\",\n\t\t\t\t},\n\t\t\t\tcreatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.account?.fields?.createdAt || \"createdAt\",\n\t\t\t\t\tdefaultValue: () => new Date(),\n\t\t\t\t},\n\t\t\t\tupdatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.account?.fields?.updatedAt || \"updatedAt\",\n\t\t\t\t\tonUpdate: () => new Date(),\n\t\t\t\t},\n\t\t\t\t...account?.fields,\n\t\t\t\t...options.account?.additionalFields,\n\t\t\t},\n\t\t\torder: 3,\n\t\t},\n\t\tverification: {\n\t\t\tmodelName: options.verification?.modelName || \"verification\",\n\t\t\tfields: {\n\t\t\t\tidentifier: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.verification?.fields?.identifier || \"identifier\",\n\t\t\t\t\tindex: true,\n\t\t\t\t},\n\t\t\t\tvalue: {\n\t\t\t\t\ttype: \"string\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.verification?.fields?.value || \"value\",\n\t\t\t\t},\n\t\t\t\texpiresAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tfieldName: options.verification?.fields?.expiresAt || \"expiresAt\",\n\t\t\t\t},\n\t\t\t\tcreatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tdefaultValue: () => new Date(),\n\t\t\t\t\tfieldName: options.verification?.fields?.createdAt || \"createdAt\",\n\t\t\t\t},\n\t\t\t\tupdatedAt: {\n\t\t\t\t\ttype: \"date\",\n\t\t\t\t\trequired: true,\n\t\t\t\t\tdefaultValue: () => new Date(),\n\t\t\t\t\tonUpdate: () => new Date(),\n\t\t\t\t\tfieldName: options.verification?.fields?.updatedAt || \"updatedAt\",\n\t\t\t\t},\n\t\t\t\t...verification?.fields,\n\t\t\t\t...options.verification?.additionalFields,\n\t\t\t},\n\t\t\torder: 4,\n\t\t},\n\t\t...pluginTables,\n\t\t...(shouldAddRateLimitTable ? rateLimitTable : {}),\n\t} satisfies BetterAuthDBSchema;\n};\n","import type { DBFieldAttribute } from \"../type\";\n\nexport function withApplyDefault(\n\tvalue: any,\n\tfield: DBFieldAttribute,\n\taction: \"create\" | \"update\" | \"findOne\" | \"findMany\",\n) {\n\tif (action === \"update\") {\n\t\t// Apply onUpdate if value is undefined\n\t\tif (value === undefined && field.onUpdate !== undefined) {\n\t\t\tif (typeof field.onUpdate === \"function\") {\n\t\t\t\treturn field.onUpdate();\n\t\t\t}\n\t\t\treturn field.onUpdate;\n\t\t}\n\t\treturn value;\n\t}\n\tif (action === \"create\") {\n\t\t// we do not want to apply default values if the value is null & not required\n\t\tif (value === undefined || (field.required === true && value === null)) {\n\t\t\tif (field.defaultValue !== undefined) {\n\t\t\t\tif (typeof field.defaultValue === \"function\") {\n\t\t\t\t\treturn field.defaultValue();\n\t\t\t\t}\n\t\t\t\treturn field.defaultValue;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n}\n\nfunction isObject(item: unknown): item is Record<string, unknown> {\n\treturn item !== null && typeof item === \"object\" && !Array.isArray(item);\n}\n\nexport function deepmerge<T>(target: T, source: Partial<T>): T {\n\tif (Array.isArray(target) && Array.isArray(source)) {\n\t\t// merge arrays by concatenation\n\t\treturn [...target, ...source] as T;\n\t} else if (isObject(target) && isObject(source)) {\n\t\tconst result: Record<string, unknown> = { ...target };\n\n\t\tfor (const [key, value] of Object.entries(source)) {\n\t\t\tif (value === undefined) continue; // skip undefined\n\n\t\t\tif (key in target) {\n\t\t\t\tresult[key] = deepmerge(\n\t\t\t\t\t(target as Record<string, unknown>)[key],\n\t\t\t\t\tvalue as unknown as Partial<T>,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tresult[key] = value;\n\t\t\t}\n\t\t}\n\n\t\treturn result as T;\n\t}\n\n\t// primitives and fallback: source overrides target\n\treturn source as T;\n}\n","import type { BetterAuthDBSchema } from \"../type\";\nimport { initGetDefaultModelName } from \"./get-default-model-name\";\n\nexport const initGetModelName = ({\n\tusePlural,\n\tschema,\n}: {\n\tusePlural: boolean | undefined;\n\tschema: BetterAuthDBSchema;\n}) => {\n\tconst getDefaultModelName = initGetDefaultModelName({\n\t\tschema,\n\t\tusePlural,\n\t});\n\t/**\n\t * Users can overwrite the default model of some tables. This function helps find the correct model name.\n\t * Furthermore, if the user passes `usePlural` as true in their adapter config,\n\t * then we should return the model name ending with an `s`.\n\t */\n\tconst getModelName = (model: string) => {\n\t\tconst defaultModelKey = getDefaultModelName(model);\n\t\tconst useCustomModelName =\n\t\t\tschema &&\n\t\t\tschema[defaultModelKey] &&\n\t\t\tschema[defaultModelKey].modelName !== model;\n\n\t\tif (useCustomModelName) {\n\t\t\treturn usePlural\n\t\t\t\t? `${schema[defaultModelKey]!.modelName}s`\n\t\t\t\t: schema[defaultModelKey]!.modelName;\n\t\t}\n\n\t\treturn usePlural ? `${model}s` : model;\n\t};\n\treturn getModelName;\n};\n","import { BetterAuthError } from \"../../error\";\nimport type { BetterAuthDBSchema } from \"../type\";\n\nexport const initGetDefaultModelName = ({\n\tusePlural,\n\tschema,\n}: {\n\tusePlural: boolean | undefined;\n\tschema: BetterAuthDBSchema;\n}) => {\n\t/**\n\t * This function helps us get the default model name from the schema defined by devs.\n\t * Often times, the user will be using the `modelName` which could had been customized by the users.\n\t * This function helps us get the actual model name useful to match against the schema. (eg: schema[model])\n\t *\n\t * If it's still unclear what this does:\n\t *\n\t * 1. User can define a custom modelName.\n\t * 2. When using a custom modelName, doing something like `schema[model]` will not work.\n\t * 3. Using this function helps us get the actual model name based on the user's defined custom modelName.\n\t */\n\tconst getDefaultModelName = (model: string) => {\n\t\t// It's possible this `model` could had applied `usePlural`.\n\t\t// Thus we'll try the search but without the trailing `s`.\n\t\tif (usePlural && model.charAt(model.length - 1) === \"s\") {\n\t\t\tconst pluralessModel = model.slice(0, -1);\n\t\t\tlet m = schema[pluralessModel] ? pluralessModel : undefined;\n\t\t\tif (!m) {\n\t\t\t\tm = Object.entries(schema).find(\n\t\t\t\t\t([_, f]) => f.modelName === pluralessModel,\n\t\t\t\t)?.[0];\n\t\t\t}\n\n\t\t\tif (m) {\n\t\t\t\treturn m;\n\t\t\t}\n\t\t}\n\n\t\tlet m = schema[model] ? model : undefined;\n\t\tif (!m) {\n\t\t\tm = Object.entries(schema).find(([_, f]) => f.modelName === model)?.[0];\n\t\t}\n\n\t\tif (!m) {\n\t\t\tthrow new BetterAuthError(`Model \"${model}\" not found in schema`);\n\t\t}\n\t\treturn m;\n\t};\n\n\treturn getDefaultModelName;\n};\n","import type { BetterAuthDBSchema } from \"../type\";\nimport { initGetDefaultFieldName } from \"./get-default-field-name\";\nimport { initGetDefaultModelName } from \"./get-default-model-name\";\n\nexport const initGetFieldName = ({\n\tschema,\n\tusePlural,\n}: {\n\tschema: BetterAuthDBSchema;\n\tusePlural: boolean | undefined;\n}) => {\n\tconst getDefaultModelName = initGetDefaultModelName({\n\t\tschema,\n\t\tusePlural,\n\t});\n\n\tconst getDefaultFieldName = initGetDefaultFieldName({\n\t\tschema,\n\t\tusePlural,\n\t});\n\n\t/**\n\t * Get the field name which is expected to be saved in the database based on the user's schema.\n\t *\n\t * This function is useful if you need to save the field name to the database.\n\t *\n\t * For example, if the user has defined a custom field name for the `user` model, then you can use this function to get the actual field name from the schema.\n\t */\n\tfunction getFieldName({\n\t\tmodel: modelName,\n\t\tfield: fieldName,\n\t}: {\n\t\tmodel: string;\n\t\tfield: string;\n\t}) {\n\t\tconst model = getDefaultModelName(modelName);\n\t\tconst field = getDefaultFieldName({ model, field: fieldName });\n\n\t\treturn schema[model]?.fields[field]?.fieldName || field;\n\t}\n\n\treturn getFieldName;\n};\n","import { BetterAuthError } from \"../../error\";\nimport type { BetterAuthDBSchema } from \"../type\";\nimport { initGetDefaultModelName } from \"./get-default-model-name\";\n\nexport const initGetDefaultFieldName = ({\n\tschema,\n\tusePlural,\n}: {\n\tschema: BetterAuthDBSchema;\n\tusePlural: boolean | undefined;\n}) => {\n\tconst getDefaultModelName = initGetDefaultModelName({\n\t\tschema,\n\t\tusePlural,\n\t});\n\n\t/**\n\t * This function helps us get the default field name from the schema defined by devs.\n\t * Often times, the user will be using the `fieldName` which could had been customized by the users.\n\t * This function helps us get the actual field name useful to match against the schema. (eg: schema[model].fields[field])\n\t *\n\t * If it's still unclear what this does:\n\t *\n\t * 1. User can define a custom fieldName.\n\t * 2. When using a custom fieldName, doing something like `schema[model].fields[field]` will not work.\n\t */\n\tconst getDefaultFieldName = ({\n\t\tfield,\n\t\tmodel: unsafeModel,\n\t}: {\n\t\tmodel: string;\n\t\tfield: string;\n\t}) => {\n\t\t// Plugin `schema`s can't define their own `id`. Better-auth auto provides `id` to every schema model.\n\t\t// Given this, we can't just check if the `field` (that being `id`) is within the schema's fields, since it is never defined.\n\t\t// So we check if the `field` is `id` and if so, we return `id` itself. Otherwise, we return the `field` from the schema.\n\t\tif (field === \"id\" || field === \"_id\") {\n\t\t\treturn \"id\";\n\t\t}\n\t\tconst model = getDefaultModelName(unsafeModel); // Just to make sure the model name is correct.\n\n\t\tlet f = schema[model]?.fields[field];\n\t\tif (!f) {\n\t\t\tconst result = Object.entries(schema[model]!.fields!).find(\n\t\t\t\t([_, f]) => f.fieldName === field,\n\t\t\t);\n\t\t\tif (result) {\n\t\t\t\tf = result[1];\n\t\t\t\tfield = result[0];\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\tthrow new BetterAuthError(`Field ${field} not found in model ${model}`);\n\t\t}\n\t\treturn field;\n\t};\n\n\treturn getDefaultFieldName;\n};\n","import { BetterAuthError } from \"../../error\";\nimport type { BetterAuthOptions } from \"../../types\";\nimport type { BetterAuthDBSchema } from \"../type\";\nimport { initGetDefaultFieldName } from \"./get-default-field-name\";\nimport { initGetDefaultModelName } from \"./get-default-model-name\";\nimport { initGetIdField } from \"./get-id-field\";\n\nexport const initGetFieldAttributes = ({\n\tusePlural,\n\tschema,\n\toptions,\n\tcustomIdGenerator,\n\tdisableIdGeneration,\n}: {\n\tusePlural?: boolean;\n\tschema: BetterAuthDBSchema;\n\toptions: BetterAuthOptions;\n\tdisableIdGeneration?: boolean;\n\tcustomIdGenerator?: ((props: { model: string }) => string) | undefined;\n}) => {\n\tconst getDefaultModelName = initGetDefaultModelName({\n\t\tusePlural,\n\t\tschema,\n\t});\n\n\tconst getDefaultFieldName = initGetDefaultFieldName({\n\t\tusePlural,\n\t\tschema,\n\t});\n\n\tconst idField = initGetIdField({\n\t\tusePlural,\n\t\tschema,\n\t\toptions,\n\t\tcustomIdGenerator,\n\t\tdisableIdGeneration,\n\t});\n\n\tconst getFieldAttributes = ({\n\t\tmodel,\n\t\tfield,\n\t}: {\n\t\tmodel: string;\n\t\tfield: string;\n\t}) => {\n\t\tconst defaultModelName = getDefaultModelName(model);\n\t\tconst defaultFieldName = getDefaultFieldName({\n\t\t\tfield: field,\n\t\t\tmodel: defaultModelName,\n\t\t});\n\n\t\tconst fields = schema[defaultModelName]!.fields;\n\t\tfields.id = idField({ customModelName: defaultModelName });\n\t\tconst fieldAttributes = fields[defaultFieldName];\n\t\tif (!fieldAttributes) {\n\t\t\tthrow new BetterAuthError(`Field ${field} not found in model ${model}`);\n\t\t}\n\t\treturn fieldAttributes;\n\t};\n\n\treturn getFieldAttributes;\n};\n","import { logger } from \"../../env\";\nimport type { BetterAuthOptions } from \"../../types\";\nimport { generateId as defaultGenerateId } from \"../../utils\";\nimport type { BetterAuthDBSchema, DBFieldAttribute } from \"../type\";\nimport { initGetDefaultModelName } from \"./get-default-model-name\";\n\nexport const initGetIdField = ({\n\tusePlural,\n\tschema,\n\tdisableIdGeneration,\n\toptions,\n\tcustomIdGenerator,\n\tsupportsUUIDs,\n}: {\n\tusePlural?: boolean;\n\tschema: BetterAuthDBSchema;\n\toptions: BetterAuthOptions;\n\tdisableIdGeneration?: boolean;\n\tcustomIdGenerator?: ((props: { model: string }) => string) | undefined;\n\tsupportsUUIDs?: boolean;\n}) => {\n\tconst getDefaultModelName = initGetDefaultModelName({\n\t\tusePlural: usePlural,\n\t\tschema,\n\t});\n\n\tconst idField = ({\n\t\tcustomModelName,\n\t\tforceAllowId,\n\t}: {\n\t\tcustomModelName?: string;\n\t\tforceAllowId?: boolean;\n\t}) => {\n\t\tconst useNumberId =\n\t\t\toptions.advanced?.database?.useNumberId ||\n\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\t\tconst useUUIDs = options.advanced?.database?.generateId === \"uuid\";\n\n\t\tconst shouldGenerateId: boolean = (() => {\n\t\t\tif (disableIdGeneration) {\n\t\t\t\treturn false;\n\t\t\t} else if (useNumberId && !forceAllowId) {\n\t\t\t\t// if force allow is true, then we should be using their custom provided id.\n\t\t\t\treturn false;\n\t\t\t} else if (useUUIDs) {\n\t\t\t\t// should only generate UUIDs via JS if the database doesn't support natively generating UUIDs.\n\t\t\t\treturn !supportsUUIDs;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t})();\n\n\t\tconst model = getDefaultModelName(customModelName ?? \"id\");\n\t\treturn {\n\t\t\ttype: useNumberId ? \"number\" : \"string\",\n\t\t\trequired: shouldGenerateId ? true : false,\n\t\t\t...(shouldGenerateId\n\t\t\t\t? {\n\t\t\t\t\t\tdefaultValue() {\n\t\t\t\t\t\t\tif (disableIdGeneration) return undefined;\n\t\t\t\t\t\t\tconst generateId = options.advanced?.database?.generateId;\n\t\t\t\t\t\t\tif (generateId === false || useNumberId) return undefined;\n\t\t\t\t\t\t\tif (typeof generateId === \"function\") {\n\t\t\t\t\t\t\t\treturn generateId({\n\t\t\t\t\t\t\t\t\tmodel,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (customIdGenerator) {\n\t\t\t\t\t\t\t\treturn customIdGenerator({ model });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (generateId === \"uuid\") {\n\t\t\t\t\t\t\t\treturn crypto.randomUUID();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn defaultGenerateId();\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: {}),\n\t\t\ttransform: {\n\t\t\t\tinput: (value) => {\n\t\t\t\t\t// Uncomment if need to debug id transformation\n\t\t\t\t\t// console.log(`transforming id: `, {\n\t\t\t\t\t// \tid: value,\n\t\t\t\t\t// \t...(useNumberId ? { useNumberId } : {}),\n\t\t\t\t\t// \t...(useUUIDs ? { useUUIDs } : {}),\n\t\t\t\t\t// \t...(forceAllowId ? { forceAllowId } : {}),\n\t\t\t\t\t// });\n\t\t\t\t\tif (!value) return undefined;\n\n\t\t\t\t\tif (useNumberId) {\n\t\t\t\t\t\tconst numberValue = Number(value);\n\t\t\t\t\t\t// if invalid number, fallback to DB generated number id.\n\t\t\t\t\t\tif (isNaN(numberValue)) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn numberValue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (useUUIDs) {\n\t\t\t\t\t\t// if it's generated by us, then we should return the value as is.\n\t\t\t\t\t\tif (shouldGenerateId && !forceAllowId) return value;\n\t\t\t\t\t\tif (disableIdGeneration) return undefined;\n\t\t\t\t\t\t// if DB will handle UUID generation, then we should return undefined.\n\t\t\t\t\t\tif (supportsUUIDs) return undefined;\n\t\t\t\t\t\t// if forceAllowId is true, it means we should be using the ID provided during the adapter call.\n\t\t\t\t\t\tif (forceAllowId && typeof value === \"string\") {\n\t\t\t\t\t\t\tconst uuidRegex =\n\t\t\t\t\t\t\t\t/^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\t\t\t\t\t\t\tif (uuidRegex.test(value)) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst err = new Error();\n\t\t\t\t\t\t\t\tconst stack = err.stack\n\t\t\t\t\t\t\t\t\t?.split(\"\\n\")\n\t\t\t\t\t\t\t\t\t.filter((_, i) => i !== 1)\n\t\t\t\t\t\t\t\t\t.join(\"\\n\")\n\t\t\t\t\t\t\t\t\t.replace(\"Error:\", \"\");\n\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t\"[Adapter Factory] - Invalid UUID value for field `id` provided when `forceAllowId` is true. Generating a new UUID.\",\n\t\t\t\t\t\t\t\t\tstack,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if the value is not a string, and the database doesn't support generating it's own UUIDs, then we should be generating the UUID.\n\t\t\t\t\t\tif (typeof value !== \"string\" && !supportsUUIDs) {\n\t\t\t\t\t\t\treturn crypto.randomUUID();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif (!value) return undefined;\n\t\t\t\t\treturn String(value);\n\t\t\t\t},\n\t\t\t},\n\t\t} satisfies DBFieldAttribute;\n\t};\n\n\treturn idField;\n};\n","import { initGetDefaultModelName } from \"./get-default-model-name.mjs\";\nimport { initGetDefaultFieldName } from \"./get-default-field-name.mjs\";\nimport { initGetIdField } from \"./get-id-field.mjs\";\nimport { initGetFieldAttributes } from \"./get-field-attributes.mjs\";\nimport { initGetFieldName } from \"./get-field-name.mjs\";\nimport { initGetModelName } from \"./get-model-name.mjs\";\nimport { deepmerge, withApplyDefault } from \"./utils.mjs\";\nimport { createAdapter, createAdapterFactory } from \"./factory.mjs\";\n\nexport { createAdapter, createAdapterFactory, deepmerge, initGetDefaultFieldName, initGetDefaultModelName, initGetFieldAttributes, initGetFieldName, initGetIdField, initGetModelName, withApplyDefault };","import { createLogger, getColorDepth, TTY_COLORS } from \"../../env\";\nimport { BetterAuthError } from \"../../error\";\nimport type { BetterAuthOptions } from \"../../types\";\nimport { safeJSONParse } from \"../../utils/json\";\nimport { getAuthTables } from \"../get-tables\";\nimport { initGetDefaultFieldName } from \"./get-default-field-name\";\nimport { initGetDefaultModelName } from \"./get-default-model-name\";\nimport { initGetFieldAttributes } from \"./get-field-attributes\";\nimport { initGetFieldName } from \"./get-field-name\";\nimport { initGetIdField } from \"./get-id-field\";\nimport { initGetModelName } from \"./get-model-name\";\nimport type {\n\tCleanedWhere,\n\tDBAdapter,\n\tDBTransactionAdapter,\n\tJoinConfig,\n\tJoinOption,\n\tWhere,\n} from \"./index\";\nimport type {\n\tAdapterFactoryConfig,\n\tAdapterFactoryOptions,\n\tAdapterTestDebugLogs,\n} from \"./types\";\nimport { withApplyDefault } from \"./utils\";\n\nexport {\n\tinitGetDefaultModelName,\n\tinitGetDefaultFieldName,\n\tinitGetModelName,\n\tinitGetFieldName,\n\tinitGetFieldAttributes,\n\tinitGetIdField,\n};\nexport * from \"./types\";\n\nlet debugLogs: { instance: string; args: any[] }[] = [];\nlet transactionId = -1;\n\nconst createAsIsTransaction =\n\t(adapter: DBAdapter<BetterAuthOptions>) =>\n\t<R>(fn: (trx: DBTransactionAdapter<BetterAuthOptions>) => Promise<R>) =>\n\t\tfn(adapter);\n\nexport type AdapterFactory = (\n\toptions: BetterAuthOptions,\n) => DBAdapter<BetterAuthOptions>;\n\nexport const createAdapterFactory =\n\t({\n\t\tadapter: customAdapter,\n\t\tconfig: cfg,\n\t}: AdapterFactoryOptions): AdapterFactory =>\n\t(options: BetterAuthOptions): DBAdapter<BetterAuthOptions> => {\n\t\tconst uniqueAdapterFactoryInstanceId = Math.random()\n\t\t\t.toString(36)\n\t\t\t.substring(2, 15);\n\n\t\tconst config = {\n\t\t\t...cfg,\n\t\t\tsupportsBooleans: cfg.supportsBooleans ?? true,\n\t\t\tsupportsDates: cfg.supportsDates ?? true,\n\t\t\tsupportsJSON: cfg.supportsJSON ?? false,\n\t\t\tadapterName: cfg.adapterName ?? cfg.adapterId,\n\t\t\tsupportsNumericIds: cfg.supportsNumericIds ?? true,\n\t\t\tsupportsUUIDs: cfg.supportsUUIDs ?? false,\n\t\t\tsupportsArrays: cfg.supportsArrays ?? false,\n\t\t\ttransaction: cfg.transaction ?? false,\n\t\t\tdisableTransformInput: cfg.disableTransformInput ?? false,\n\t\t\tdisableTransformOutput: cfg.disableTransformOutput ?? false,\n\t\t\tdisableTransformJoin: cfg.disableTransformJoin ?? false,\n\t\t} satisfies AdapterFactoryConfig;\n\n\t\tconst useNumberId =\n\t\t\toptions.advanced?.database?.useNumberId === true ||\n\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\t\tif (useNumberId && config.supportsNumericIds === false) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t`[${config.adapterName}] Your database or database adapter does not support numeric ids. Please disable \"useNumberId\" in your config.`,\n\t\t\t);\n\t\t}\n\n\t\t// End-user's Better-Auth instance's schema\n\t\tconst schema = getAuthTables(options);\n\n\t\tconst debugLog = (...args: any[]) => {\n\t\t\tif (config.debugLogs === true || typeof config.debugLogs === \"object\") {\n\t\t\t\tconst logger = createLogger({ level: \"info\" });\n\t\t\t\t// If we're running adapter tests, we'll keep debug logs in memory, then print them out if a test fails.\n\t\t\t\tif (\n\t\t\t\t\ttypeof config.debugLogs === \"object\" &&\n\t\t\t\t\t\"isRunningAdapterTests\" in config.debugLogs\n\t\t\t\t) {\n\t\t\t\t\tif (config.debugLogs.isRunningAdapterTests) {\n\t\t\t\t\t\targs.shift(); // Removes the {method: \"...\"} object from the args array.\n\t\t\t\t\t\tdebugLogs.push({ instance: uniqueAdapterFactoryInstanceId, args });\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\ttypeof config.debugLogs === \"object\" &&\n\t\t\t\t\tconfig.debugLogs.logCondition &&\n\t\t\t\t\t!config.debugLogs.logCondition?.()\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (typeof args[0] === \"object\" && \"method\" in args[0]) {\n\t\t\t\t\tconst method = args.shift().method;\n\t\t\t\t\t// Make sure the method is enabled in the config.\n\t\t\t\t\tif (typeof config.debugLogs === \"object\") {\n\t\t\t\t\t\tif (method === \"create\" && !config.debugLogs.create) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (method === \"update\" && !config.debugLogs.update) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tmethod === \"updateMany\" &&\n\t\t\t\t\t\t\t!config.debugLogs.updateMany\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (method === \"findOne\" && !config.debugLogs.findOne) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (method === \"findMany\" && !config.debugLogs.findMany) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (method === \"delete\" && !config.debugLogs.delete) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tmethod === \"deleteMany\" &&\n\t\t\t\t\t\t\t!config.debugLogs.deleteMany\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else if (method === \"count\" && !config.debugLogs.count) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.info(`[${config.adapterName}]`, ...args);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(`[${config.adapterName}]`, ...args);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst logger = createLogger(options.logger);\n\n\t\tconst getDefaultModelName = initGetDefaultModelName({\n\t\t\tusePlural: config.usePlural,\n\t\t\tschema,\n\t\t});\n\n\t\tconst getDefaultFieldName = initGetDefaultFieldName({\n\t\t\tusePlural: config.usePlural,\n\t\t\tschema,\n\t\t});\n\n\t\tconst getModelName = initGetModelName({\n\t\t\tusePlural: config.usePlural,\n\t\t\tschema,\n\t\t});\n\t\tconst getFieldName = initGetFieldName({\n\t\t\tschema,\n\t\t\tusePlural: config.usePlural,\n\t\t});\n\n\t\tconst idField = initGetIdField({\n\t\t\tschema,\n\t\t\toptions,\n\t\t\tusePlural: config.usePlural,\n\t\t\tdisableIdGeneration: config.disableIdGeneration,\n\t\t\tcustomIdGenerator: config.customIdGenerator,\n\t\t\tsupportsUUIDs: config.supportsUUIDs,\n\t\t});\n\n\t\tconst getFieldAttributes = initGetFieldAttributes({\n\t\t\tschema,\n\t\t\toptions,\n\t\t\tusePlural: config.usePlural,\n\t\t\tdisableIdGeneration: config.disableIdGeneration,\n\t\t\tcustomIdGenerator: config.customIdGenerator,\n\t\t});\n\n\t\tconst transformInput = async (\n\t\t\tdata: Record<string, any>,\n\t\t\tdefaultModelName: string,\n\t\t\taction: \"create\" | \"update\" | \"findOne\" | \"findMany\",\n\t\t\tforceAllowId?: boolean,\n\t\t) => {\n\t\t\tconst transformedData: Record<string, any> = {};\n\t\t\tconst fields = schema[defaultModelName]!.fields;\n\n\t\t\tconst newMappedKeys = config.mapKeysTransformInput ?? {};\n\t\t\tconst useNumberId =\n\t\t\t\toptions.advanced?.database?.useNumberId ||\n\t\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\t\t\tfields.id = idField({\n\t\t\t\tcustomModelName: defaultModelName,\n\t\t\t\tforceAllowId: forceAllowId && \"id\" in data,\n\t\t\t});\n\t\t\tfor (const field in fields) {\n\t\t\t\tlet value = data[field];\n\t\t\t\tconst fieldAttributes = fields[field];\n\n\t\t\t\tconst newFieldName: string =\n\t\t\t\t\tnewMappedKeys[field] || fields[field]!.fieldName || field;\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined &&\n\t\t\t\t\t((fieldAttributes!.defaultValue === undefined &&\n\t\t\t\t\t\t!fieldAttributes!.transform?.input &&\n\t\t\t\t\t\t!(action === \"update\" && fieldAttributes!.onUpdate)) ||\n\t\t\t\t\t\t(action === \"update\" && !fieldAttributes!.onUpdate))\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// In some endpoints (like signUpEmail) where there isn't proper Zod validation,\n\t\t\t\t// we might receive a date as a string (this is because of the client converting the Date to a string\n\t\t\t\t// when sending to the server). Because of this, we'll convert the string to a Date.\n\t\t\t\tif (\n\t\t\t\t\tfieldAttributes &&\n\t\t\t\t\tfieldAttributes.type === \"date\" &&\n\t\t\t\t\t!(value instanceof Date) &&\n\t\t\t\t\ttypeof value === \"string\"\n\t\t\t\t) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = new Date(value);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tlogger.error(\"[Adapter Factory] Failed to convert string to date\", {\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tfield,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the value is undefined, but the fieldAttr provides a `defaultValue`, then we'll use that.\n\t\t\t\tlet newValue = withApplyDefault(value, fieldAttributes!, action);\n\n\t\t\t\t// If the field attr provides a custom transform input, then we'll let it handle the value transformation.\n\t\t\t\t// Afterwards, we'll continue to apply the default transformations just to make sure it saves in the correct format.\n\t\t\t\tif (fieldAttributes!.transform?.input) {\n\t\t\t\t\tnewValue = await fieldAttributes!.transform.input(newValue);\n\t\t\t\t}\n\n\t\t\t\tif (fieldAttributes!.references?.field === \"id\" && useNumberId) {\n\t\t\t\t\tif (Array.isArray(newValue)) {\n\t\t\t\t\t\tnewValue = newValue.map((x) => (x !== null ? Number(x) : null));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewValue = newValue !== null ? Number(newValue) : null;\n\t\t\t\t\t}\n\t\t\t\t} else if (\n\t\t\t\t\tconfig.supportsJSON === false &&\n\t\t\t\t\ttypeof newValue === \"object\" &&\n\t\t\t\t\tfieldAttributes!.type === \"json\"\n\t\t\t\t) {\n\t\t\t\t\tnewValue = JSON.stringify(newValue);\n\t\t\t\t} else if (\n\t\t\t\t\tconfig.supportsArrays === false &&\n\t\t\t\t\tArray.isArray(newValue) &&\n\t\t\t\t\t(fieldAttributes!.type === \"string[]\" ||\n\t\t\t\t\t\tfieldAttributes!.type === \"number[]\")\n\t\t\t\t) {\n\t\t\t\t\tnewValue = JSON.stringify(newValue);\n\t\t\t\t} else if (\n\t\t\t\t\tconfig.supportsDates === false &&\n\t\t\t\t\tnewValue instanceof Date &&\n\t\t\t\t\tfieldAttributes!.type === \"date\"\n\t\t\t\t) {\n\t\t\t\t\tnewValue = newValue.toISOString();\n\t\t\t\t} else if (\n\t\t\t\t\tconfig.supportsBooleans === false &&\n\t\t\t\t\ttypeof newValue === \"boolean\"\n\t\t\t\t) {\n\t\t\t\t\tnewValue = newValue ? 1 : 0;\n\t\t\t\t}\n\n\t\t\t\tif (config.customTransformInput) {\n\t\t\t\t\tnewValue = config.customTransformInput({\n\t\t\t\t\t\tdata: newValue,\n\t\t\t\t\t\taction,\n\t\t\t\t\t\tfield: newFieldName,\n\t\t\t\t\t\tfieldAttributes: fieldAttributes!,\n\t\t\t\t\t\tmodel: getModelName(defaultModelName),\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (newValue !== undefined) {\n\t\t\t\t\ttransformedData[newFieldName] = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn transformedData;\n\t\t};\n\n\t\tconst transformOutput = async (\n\t\t\tdata: Record<string, any> | null,\n\t\t\tunsafe_model: string,\n\t\t\tselect: string[] = [],\n\t\t\tjoin: JoinConfig | undefined,\n\t\t) => {\n\t\t\tconst transformSingleOutput = async (\n\t\t\t\tdata: Record<string, any> | null,\n\t\t\t\tunsafe_model: string,\n\t\t\t\tselect: string[] = [],\n\t\t\t) => {\n\t\t\t\tif (!data) return null;\n\t\t\t\tconst newMappedKeys = config.mapKeysTransformOutput ?? {};\n\t\t\t\tconst transformedData: Record<string, any> = {};\n\t\t\t\tconst tableSchema = schema[getDefaultModelName(unsafe_model)]!.fields;\n\t\t\t\tconst idKey = Object.entries(newMappedKeys).find(\n\t\t\t\t\t([_, v]) => v === \"id\",\n\t\t\t\t)?.[0];\n\t\t\t\tconst useNumberId =\n\t\t\t\t\toptions.advanced?.database?.useNumberId ||\n\t\t\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\t\t\t\ttableSchema[idKey ?? \"id\"] = {\n\t\t\t\t\ttype: useNumberId ? \"number\" : \"string\",\n\t\t\t\t};\n\t\t\t\tfor (const key in tableSchema) {\n\t\t\t\t\tif (select.length && !select.includes(key)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst field = tableSchema[key];\n\t\t\t\t\tif (field) {\n\t\t\t\t\t\tconst originalKey = field.fieldName || key;\n\n\t\t\t\t\t\t// If the field is mapped, we'll use the mapped key. Otherwise, we'll use the original key.\n\t\t\t\t\t\tlet newValue =\n\t\t\t\t\t\t\tdata[\n\t\t\t\t\t\t\t\tObject.entries(newMappedKeys).find(\n\t\t\t\t\t\t\t\t\t([_, v]) => v === originalKey,\n\t\t\t\t\t\t\t\t)?.[0] || originalKey\n\t\t\t\t\t\t\t];\n\n\t\t\t\t\t\tif (field.transform?.output) {\n\t\t\t\t\t\t\tnewValue = await field.transform.output(newValue);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst newFieldName: string = newMappedKeys[key] || key;\n\n\t\t\t\t\t\tif (originalKey === \"id\" || field.references?.field === \"id\") {\n\t\t\t\t\t\t\t// Even if `useNumberId` is true, we must always return a string `id` output.\n\t\t\t\t\t\t\tif (typeof newValue !== \"undefined\" && newValue !== null)\n\t\t\t\t\t\t\t\tnewValue = String(newValue);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tconfig.supportsJSON === false &&\n\t\t\t\t\t\t\ttypeof newValue === \"string\" &&\n\t\t\t\t\t\t\tfield.type === \"json\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnewValue = safeJSONParse(newValue);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tconfig.supportsArrays === false &&\n\t\t\t\t\t\t\ttypeof newValue === \"string\" &&\n\t\t\t\t\t\t\t(field.type === \"string[]\" || field.type === \"number[]\")\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnewValue = safeJSONParse(newValue);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tconfig.supportsDates === false &&\n\t\t\t\t\t\t\ttypeof newValue === \"string\" &&\n\t\t\t\t\t\t\tfield.type === \"date\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnewValue = new Date(newValue);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tconfig.supportsBooleans === false &&\n\t\t\t\t\t\t\ttypeof newValue === \"number\" &&\n\t\t\t\t\t\t\tfield.type === \"boolean\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnewValue = newValue === 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (config.customTransformOutput) {\n\t\t\t\t\t\t\tnewValue = config.customTransformOutput({\n\t\t\t\t\t\t\t\tdata: newValue,\n\t\t\t\t\t\t\t\tfield: newFieldName,\n\t\t\t\t\t\t\t\tfieldAttributes: field,\n\t\t\t\t\t\t\t\tselect,\n\t\t\t\t\t\t\t\tmodel: getModelName(unsafe_model),\n\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttransformedData[newFieldName] = newValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn transformedData as any;\n\t\t\t};\n\n\t\t\tif (!join || Object.keys(join).length === 0) {\n\t\t\t\treturn await transformSingleOutput(data, unsafe_model, select);\n\t\t\t}\n\n\t\t\tunsafe_model = getDefaultModelName(unsafe_model);\n\t\t\t// for now we just transform the base model\n\t\t\t// later we append the joined models to this object.\n\t\t\tconst transformedData: Record<string, any> = await transformSingleOutput(\n\t\t\t\tdata,\n\t\t\t\tunsafe_model,\n\t\t\t\tselect,\n\t\t\t);\n\n\t\t\t// Get all the models that are required to be joined.\n\t\t\tconst requiredModels = Object.entries(join).map(\n\t\t\t\t([model, joinConfig]) => ({\n\t\t\t\t\tmodelName: getModelName(model),\n\t\t\t\t\tdefaultModelName: getDefaultModelName(model),\n\t\t\t\t\tjoinConfig,\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tif (!data) return null;\n\t\t\t// Data is now the base model object directly (not wrapped under a key)\n\n\t\t\tfor (const {\n\t\t\t\tmodelName,\n\t\t\t\tdefaultModelName,\n\t\t\t\tjoinConfig,\n\t\t\t} of requiredModels) {\n\t\t\t\tlet joinedData = await (async () => {\n\t\t\t\t\tif (options.experimental?.joins) {\n\t\t\t\t\t\tconst result = data[modelName];\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// doesn't support joins, so fallback to handleFallbackJoin\n\t\t\t\t\t\tconst result = await handleFallbackJoin({\n\t\t\t\t\t\t\tbaseModel: unsafe_model,\n\t\t\t\t\t\t\tbaseData: transformedData,\n\t\t\t\t\t\t\tjoinModel: modelName,\n\t\t\t\t\t\t\tspecificJoinConfig: joinConfig,\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t})();\n\n\t\t\t\t// If joinedData is undefined, initialize it based on relationship type\n\t\t\t\tif (joinedData === undefined || joinedData === null) {\n\t\t\t\t\tjoinedData = joinConfig.relation === \"one-to-one\" ? null : [];\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tjoinConfig.relation === \"one-to-many\" &&\n\t\t\t\t\t!Array.isArray(joinedData)\n\t\t\t\t) {\n\t\t\t\t\tjoinedData = [joinedData];\n\t\t\t\t}\n\n\t\t\t\tconst transformed = [];\n\n\t\t\t\tif (Array.isArray(joinedData)) {\n\t\t\t\t\tfor (const item of joinedData) {\n\t\t\t\t\t\tconst transformedItem = await transformSingleOutput(\n\t\t\t\t\t\t\titem,\n\t\t\t\t\t\t\tmodelName,\n\t\t\t\t\t\t\t[],\n\t\t\t\t\t\t);\n\t\t\t\t\t\ttransformed.push(transformedItem);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst transformedItem = await transformSingleOutput(\n\t\t\t\t\t\tjoinedData,\n\t\t\t\t\t\tmodelName,\n\t\t\t\t\t\t[],\n\t\t\t\t\t);\n\t\t\t\t\ttransformed.push(transformedItem);\n\t\t\t\t}\n\n\t\t\t\tconst result =\n\t\t\t\t\tjoinConfig.relation === \"one-to-one\" ? transformed[0] : transformed;\n\t\t\t\ttransformedData[defaultModelName] = result ?? null;\n\t\t\t}\n\n\t\t\treturn transformedData as any;\n\t\t};\n\n\t\tconst transformWhereClause = <W extends Where[] | undefined>({\n\t\t\tmodel,\n\t\t\twhere,\n\t\t\taction,\n\t\t}: {\n\t\t\twhere: W;\n\t\t\tmodel: string;\n\t\t\taction:\n\t\t\t\t| \"create\"\n\t\t\t\t| \"update\"\n\t\t\t\t| \"findOne\"\n\t\t\t\t| \"findMany\"\n\t\t\t\t| \"updateMany\"\n\t\t\t\t| \"delete\"\n\t\t\t\t| \"deleteMany\"\n\t\t\t\t| \"count\";\n\t\t}): W extends undefined ? undefined : CleanedWhere[] => {\n\t\t\tif (!where) return undefined as any;\n\t\t\tconst newMappedKeys = config.mapKeysTransformInput ?? {};\n\n\t\t\treturn where.map((w) => {\n\t\t\t\tconst {\n\t\t\t\t\tfield: unsafe_field,\n\t\t\t\t\tvalue,\n\t\t\t\t\toperator = \"eq\",\n\t\t\t\t\tconnector = \"AND\",\n\t\t\t\t} = w;\n\t\t\t\tif (operator === \"in\") {\n\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\tthrow new BetterAuthError(\"Value must be an array\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet newValue = value;\n\n\t\t\t\tconst defaultModelName = getDefaultModelName(model);\n\t\t\t\tconst defaultFieldName = getDefaultFieldName({\n\t\t\t\t\tfield: unsafe_field,\n\t\t\t\t\tmodel,\n\t\t\t\t});\n\t\t\t\tconst fieldName: string =\n\t\t\t\t\tnewMappedKeys[defaultFieldName] ||\n\t\t\t\t\tgetFieldName({\n\t\t\t\t\t\tfield: defaultFieldName,\n\t\t\t\t\t\tmodel: defaultModelName,\n\t\t\t\t\t});\n\n\t\t\t\tconst fieldAttr = getFieldAttributes({\n\t\t\t\t\tfield: defaultFieldName,\n\t\t\t\t\tmodel: defaultModelName,\n\t\t\t\t});\n\n\t\t\t\tconst useNumberId =\n\t\t\t\t\toptions.advanced?.database?.useNumberId ||\n\t\t\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\n\t\t\t\tif (\n\t\t\t\t\tdefaultFieldName === \"id\" ||\n\t\t\t\t\tfieldAttr!.references?.field === \"id\"\n\t\t\t\t) {\n\t\t\t\t\tif (useNumberId) {\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tnewValue = value.map(Number);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewValue = Number(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfieldAttr.type === \"date\" &&\n\t\t\t\t\tvalue instanceof Date &&\n\t\t\t\t\t!config.supportsDates\n\t\t\t\t) {\n\t\t\t\t\tnewValue = value.toISOString();\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfieldAttr.type === \"boolean\" &&\n\t\t\t\t\ttypeof value === \"boolean\" &&\n\t\t\t\t\t!config.supportsBooleans\n\t\t\t\t) {\n\t\t\t\t\tnewValue = value ? 1 : 0;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfieldAttr.type === \"json\" &&\n\t\t\t\t\ttypeof value === \"object\" &&\n\t\t\t\t\t!config.supportsJSON\n\t\t\t\t) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst stringifiedJSON = JSON.stringify(value);\n\t\t\t\t\t\tnewValue = stringifiedJSON;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Failed to stringify JSON value for field ${fieldName}`,\n\t\t\t\t\t\t\t{ cause: error },\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (config.customTransformInput) {\n\t\t\t\t\tnewValue = config.customTransformInput({\n\t\t\t\t\t\tdata: newValue,\n\t\t\t\t\t\tfieldAttributes: fieldAttr,\n\t\t\t\t\t\tfield: fieldName,\n\t\t\t\t\t\tmodel: getModelName(model),\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\taction,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\toperator,\n\t\t\t\t\tconnector,\n\t\t\t\t\tfield: fieldName,\n\t\t\t\t\tvalue: newValue,\n\t\t\t\t} satisfies CleanedWhere;\n\t\t\t}) as any;\n\t\t};\n\n\t\tconst transformJoinClause = (\n\t\t\tbaseModel: string,\n\t\t\tunsanitizedJoin: JoinOption | undefined,\n\t\t\tselect: string[] | undefined,\n\t\t): { join: JoinConfig; select: string[] | undefined } | undefined => {\n\t\t\tif (!unsanitizedJoin) return undefined;\n\t\t\tif (Object.keys(unsanitizedJoin).length === 0) return undefined;\n\t\t\tconst transformedJoin: JoinConfig = {};\n\t\t\tfor (const [model, join] of Object.entries(unsanitizedJoin)) {\n\t\t\t\tif (!join) continue;\n\t\t\t\tconst defaultModelName = getDefaultModelName(model);\n\t\t\t\tconst defaultBaseModelName = getDefaultModelName(baseModel);\n\n\t\t\t\t// First, check if the joined model has FKs to the base model (forward join)\n\t\t\t\tlet foreignKeys = Object.entries(\n\t\t\t\t\tschema[defaultModelName]!.fields,\n\t\t\t\t).filter(\n\t\t\t\t\t([field, fieldAttributes]) =>\n\t\t\t\t\t\tfieldAttributes.references &&\n\t\t\t\t\t\tgetDefaultModelName(fieldAttributes.references.model) ===\n\t\t\t\t\t\t\tdefaultBaseModelName,\n\t\t\t\t);\n\n\t\t\t\tlet isForwardJoin = true;\n\n\t\t\t\t// If no forward join found, check backwards: does the base model have FKs to the joined model?\n\t\t\t\tif (!foreignKeys.length) {\n\t\t\t\t\tforeignKeys = Object.entries(\n\t\t\t\t\t\tschema[defaultBaseModelName]!.fields,\n\t\t\t\t\t).filter(\n\t\t\t\t\t\t([field, fieldAttributes]) =>\n\t\t\t\t\t\t\tfieldAttributes.references &&\n\t\t\t\t\t\t\tgetDefaultModelName(fieldAttributes.references.model) ===\n\t\t\t\t\t\t\t\tdefaultModelName,\n\t\t\t\t\t);\n\t\t\t\t\tisForwardJoin = false;\n\t\t\t\t}\n\n\t\t\t\tif (!foreignKeys.length) {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t`No foreign key found for model ${model} and base model ${baseModel} while performing join operation.`,\n\t\t\t\t\t);\n\t\t\t\t} else if (foreignKeys.length > 1) {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t`Multiple foreign keys found for model ${model} and base model ${baseModel} while performing join operation. Only one foreign key is supported.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [foreignKey, foreignKeyAttributes] = foreignKeys[0]!;\n\t\t\t\tif (!foreignKeyAttributes.references) {\n\t\t\t\t\t// this should never happen, as we filter for references in the foreign keys.\n\t\t\t\t\t// it's here for typescript to be happy.\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t`No references found for foreign key ${foreignKey} on model ${model} while performing join operation.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet from: string;\n\t\t\t\tlet to: string;\n\t\t\t\tlet requiredSelectField: string;\n\n\t\t\t\tif (isForwardJoin) {\n\t\t\t\t\t// joined model has FK to base model\n\t\t\t\t\t// The field we need in select is the referenced field in the base model\n\t\t\t\t\trequiredSelectField = foreignKeyAttributes.references.field;\n\t\t\t\t\tfrom = getFieldName({\n\t\t\t\t\t\tmodel: baseModel,\n\t\t\t\t\t\tfield: requiredSelectField,\n\t\t\t\t\t});\n\n\t\t\t\t\tto = getFieldName({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tfield: foreignKey,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// base model has FK to joined model\n\t\t\t\t\t// The field we need in select is the foreign key field in the base model\n\t\t\t\t\trequiredSelectField = foreignKey;\n\t\t\t\t\tfrom = getFieldName({\n\t\t\t\t\t\tmodel: baseModel,\n\t\t\t\t\t\tfield: requiredSelectField,\n\t\t\t\t\t});\n\n\t\t\t\t\tto = getFieldName({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tfield: foreignKeyAttributes.references.field,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Ensure the required field is in select if select is provided\n\t\t\t\tif (select && !select.includes(requiredSelectField)) {\n\t\t\t\t\tselect.push(requiredSelectField);\n\t\t\t\t}\n\n\t\t\t\tconst isUnique =\n\t\t\t\t\tto === \"id\" ? true : (foreignKeyAttributes.unique ?? false);\n\n\t\t\t\tlet limit: number =\n\t\t\t\t\toptions.advanced?.database?.defaultFindManyLimit ?? 100;\n\t\t\t\tif (isUnique) {\n\t\t\t\t\tlimit = 1;\n\t\t\t\t} else if (typeof join === \"object\" && typeof join.limit === \"number\") {\n\t\t\t\t\tlimit = join.limit;\n\t\t\t\t}\n\n\t\t\t\ttransformedJoin[getModelName(model)] = {\n\t\t\t\t\ton: {\n\t\t\t\t\t\tfrom,\n\t\t\t\t\t\tto,\n\t\t\t\t\t},\n\t\t\t\t\tlimit,\n\t\t\t\t\trelation: isUnique ? \"one-to-one\" : \"one-to-many\",\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn { join: transformedJoin, select };\n\t\t};\n\n\t\t/**\n\t\t * Handle joins by making separate queries and combining results (fallback for adapters that don't support native joins).\n\t\t */\n\t\tconst handleFallbackJoin = async <T extends Record<string, any> | null>({\n\t\t\tbaseModel,\n\t\t\tbaseData,\n\t\t\tjoinModel,\n\t\t\tspecificJoinConfig: joinConfig,\n\t\t}: {\n\t\t\tbaseModel: string;\n\t\t\tbaseData: T;\n\t\t\tjoinModel: string;\n\t\t\tspecificJoinConfig: JoinConfig[number];\n\t\t}) => {\n\t\t\tif (!baseData) return baseData;\n\t\t\tconst modelName = getModelName(joinModel);\n\t\t\tconst field = joinConfig.on.to;\n\t\t\tconst value =\n\t\t\t\tbaseData[\n\t\t\t\t\tgetDefaultFieldName({ field: joinConfig.on.from, model: baseModel })\n\t\t\t\t];\n\n\t\t\tif (value === null || value === undefined) {\n\t\t\t\t// If there is no value, it could mean that the query used a `select` clause that didn't include the field.\n\t\t\t\t// or the query result is purely empty.\n\t\t\t\t// In any case, we return null/empty array.\n\t\t\t\treturn joinConfig.relation === \"one-to-one\" ? null : [];\n\t\t\t}\n\t\t\tlet result: Record<string, any> | Record<string, any>[] | null;\n\t\t\tconst where = transformWhereClause({\n\t\t\t\tmodel: modelName,\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\toperator: \"eq\",\n\t\t\t\t\t\tconnector: \"AND\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\taction: \"findOne\",\n\t\t\t});\n\t\t\ttry {\n\t\t\t\tif (joinConfig.relation === \"one-to-one\") {\n\t\t\t\t\tresult = await adapterInstance.findOne<Record<string, any>>({\n\t\t\t\t\t\tmodel: modelName,\n\t\t\t\t\t\twhere: where,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconst limit =\n\t\t\t\t\t\tjoinConfig.limit ??\n\t\t\t\t\t\toptions.advanced?.database?.defaultFindManyLimit ??\n\t\t\t\t\t\t100;\n\t\t\t\t\tresult = await adapterInstance.findMany<Record<string, any>>({\n\t\t\t\t\t\tmodel: modelName,\n\t\t\t\t\t\twhere: where,\n\t\t\t\t\t\tlimit,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(`Failed to query fallback join for model ${modelName}:`, {\n\t\t\t\t\twhere,\n\t\t\t\t\tlimit: joinConfig.limit,\n\t\t\t\t});\n\t\t\t\tconsole.error(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tconst adapterInstance = customAdapter({\n\t\t\toptions,\n\t\t\tschema,\n\t\t\tdebugLog,\n\t\t\tgetFieldName,\n\t\t\tgetModelName,\n\t\t\tgetDefaultModelName,\n\t\t\tgetDefaultFieldName,\n\t\t\tgetFieldAttributes,\n\t\t\ttransformInput,\n\t\t\ttransformOutput,\n\t\t\ttransformWhereClause,\n\t\t});\n\n\t\tlet lazyLoadTransaction:\n\t\t\t| DBAdapter<BetterAuthOptions>[\"transaction\"]\n\t\t\t| null = null;\n\t\tconst adapter: DBAdapter<BetterAuthOptions> = {\n\t\t\ttransaction: async (cb) => {\n\t\t\t\tif (!lazyLoadTransaction) {\n\t\t\t\t\tif (!config.transaction) {\n\t\t\t\t\t\tlazyLoadTransaction = createAsIsTransaction(adapter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t`[${config.adapterName}] - Using provided transaction implementation.`,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlazyLoadTransaction = config.transaction;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn lazyLoadTransaction(cb);\n\t\t\t},\n\t\t\tcreate: async <T extends Record<string, any>, R = T>({\n\t\t\t\tdata: unsafeData,\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\tselect,\n\t\t\t\tforceAllowId = false,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\tdata: T;\n\t\t\t\tselect?: string[];\n\t\t\t\tforceAllowId?: boolean;\n\t\t\t}): Promise<R> => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tif (\n\t\t\t\t\t\"id\" in unsafeData &&\n\t\t\t\t\ttypeof unsafeData.id !== \"undefined\" &&\n\t\t\t\t\t!forceAllowId\n\t\t\t\t) {\n\t\t\t\t\t// The reason why `forceAllowId` was introduced was because we used to handle\n\t\t\t\t\t// id generation ourselves (eg adapter.create({ data: { id: \"123\" } }))\n\t\t\t\t\t// This was bad as certain things (such as number ids) would not work as expected.\n\t\t\t\t\t// Since then, we have introduced the `forceAllowId` parameter to allow users to\n\t\t\t\t\t// bypass this check. Otherwise, we would throw a warning stating that the id will be ignored\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`[${config.adapterName}] - You are trying to create a record with an id. This is not allowed as we handle id generation for you, unless you pass in the \\`forceAllowId\\` parameter. The id will be ignored.`,\n\t\t\t\t\t);\n\t\t\t\t\tconst err = new Error();\n\t\t\t\t\tconst stack = err.stack\n\t\t\t\t\t\t?.split(\"\\n\")\n\t\t\t\t\t\t.filter((_, i) => i !== 1)\n\t\t\t\t\t\t.join(\"\\n\")\n\t\t\t\t\t\t.replace(\"Error:\", \"Create method with `id` being called at:\");\n\t\t\t\t\tconsole.log(stack);\n\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\tunsafeData.id = undefined;\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"create\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`,\n\t\t\t\t\t`${formatMethod(\"create\")} ${formatAction(\"Unsafe Input\")}:`,\n\t\t\t\t\t{ model, data: unsafeData },\n\t\t\t\t);\n\t\t\t\tlet data = unsafeData;\n\t\t\t\tif (!config.disableTransformInput) {\n\t\t\t\t\tdata = (await transformInput(\n\t\t\t\t\t\tunsafeData,\n\t\t\t\t\t\tunsafeModel,\n\t\t\t\t\t\t\"create\",\n\t\t\t\t\t\tforceAllowId,\n\t\t\t\t\t)) as T;\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"create\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`,\n\t\t\t\t\t`${formatMethod(\"create\")} ${formatAction(\"Parsed Input\")}:`,\n\t\t\t\t\t{ model, data },\n\t\t\t\t);\n\t\t\t\tconst res = await adapterInstance.create<T>({ data, model });\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"create\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`,\n\t\t\t\t\t`${formatMethod(\"create\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model, res },\n\t\t\t\t);\n\t\t\t\tlet transformed = res as any;\n\t\t\t\tif (!config.disableTransformOutput) {\n\t\t\t\t\ttransformed = await transformOutput(\n\t\t\t\t\t\tres as any,\n\t\t\t\t\t\tunsafeModel,\n\t\t\t\t\t\tselect,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"create\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`,\n\t\t\t\t\t`${formatMethod(\"create\")} ${formatAction(\"Parsed Result\")}:`,\n\t\t\t\t\t{ model, data: transformed },\n\t\t\t\t);\n\t\t\t\treturn transformed;\n\t\t\t},\n\t\t\tupdate: async <T>({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t\tupdate: unsafeData,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere: Where[];\n\t\t\t\tupdate: Record<string, any>;\n\t\t\t}): Promise<T | null> => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"update\",\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"update\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`,\n\t\t\t\t\t`${formatMethod(\"update\")} ${formatAction(\"Unsafe Input\")}:`,\n\t\t\t\t\t{ model, data: unsafeData },\n\t\t\t\t);\n\t\t\t\tlet data = unsafeData as T;\n\t\t\t\tif (!config.disableTransformInput) {\n\t\t\t\t\tdata = (await transformInput(unsafeData, unsafeModel, \"update\")) as T;\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"update\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`,\n\t\t\t\t\t`${formatMethod(\"update\")} ${formatAction(\"Parsed Input\")}:`,\n\t\t\t\t\t{ model, data },\n\t\t\t\t);\n\t\t\t\tconst res = await adapterInstance.update<T>({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t\tupdate: data,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"update\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`,\n\t\t\t\t\t`${formatMethod(\"update\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model, data: res },\n\t\t\t\t);\n\t\t\t\tlet transformed = res as any;\n\t\t\t\tif (!config.disableTransformOutput) {\n\t\t\t\t\ttransformed = await transformOutput(\n\t\t\t\t\t\tres as any,\n\t\t\t\t\t\tunsafeModel,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"update\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`,\n\t\t\t\t\t`${formatMethod(\"update\")} ${formatAction(\"Parsed Result\")}:`,\n\t\t\t\t\t{ model, data: transformed },\n\t\t\t\t);\n\t\t\t\treturn transformed;\n\t\t\t},\n\t\t\tupdateMany: async ({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t\tupdate: unsafeData,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere: Where[];\n\t\t\t\tupdate: Record<string, any>;\n\t\t\t}) => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"updateMany\",\n\t\t\t\t});\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"updateMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 4)}`,\n\t\t\t\t\t`${formatMethod(\"updateMany\")} ${formatAction(\"Unsafe Input\")}:`,\n\t\t\t\t\t{ model, data: unsafeData },\n\t\t\t\t);\n\t\t\t\tlet data = unsafeData;\n\t\t\t\tif (!config.disableTransformInput) {\n\t\t\t\t\tdata = await transformInput(unsafeData, unsafeModel, \"update\");\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"updateMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 4)}`,\n\t\t\t\t\t`${formatMethod(\"updateMany\")} ${formatAction(\"Parsed Input\")}:`,\n\t\t\t\t\t{ model, data },\n\t\t\t\t);\n\n\t\t\t\tconst updatedCount = await adapterInstance.updateMany({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t\tupdate: data,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"updateMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(3, 4)}`,\n\t\t\t\t\t`${formatMethod(\"updateMany\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model, data: updatedCount },\n\t\t\t\t);\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"updateMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(4, 4)}`,\n\t\t\t\t\t`${formatMethod(\"updateMany\")} ${formatAction(\"Parsed Result\")}:`,\n\t\t\t\t\t{ model, data: updatedCount },\n\t\t\t\t);\n\t\t\t\treturn updatedCount;\n\t\t\t},\n\t\t\tfindOne: async <T extends Record<string, any>>({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t\tselect,\n\t\t\t\tjoin: unsafeJoin,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere: Where[];\n\t\t\t\tselect?: string[];\n\t\t\t\tjoin?: JoinOption;\n\t\t\t}) => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"findOne\",\n\t\t\t\t});\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tlet join: JoinConfig | undefined;\n\t\t\t\tlet passJoinToAdapter = true;\n\t\t\t\tif (!config.disableTransformJoin) {\n\t\t\t\t\tconst result = transformJoinClause(unsafeModel, unsafeJoin, select);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tjoin = result.join;\n\t\t\t\t\t\tselect = result.select;\n\t\t\t\t\t}\n\t\t\t\t\t// If adapter doesn't support joins and we have joins, don't pass them to the adapter\n\t\t\t\t\tconst experimentalJoins = options.experimental?.joins;\n\t\t\t\t\tif (!experimentalJoins && join && Object.keys(join).length > 0) {\n\t\t\t\t\t\tpassJoinToAdapter = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// assume it's already transformed if transformation is disabled\n\t\t\t\t\tjoin = unsafeJoin as never as JoinConfig;\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"findOne\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 3)}`,\n\t\t\t\t\t`${formatMethod(\"findOne\")}:`,\n\t\t\t\t\t{ model, where, select, join },\n\t\t\t\t);\n\n\t\t\t\tconst res = await adapterInstance.findOne<T>({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t\tselect,\n\t\t\t\t\tjoin: passJoinToAdapter ? join : undefined,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"findOne\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 3)}`,\n\t\t\t\t\t`${formatMethod(\"findOne\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model, data: res },\n\t\t\t\t);\n\n\t\t\t\t// Handle fallback join if adapter doesn't support joins\n\t\t\t\tlet transformed = res as any;\n\t\t\t\tif (!config.disableTransformOutput) {\n\t\t\t\t\ttransformed = await transformOutput(res, unsafeModel, select, join);\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"findOne\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(3, 3)}`,\n\t\t\t\t\t`${formatMethod(\"findOne\")} ${formatAction(\"Parsed Result\")}:`,\n\t\t\t\t\t{ model, data: transformed },\n\t\t\t\t);\n\t\t\t\treturn transformed;\n\t\t\t},\n\t\t\tfindMany: async <T extends Record<string, any>>({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t\tlimit: unsafeLimit,\n\t\t\t\tsortBy,\n\t\t\t\toffset,\n\t\t\t\tjoin: unsafeJoin,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere?: Where[];\n\t\t\t\tlimit?: number;\n\t\t\t\tsortBy?: { field: string; direction: \"asc\" | \"desc\" };\n\t\t\t\toffset?: number;\n\t\t\t\tjoin?: JoinOption;\n\t\t\t}) => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst limit =\n\t\t\t\t\tunsafeLimit ??\n\t\t\t\t\toptions.advanced?.database?.defaultFindManyLimit ??\n\t\t\t\t\t100;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"findMany\",\n\t\t\t\t});\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tlet join: JoinConfig | undefined;\n\t\t\t\tlet passJoinToAdapter = true;\n\t\t\t\tif (!config.disableTransformJoin) {\n\t\t\t\t\tconst result = transformJoinClause(\n\t\t\t\t\t\tunsafeModel,\n\t\t\t\t\t\tunsafeJoin,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tjoin = result.join;\n\t\t\t\t\t}\n\t\t\t\t\t// If adapter doesn't support joins and we have joins, don't pass them to the adapter\n\t\t\t\t\tconst experimentalJoins = options.experimental?.joins;\n\t\t\t\t\tif (!experimentalJoins && join && Object.keys(join).length > 0) {\n\t\t\t\t\t\tpassJoinToAdapter = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// assume it's already transformed if transformation is disabled\n\t\t\t\t\tjoin = unsafeJoin as never as JoinConfig;\n\t\t\t\t}\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"findMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 3)}`,\n\t\t\t\t\t`${formatMethod(\"findMany\")}:`,\n\t\t\t\t\t{ model, where, limit, sortBy, offset, join },\n\t\t\t\t);\n\t\t\t\tconst res = await adapterInstance.findMany<T>({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t\tlimit: limit,\n\t\t\t\t\tsortBy,\n\t\t\t\t\toffset,\n\t\t\t\t\tjoin: passJoinToAdapter ? join : undefined,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"findMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 3)}`,\n\t\t\t\t\t`${formatMethod(\"findMany\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model, data: res },\n\t\t\t\t);\n\n\t\t\t\tlet transformed = res as any;\n\t\t\t\tif (!config.disableTransformOutput) {\n\t\t\t\t\ttransformed = await Promise.all(\n\t\t\t\t\t\tres.map(async (r: Record<string, any>) => {\n\t\t\t\t\t\t\treturn await transformOutput(r, unsafeModel, undefined, join);\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"findMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(3, 3)}`,\n\t\t\t\t\t`${formatMethod(\"findMany\")} ${formatAction(\"Parsed Result\")}:`,\n\t\t\t\t\t{ model, data: transformed },\n\t\t\t\t);\n\t\t\t\treturn transformed;\n\t\t\t},\n\t\t\tdelete: async ({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere: Where[];\n\t\t\t}) => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"delete\",\n\t\t\t\t});\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"delete\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`,\n\t\t\t\t\t`${formatMethod(\"delete\")}:`,\n\t\t\t\t\t{ model, where },\n\t\t\t\t);\n\t\t\t\tawait adapterInstance.delete({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"delete\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`,\n\t\t\t\t\t`${formatMethod(\"delete\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model },\n\t\t\t\t);\n\t\t\t},\n\t\t\tdeleteMany: async ({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere: Where[];\n\t\t\t}) => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"deleteMany\",\n\t\t\t\t});\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"deleteMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`,\n\t\t\t\t\t`${formatMethod(\"deleteMany\")} ${formatAction(\"DeleteMany\")}:`,\n\t\t\t\t\t{ model, where },\n\t\t\t\t);\n\t\t\t\tconst res = await adapterInstance.deleteMany({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"deleteMany\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`,\n\t\t\t\t\t`${formatMethod(\"deleteMany\")} ${formatAction(\"DB Result\")}:`,\n\t\t\t\t\t{ model, data: res },\n\t\t\t\t);\n\t\t\t\treturn res;\n\t\t\t},\n\t\t\tcount: async ({\n\t\t\t\tmodel: unsafeModel,\n\t\t\t\twhere: unsafeWhere,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere?: Where[];\n\t\t\t}) => {\n\t\t\t\ttransactionId++;\n\t\t\t\tconst thisTransactionId = transactionId;\n\t\t\t\tconst model = getModelName(unsafeModel);\n\t\t\t\tconst where = transformWhereClause({\n\t\t\t\t\tmodel: unsafeModel,\n\t\t\t\t\twhere: unsafeWhere,\n\t\t\t\t\taction: \"count\",\n\t\t\t\t});\n\t\t\t\tunsafeModel = getDefaultModelName(unsafeModel);\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"count\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(1, 2)}`,\n\t\t\t\t\t`${formatMethod(\"count\")}:`,\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tconst res = await adapterInstance.count({\n\t\t\t\t\tmodel,\n\t\t\t\t\twhere,\n\t\t\t\t});\n\t\t\t\tdebugLog(\n\t\t\t\t\t{ method: \"count\" },\n\t\t\t\t\t`${formatTransactionId(thisTransactionId)} ${formatStep(2, 2)}`,\n\t\t\t\t\t`${formatMethod(\"count\")}:`,\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tdata: res,\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\treturn res;\n\t\t\t},\n\t\t\tcreateSchema: adapterInstance.createSchema\n\t\t\t\t? async (_, file) => {\n\t\t\t\t\t\tconst tables = getAuthTables(options);\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\toptions.secondaryStorage &&\n\t\t\t\t\t\t\t!options.session?.storeSessionInDatabase\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// biome-ignore lint/performance/noDelete: If the user has enabled secondaryStorage, as well as not specifying to store session table in DB, then createSchema shouldn't generate schema table.\n\t\t\t\t\t\t\tdelete tables.session;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn adapterInstance.createSchema!({ file, tables });\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t\t\toptions: {\n\t\t\t\tadapterConfig: config,\n\t\t\t\t...(adapterInstance.options ?? {}),\n\t\t\t},\n\t\t\tid: config.adapterId,\n\n\t\t\t// Secretly export values ONLY if this adapter has enabled adapter-test-debug-logs.\n\t\t\t// This would then be used during our adapter-tests to help print debug logs if a test fails.\n\t\t\t//@ts-expect-error - ^^\n\t\t\t...(config.debugLogs?.isRunningAdapterTests\n\t\t\t\t? {\n\t\t\t\t\t\tadapterTestDebugLogs: {\n\t\t\t\t\t\t\tresetDebugLogs() {\n\t\t\t\t\t\t\t\tdebugLogs = debugLogs.filter(\n\t\t\t\t\t\t\t\t\t(log) => log.instance !== uniqueAdapterFactoryInstanceId,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tprintDebugLogs() {\n\t\t\t\t\t\t\t\tconst separator = ``.repeat(80);\n\t\t\t\t\t\t\t\tconst logs = debugLogs.filter(\n\t\t\t\t\t\t\t\t\t(log) => log.instance === uniqueAdapterFactoryInstanceId,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (logs.length === 0) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t//`${colors.fg.blue}|${colors.reset} `,\n\t\t\t\t\t\t\t\tconst log: any[] = logs\n\t\t\t\t\t\t\t\t\t.reverse()\n\t\t\t\t\t\t\t\t\t.map((log) => {\n\t\t\t\t\t\t\t\t\t\tlog.args[0] = `\\n${log.args[0]}`;\n\t\t\t\t\t\t\t\t\t\treturn [...log.args, \"\\n\"];\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t.reduce(\n\t\t\t\t\t\t\t\t\t\t(prev, curr) => {\n\t\t\t\t\t\t\t\t\t\t\treturn [...curr, ...prev];\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t[`\\n${separator}`],\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tconsole.log(...log);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} satisfies AdapterTestDebugLogs,\n\t\t\t\t\t}\n\t\t\t\t: {}),\n\t\t};\n\t\treturn adapter;\n\t};\n\nfunction formatTransactionId(transactionId: number) {\n\tif (getColorDepth() < 8) {\n\t\treturn `#${transactionId}`;\n\t}\n\treturn `${TTY_COLORS.fg.magenta}#${transactionId}${TTY_COLORS.reset}`;\n}\n\nfunction formatStep(step: number, total: number) {\n\treturn `${TTY_COLORS.bg.black}${TTY_COLORS.fg.yellow}[${step}/${total}]${TTY_COLORS.reset}`;\n}\n\nfunction formatMethod(method: string) {\n\treturn `${TTY_COLORS.bright}${method}${TTY_COLORS.reset}`;\n}\n\nfunction formatAction(action: string) {\n\treturn `${TTY_COLORS.dim}(${action})${TTY_COLORS.reset}`;\n}\n\n/**\n * @deprecated Use `createAdapterFactory` instead. This export will be removed in a future version.\n * @alias\n */\nexport const createAdapter = createAdapterFactory;\n"],"names":["shouldGenerateId: boolean","m","f","result: Record<string, unknown>","generateId","defaultGenerateId","debugLogs: { instance: string; args: any[] }[]","logger","transformedData: Record<string, any>","newFieldName: string","data","unsafe_model","select","transformedData","fieldName: string","transformedJoin: JoinConfig","from: string","to: string","requiredSelectField: string","limit: number","result: Record<string, any> | Record<string, any>[] | null","lazyLoadTransaction:\n\t\t\t| DBAdapter<BetterAuthOptions>[\"transaction\"]\n\t\t\t| null","adapter: DBAdapter<BetterAuthOptions>","join: JoinConfig | undefined","log","log: any[]","transactionId"],"mappings":"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","ignoreList":[1,2,3,4,5,6,7,8,9]}