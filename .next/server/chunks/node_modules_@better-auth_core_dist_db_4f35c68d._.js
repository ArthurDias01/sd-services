module.exports = [
  69774,
  (e) => {
    "use strict";
    let t = (e) => {
      let t = (e.plugins ?? []).reduce((e, t) => {
          let r = t.schema;
          if (!r) return e;
          for (let [t, a] of Object.entries(r))
            e[t] = { fields: { ...e[t]?.fields, ...a.fields }, modelName: a.modelName || t };
          return e;
        }, {}),
        r = e.rateLimit?.storage === "database",
        a = {
          rateLimit: {
            modelName: e.rateLimit?.modelName || "rateLimit",
            fields: {
              key: {
                type: "string",
                unique: !0,
                required: !0,
                fieldName: e.rateLimit?.fields?.key || "key",
              },
              count: {
                type: "number",
                required: !0,
                fieldName: e.rateLimit?.fields?.count || "count",
              },
              lastRequest: {
                type: "number",
                bigint: !0,
                required: !0,
                fieldName: e.rateLimit?.fields?.lastRequest || "lastRequest",
                defaultValue: () => Date.now(),
              },
            },
          },
        },
        { user: i, session: d, account: n, verification: s, ...o } = t,
        l = {
          session: {
            modelName: e.session?.modelName || "session",
            fields: {
              expiresAt: {
                type: "date",
                required: !0,
                fieldName: e.session?.fields?.expiresAt || "expiresAt",
              },
              token: {
                type: "string",
                required: !0,
                fieldName: e.session?.fields?.token || "token",
                unique: !0,
              },
              createdAt: {
                type: "date",
                required: !0,
                fieldName: e.session?.fields?.createdAt || "createdAt",
                defaultValue: () => new Date(),
              },
              updatedAt: {
                type: "date",
                required: !0,
                fieldName: e.session?.fields?.updatedAt || "updatedAt",
                onUpdate: () => new Date(),
              },
              ipAddress: {
                type: "string",
                required: !1,
                fieldName: e.session?.fields?.ipAddress || "ipAddress",
              },
              userAgent: {
                type: "string",
                required: !1,
                fieldName: e.session?.fields?.userAgent || "userAgent",
              },
              userId: {
                type: "string",
                fieldName: e.session?.fields?.userId || "userId",
                references: {
                  model: e.user?.modelName || "user",
                  field: "id",
                  onDelete: "cascade",
                },
                required: !0,
                index: !0,
              },
              ...d?.fields,
              ...e.session?.additionalFields,
            },
            order: 2,
          },
        };
      return {
        user: {
          modelName: e.user?.modelName || "user",
          fields: {
            name: {
              type: "string",
              required: !0,
              fieldName: e.user?.fields?.name || "name",
              sortable: !0,
            },
            email: {
              type: "string",
              unique: !0,
              required: !0,
              fieldName: e.user?.fields?.email || "email",
              sortable: !0,
            },
            emailVerified: {
              type: "boolean",
              defaultValue: !1,
              required: !0,
              fieldName: e.user?.fields?.emailVerified || "emailVerified",
              input: !1,
            },
            image: { type: "string", required: !1, fieldName: e.user?.fields?.image || "image" },
            createdAt: {
              type: "date",
              defaultValue: () => new Date(),
              required: !0,
              fieldName: e.user?.fields?.createdAt || "createdAt",
            },
            updatedAt: {
              type: "date",
              defaultValue: () => new Date(),
              onUpdate: () => new Date(),
              required: !0,
              fieldName: e.user?.fields?.updatedAt || "updatedAt",
            },
            ...i?.fields,
            ...e.user?.additionalFields,
          },
          order: 1,
        },
        ...(!e.secondaryStorage || e.session?.storeSessionInDatabase ? l : {}),
        account: {
          modelName: e.account?.modelName || "account",
          fields: {
            accountId: {
              type: "string",
              required: !0,
              fieldName: e.account?.fields?.accountId || "accountId",
            },
            providerId: {
              type: "string",
              required: !0,
              fieldName: e.account?.fields?.providerId || "providerId",
            },
            userId: {
              type: "string",
              references: { model: e.user?.modelName || "user", field: "id", onDelete: "cascade" },
              required: !0,
              fieldName: e.account?.fields?.userId || "userId",
              index: !0,
            },
            accessToken: {
              type: "string",
              required: !1,
              returned: !1,
              fieldName: e.account?.fields?.accessToken || "accessToken",
            },
            refreshToken: {
              type: "string",
              required: !1,
              returned: !1,
              fieldName: e.account?.fields?.refreshToken || "refreshToken",
            },
            idToken: {
              type: "string",
              required: !1,
              returned: !1,
              fieldName: e.account?.fields?.idToken || "idToken",
            },
            accessTokenExpiresAt: {
              type: "date",
              required: !1,
              returned: !1,
              fieldName: e.account?.fields?.accessTokenExpiresAt || "accessTokenExpiresAt",
            },
            refreshTokenExpiresAt: {
              type: "date",
              required: !1,
              returned: !1,
              fieldName: e.account?.fields?.refreshTokenExpiresAt || "refreshTokenExpiresAt",
            },
            scope: { type: "string", required: !1, fieldName: e.account?.fields?.scope || "scope" },
            password: {
              type: "string",
              required: !1,
              returned: !1,
              fieldName: e.account?.fields?.password || "password",
            },
            createdAt: {
              type: "date",
              required: !0,
              fieldName: e.account?.fields?.createdAt || "createdAt",
              defaultValue: () => new Date(),
            },
            updatedAt: {
              type: "date",
              required: !0,
              fieldName: e.account?.fields?.updatedAt || "updatedAt",
              onUpdate: () => new Date(),
            },
            ...n?.fields,
            ...e.account?.additionalFields,
          },
          order: 3,
        },
        verification: {
          modelName: e.verification?.modelName || "verification",
          fields: {
            identifier: {
              type: "string",
              required: !0,
              fieldName: e.verification?.fields?.identifier || "identifier",
              index: !0,
            },
            value: {
              type: "string",
              required: !0,
              fieldName: e.verification?.fields?.value || "value",
            },
            expiresAt: {
              type: "date",
              required: !0,
              fieldName: e.verification?.fields?.expiresAt || "expiresAt",
            },
            createdAt: {
              type: "date",
              required: !0,
              defaultValue: () => new Date(),
              fieldName: e.verification?.fields?.createdAt || "createdAt",
            },
            updatedAt: {
              type: "date",
              required: !0,
              defaultValue: () => new Date(),
              onUpdate: () => new Date(),
              fieldName: e.verification?.fields?.updatedAt || "updatedAt",
            },
            ...s?.fields,
            ...e.verification?.additionalFields,
          },
          order: 4,
        },
        ...o,
        ...(r ? a : {}),
      };
    };
    e.s(["getAuthTables", () => t]);
  },
  67200,
  82868,
  24891,
  26388,
  46378,
  31139,
  71928,
  (e) => {
    "use strict";
    var t = e.i(71616);
    let r =
      ({ usePlural: e, schema: r }) =>
      (a) => {
        if (e && "s" === a.charAt(a.length - 1)) {
          let e = a.slice(0, -1),
            t = r[e] ? e : void 0;
          if ((t || (t = Object.entries(r).find(([t, r]) => r.modelName === e)?.[0]), t)) return t;
        }
        let i = r[a] ? a : void 0;
        if ((i || (i = Object.entries(r).find(([e, t]) => t.modelName === a)?.[0]), !i))
          throw new t.BetterAuthError(`Model "${a}" not found in schema`);
        return i;
      };
    e.s(["initGetDefaultModelName", () => r], 67200);
    let a = ({ schema: e, usePlural: a }) => {
      let i = r({ schema: e, usePlural: a });
      return ({ field: r, model: a }) => {
        if ("id" === r || "_id" === r) return "id";
        let d = i(a),
          n = e[d]?.fields[r];
        if (!n) {
          let t = Object.entries(e[d].fields).find(([e, t]) => t.fieldName === r);
          t && ((n = t[1]), (r = t[0]));
        }
        if (!n) throw new t.BetterAuthError(`Field ${r} not found in model ${d}`);
        return r;
      };
    };
    e.s(["initGetDefaultFieldName", () => a], 82868);
    var i = e.i(90126);
    e.i(89139);
    var d = e.i(18195);
    e.i(36447);
    let n = ({
      usePlural: e,
      schema: t,
      disableIdGeneration: a,
      options: n,
      customIdGenerator: s,
      supportsUUIDs: o,
    }) => {
      let l = r({ usePlural: e, schema: t });
      return ({ customModelName: e, forceAllowId: t }) => {
        let r = n.advanced?.database?.useNumberId || n.advanced?.database?.generateId === "serial",
          u = n.advanced?.database?.generateId === "uuid",
          f = !a && (!r || !!t) && (!u || !o),
          p = l(e ?? "id");
        return {
          type: r ? "number" : "string",
          required: !!f,
          ...(f
            ? {
                defaultValue() {
                  if (a) return;
                  let e = n.advanced?.database?.generateId;
                  if (!1 !== e && !r)
                    return "function" == typeof e
                      ? e({ model: p })
                      : s
                        ? s({ model: p })
                        : "uuid" === e
                          ? crypto.randomUUID()
                          : (0, d.generateId)();
                },
              }
            : {}),
          transform: {
            input: (e) => {
              if (e) {
                if (r) {
                  let t = Number(e);
                  if (isNaN(t)) return;
                  return t;
                }
                if (u) {
                  if (f && !t) return e;
                  if (a || o) return;
                  if (t && "string" == typeof e)
                    if (
                      /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
                        e,
                      )
                    )
                      return e;
                    else {
                      let e = Error()
                        .stack?.split("\n")
                        .filter((e, t) => 1 !== t)
                        .join("\n")
                        .replace("Error:", "");
                      i.logger.warn(
                        "[Adapter Factory] - Invalid UUID value for field `id` provided when `forceAllowId` is true. Generating a new UUID.",
                        e,
                      );
                    }
                  return "string" == typeof e || o ? void 0 : crypto.randomUUID();
                }
                return e;
              }
            },
            output: (e) => {
              if (e) return String(e);
            },
          },
        };
      };
    };
    e.s(["initGetIdField", () => n], 24891);
    let s = ({
      usePlural: e,
      schema: i,
      options: d,
      customIdGenerator: s,
      disableIdGeneration: o,
    }) => {
      let l = r({ usePlural: e, schema: i }),
        u = a({ usePlural: e, schema: i }),
        f = n({
          usePlural: e,
          schema: i,
          options: d,
          customIdGenerator: s,
          disableIdGeneration: o,
        });
      return ({ model: e, field: r }) => {
        let a = l(e),
          d = u({ field: r, model: a }),
          n = i[a].fields;
        n.id = f({ customModelName: a });
        let s = n[d];
        if (!s) throw new t.BetterAuthError(`Field ${r} not found in model ${e}`);
        return s;
      };
    };
    e.s(["initGetFieldAttributes", () => s], 26388);
    let o = ({ schema: e, usePlural: t }) => {
      let i = r({ schema: e, usePlural: t }),
        d = a({ schema: e, usePlural: t });
      return function ({ model: t, field: r }) {
        let a = i(t),
          n = d({ model: a, field: r });
        return e[a]?.fields[n]?.fieldName || n;
      };
    };
    e.s(["initGetFieldName", () => o], 46378);
    let l = ({ usePlural: e, schema: t }) => {
      let a = r({ schema: t, usePlural: e });
      return (r) => {
        let i = a(r);
        return t && t[i] && t[i].modelName !== r
          ? e
            ? `${t[i].modelName}s`
            : t[i].modelName
          : e
            ? `${r}s`
            : r;
      };
    };
    function u(e, t, r) {
      if ("update" === r)
        return void 0 === e && void 0 !== t.onUpdate
          ? "function" == typeof t.onUpdate
            ? t.onUpdate()
            : t.onUpdate
          : e;
      return "create" === r &&
        (void 0 === e || (!0 === t.required && null === e)) &&
        void 0 !== t.defaultValue
        ? "function" == typeof t.defaultValue
          ? t.defaultValue()
          : t.defaultValue
        : e;
    }
    function f(e) {
      return null !== e && "object" == typeof e && !Array.isArray(e);
    }
    (e.s(["initGetModelName", () => l], 31139),
      e.s(
        [
          "deepmerge",
          () =>
            function e(t, r) {
              if (Array.isArray(t) && Array.isArray(r)) return [...t, ...r];
              if (f(t) && f(r)) {
                let a = { ...t };
                for (let [i, d] of Object.entries(r))
                  void 0 !== d && (i in t ? (a[i] = e(t[i], d)) : (a[i] = d));
                return a;
              }
              return r;
            },
          "withApplyDefault",
          () => u,
        ],
        71928,
      ));
  },
  76757,
  5284,
  (e) => {
    "use strict";
    var t = e.i(67200),
      r = e.i(82868),
      a = e.i(24891),
      i = e.i(26388),
      d = e.i(46378),
      n = e.i(31139),
      s = e.i(71928),
      o = e.i(69774),
      l = e.i(83698),
      u = e.i(90126);
    e.i(89139);
    var f = e.i(30283),
      p = e.i(71616);
    let m = [],
      c = -1,
      y =
        ({ adapter: e, config: l }) =>
        (y) => {
          let N = Math.random().toString(36).substring(2, 15),
            A = {
              ...l,
              supportsBooleans: l.supportsBooleans ?? !0,
              supportsDates: l.supportsDates ?? !0,
              supportsJSON: l.supportsJSON ?? !1,
              adapterName: l.adapterName ?? l.adapterId,
              supportsNumericIds: l.supportsNumericIds ?? !0,
              supportsUUIDs: l.supportsUUIDs ?? !1,
              supportsArrays: l.supportsArrays ?? !1,
              transaction: l.transaction ?? !1,
              disableTransformInput: l.disableTransformInput ?? !1,
              disableTransformOutput: l.disableTransformOutput ?? !1,
              disableTransformJoin: l.disableTransformJoin ?? !1,
            };
          if (
            (y.advanced?.database?.useNumberId === !0 ||
              y.advanced?.database?.generateId === "serial") &&
            !1 === A.supportsNumericIds
          )
            throw new p.BetterAuthError(
              `[${A.adapterName}] Your database or database adapter does not support numeric ids. Please disable "useNumberId" in your config.`,
            );
          let w = (0, o.getAuthTables)(y),
            I = (...e) => {
              if (!0 === A.debugLogs || "object" == typeof A.debugLogs) {
                let t = (0, u.createLogger)({ level: "info" });
                if ("object" == typeof A.debugLogs && "isRunningAdapterTests" in A.debugLogs) {
                  A.debugLogs.isRunningAdapterTests &&
                    (e.shift(), m.push({ instance: N, args: e }));
                  return;
                }
                if (
                  "object" != typeof A.debugLogs ||
                  !A.debugLogs.logCondition ||
                  A.debugLogs.logCondition?.()
                )
                  if ("object" == typeof e[0] && "method" in e[0]) {
                    let r = e.shift().method;
                    if ("object" == typeof A.debugLogs) {
                      if ("create" === r && !A.debugLogs.create) return;
                      else if ("update" === r && !A.debugLogs.update) return;
                      else if ("updateMany" === r && !A.debugLogs.updateMany) return;
                      else if ("findOne" === r && !A.debugLogs.findOne) return;
                      else if ("findMany" === r && !A.debugLogs.findMany) return;
                      else if ("delete" === r && !A.debugLogs.delete) return;
                      else if ("deleteMany" === r && !A.debugLogs.deleteMany) return;
                      else if ("count" === r && !A.debugLogs.count) return;
                    }
                    t.info(`[${A.adapterName}]`, ...e);
                  } else t.info(`[${A.adapterName}]`, ...e);
              }
            },
            O = (0, u.createLogger)(y.logger),
            T = (0, t.initGetDefaultModelName)({ usePlural: A.usePlural, schema: w }),
            v = (0, r.initGetDefaultFieldName)({ usePlural: A.usePlural, schema: w }),
            D = (0, n.initGetModelName)({ usePlural: A.usePlural, schema: w }),
            M = (0, d.initGetFieldName)({ schema: w, usePlural: A.usePlural }),
            q = (0, a.initGetIdField)({
              schema: w,
              options: y,
              usePlural: A.usePlural,
              disableIdGeneration: A.disableIdGeneration,
              customIdGenerator: A.customIdGenerator,
              supportsUUIDs: A.supportsUUIDs,
            }),
            j = (0, i.initGetFieldAttributes)({
              schema: w,
              options: y,
              usePlural: A.usePlural,
              disableIdGeneration: A.disableIdGeneration,
              customIdGenerator: A.customIdGenerator,
            }),
            L = async (e, t, r, a) => {
              let i = {},
                d = w[t].fields,
                n = A.mapKeysTransformInput ?? {},
                o =
                  y.advanced?.database?.useNumberId ||
                  y.advanced?.database?.generateId === "serial";
              for (let l in ((d.id = q({ customModelName: t, forceAllowId: a && "id" in e })), d)) {
                let a = e[l],
                  u = d[l],
                  f = n[l] || d[l].fieldName || l;
                if (
                  void 0 === a &&
                  ((void 0 === u.defaultValue &&
                    !u.transform?.input &&
                    !("update" === r && u.onUpdate)) ||
                    ("update" === r && !u.onUpdate))
                )
                  continue;
                if (u && "date" === u.type && !(a instanceof Date) && "string" == typeof a)
                  try {
                    a = new Date(a);
                  } catch {
                    O.error("[Adapter Factory] Failed to convert string to date", {
                      value: a,
                      field: l,
                    });
                  }
                let p = (0, s.withApplyDefault)(a, u, r);
                (u.transform?.input && (p = await u.transform.input(p)),
                  u.references?.field === "id" && o
                    ? (p = Array.isArray(p)
                        ? p.map((e) => (null !== e ? Number(e) : null))
                        : null !== p
                          ? Number(p)
                          : null)
                    : (!1 === A.supportsJSON && "object" == typeof p && "json" === u.type) ||
                        (!1 === A.supportsArrays &&
                          Array.isArray(p) &&
                          ("string[]" === u.type || "number[]" === u.type))
                      ? (p = JSON.stringify(p))
                      : !1 === A.supportsDates && p instanceof Date && "date" === u.type
                        ? (p = p.toISOString())
                        : !1 === A.supportsBooleans && "boolean" == typeof p && (p = +!!p),
                  A.customTransformInput &&
                    (p = A.customTransformInput({
                      data: p,
                      action: r,
                      field: f,
                      fieldAttributes: u,
                      model: D(t),
                      schema: w,
                      options: y,
                    })),
                  void 0 !== p && (i[f] = p));
              }
              return i;
            },
            k = async (e, t, r = [], a) => {
              let i = async (e, t, r = []) => {
                if (!e) return null;
                let a = A.mapKeysTransformOutput ?? {},
                  i = {},
                  d = w[T(t)].fields;
                for (let n in ((d[Object.entries(a).find(([e, t]) => "id" === t)?.[0] ?? "id"] = {
                  type:
                    y.advanced?.database?.useNumberId ||
                    y.advanced?.database?.generateId === "serial"
                      ? "number"
                      : "string",
                }),
                d)) {
                  if (r.length && !r.includes(n)) continue;
                  let s = d[n];
                  if (s) {
                    let d = s.fieldName || n,
                      o = e[Object.entries(a).find(([e, t]) => t === d)?.[0] || d];
                    s.transform?.output && (o = await s.transform.output(o));
                    let l = a[n] || n;
                    ("id" === d || s.references?.field === "id"
                      ? null != o && (o = String(o))
                      : (!1 === A.supportsJSON && "string" == typeof o && "json" === s.type) ||
                          (!1 === A.supportsArrays &&
                            "string" == typeof o &&
                            ("string[]" === s.type || "number[]" === s.type))
                        ? (o = (0, f.safeJSONParse)(o))
                        : !1 === A.supportsDates && "string" == typeof o && "date" === s.type
                          ? (o = new Date(o))
                          : !1 === A.supportsBooleans &&
                            "number" == typeof o &&
                            "boolean" === s.type &&
                            (o = 1 === o),
                      A.customTransformOutput &&
                        (o = A.customTransformOutput({
                          data: o,
                          field: l,
                          fieldAttributes: s,
                          select: r,
                          model: D(t),
                          schema: w,
                          options: y,
                        })),
                      (i[l] = o));
                  }
                }
                return i;
              };
              if (!a || 0 === Object.keys(a).length) return await i(e, t, r);
              t = T(t);
              let d = await i(e, t, r),
                n = Object.entries(a).map(([e, t]) => ({
                  modelName: D(e),
                  defaultModelName: T(e),
                  joinConfig: t,
                }));
              if (!e) return null;
              for (let { modelName: r, defaultModelName: a, joinConfig: s } of n) {
                let n = await (async () =>
                  y.experimental?.joins
                    ? e[r]
                    : await R({
                        baseModel: t,
                        baseData: d,
                        joinModel: r,
                        specificJoinConfig: s,
                      }))();
                (null == n && (n = "one-to-one" === s.relation ? null : []),
                  "one-to-many" !== s.relation || Array.isArray(n) || (n = [n]));
                let o = [];
                if (Array.isArray(n))
                  for (let e of n) {
                    let t = await i(e, r, []);
                    o.push(t);
                  }
                else {
                  let e = await i(n, r, []);
                  o.push(e);
                }
                d[a] = ("one-to-one" === s.relation ? o[0] : o) ?? null;
              }
              return d;
            },
            S = ({ model: e, where: t, action: r }) => {
              if (!t) return;
              let a = A.mapKeysTransformInput ?? {};
              return t.map((t) => {
                let { field: i, value: d, operator: n = "eq", connector: s = "AND" } = t;
                if ("in" === n && !Array.isArray(d))
                  throw new p.BetterAuthError("Value must be an array");
                let o = d,
                  l = T(e),
                  u = v({ field: i, model: e }),
                  f = a[u] || M({ field: u, model: l }),
                  m = j({ field: u, model: l }),
                  c =
                    y.advanced?.database?.useNumberId ||
                    y.advanced?.database?.generateId === "serial";
                if (
                  (("id" === u || m.references?.field === "id") &&
                    c &&
                    (o = Array.isArray(d) ? d.map(Number) : Number(d)),
                  "date" === m.type &&
                    d instanceof Date &&
                    !A.supportsDates &&
                    (o = d.toISOString()),
                  "boolean" !== m.type || "boolean" != typeof d || A.supportsBooleans || (o = +!!d),
                  "json" === m.type && "object" == typeof d && !A.supportsJSON)
                )
                  try {
                    o = JSON.stringify(d);
                  } catch (e) {
                    throw Error(`Failed to stringify JSON value for field ${f}`, { cause: e });
                  }
                return (
                  A.customTransformInput &&
                    (o = A.customTransformInput({
                      data: o,
                      fieldAttributes: m,
                      field: f,
                      model: D(e),
                      schema: w,
                      options: y,
                      action: r,
                    })),
                  { operator: n, connector: s, field: f, value: o }
                );
              });
            },
            U = (e, t, r) => {
              if (!t || 0 === Object.keys(t).length) return;
              let a = {};
              for (let [i, d] of Object.entries(t)) {
                let t, n, s;
                if (!d) continue;
                let o = T(i),
                  l = T(e),
                  u = Object.entries(w[o].fields).filter(
                    ([e, t]) => t.references && T(t.references.model) === l,
                  ),
                  f = !0;
                if (
                  (u.length ||
                    ((u = Object.entries(w[l].fields).filter(
                      ([e, t]) => t.references && T(t.references.model) === o,
                    )),
                    (f = !1)),
                  u.length)
                ) {
                  if (u.length > 1)
                    throw new p.BetterAuthError(
                      `Multiple foreign keys found for model ${i} and base model ${e} while performing join operation. Only one foreign key is supported.`,
                    );
                } else
                  throw new p.BetterAuthError(
                    `No foreign key found for model ${i} and base model ${e} while performing join operation.`,
                  );
                let [m, c] = u[0];
                if (!c.references)
                  throw new p.BetterAuthError(
                    `No references found for foreign key ${m} on model ${i} while performing join operation.`,
                  );
                (f
                  ? ((t = M({ model: e, field: (s = c.references.field) })),
                    (n = M({ model: i, field: m })))
                  : ((t = M({ model: e, field: (s = m) })),
                    (n = M({ model: i, field: c.references.field }))),
                  r && !r.includes(s) && r.push(s));
                let g = "id" === n || (c.unique ?? !1),
                  b = y.advanced?.database?.defaultFindManyLimit ?? 100;
                (g ? (b = 1) : "object" == typeof d && "number" == typeof d.limit && (b = d.limit),
                  (a[D(i)] = {
                    on: { from: t, to: n },
                    limit: b,
                    relation: g ? "one-to-one" : "one-to-many",
                  }));
              }
              return { join: a, select: r };
            },
            R = async ({ baseModel: e, baseData: t, joinModel: r, specificJoinConfig: a }) => {
              let i;
              if (!t) return t;
              let d = D(r),
                n = a.on.to,
                s = t[v({ field: a.on.from, model: e })];
              if (null == s) return "one-to-one" === a.relation ? null : [];
              let o = S({
                model: d,
                where: [{ field: n, value: s, operator: "eq", connector: "AND" }],
                action: "findOne",
              });
              try {
                if ("one-to-one" === a.relation) i = await F.findOne({ model: d, where: o });
                else {
                  let e = a.limit ?? y.advanced?.database?.defaultFindManyLimit ?? 100;
                  i = await F.findMany({ model: d, where: o, limit: e });
                }
              } catch (e) {
                throw (
                  O.error(`Failed to query fallback join for model ${d}:`, {
                    where: o,
                    limit: a.limit,
                  }),
                  console.error(e),
                  e
                );
              }
              return i;
            },
            F = e({
              options: y,
              schema: w,
              debugLog: I,
              getFieldName: M,
              getModelName: D,
              getDefaultModelName: T,
              getDefaultFieldName: v,
              getFieldAttributes: j,
              transformInput: L,
              transformOutput: k,
              transformWhereClause: S,
            }),
            P = null,
            G = {
              transaction: async (e) => {
                if (!P)
                  if (A.transaction)
                    (O.debug(`[${A.adapterName}] - Using provided transaction implementation.`),
                      (P = A.transaction));
                  else P = (e) => e(G);
                return P(e);
              },
              create: async ({ data: e, model: t, select: r, forceAllowId: a = !1 }) => {
                let i = ++c,
                  d = D(t);
                ((t = T(t)),
                  "id" in e &&
                    void 0 !== e.id &&
                    !a &&
                    (O.warn(
                      `[${A.adapterName}] - You are trying to create a record with an id. This is not allowed as we handle id generation for you, unless you pass in the \`forceAllowId\` parameter. The id will be ignored.`,
                    ),
                    console.log(
                      Error()
                        .stack?.split("\n")
                        .filter((e, t) => 1 !== t)
                        .join("\n")
                        .replace("Error:", "Create method with `id` being called at:"),
                    ),
                    (e.id = void 0)),
                  I(
                    { method: "create" },
                    `${g(i)} ${b(1, 4)}`,
                    `${$("create")} ${h("Unsafe Input")}:`,
                    { model: d, data: e },
                  ));
                let n = e;
                (A.disableTransformInput || (n = await L(e, t, "create", a)),
                  I(
                    { method: "create" },
                    `${g(i)} ${b(2, 4)}`,
                    `${$("create")} ${h("Parsed Input")}:`,
                    { model: d, data: n },
                  ));
                let s = await F.create({ data: n, model: d });
                I({ method: "create" }, `${g(i)} ${b(3, 4)}`, `${$("create")} ${h("DB Result")}:`, {
                  model: d,
                  res: s,
                });
                let o = s;
                return (
                  A.disableTransformOutput || (o = await k(s, t, r, void 0)),
                  I(
                    { method: "create" },
                    `${g(i)} ${b(4, 4)}`,
                    `${$("create")} ${h("Parsed Result")}:`,
                    { model: d, data: o },
                  ),
                  o
                );
              },
              update: async ({ model: e, where: t, update: r }) => {
                let a = ++c,
                  i = D((e = T(e))),
                  d = S({ model: e, where: t, action: "update" });
                I(
                  { method: "update" },
                  `${g(a)} ${b(1, 4)}`,
                  `${$("update")} ${h("Unsafe Input")}:`,
                  { model: i, data: r },
                );
                let n = r;
                (A.disableTransformInput || (n = await L(r, e, "update")),
                  I(
                    { method: "update" },
                    `${g(a)} ${b(2, 4)}`,
                    `${$("update")} ${h("Parsed Input")}:`,
                    { model: i, data: n },
                  ));
                let s = await F.update({ model: i, where: d, update: n });
                I({ method: "update" }, `${g(a)} ${b(3, 4)}`, `${$("update")} ${h("DB Result")}:`, {
                  model: i,
                  data: s,
                });
                let o = s;
                return (
                  A.disableTransformOutput || (o = await k(s, e, void 0, void 0)),
                  I(
                    { method: "update" },
                    `${g(a)} ${b(4, 4)}`,
                    `${$("update")} ${h("Parsed Result")}:`,
                    { model: i, data: o },
                  ),
                  o
                );
              },
              updateMany: async ({ model: e, where: t, update: r }) => {
                let a = ++c,
                  i = D(e),
                  d = S({ model: e, where: t, action: "updateMany" });
                ((e = T(e)),
                  I(
                    { method: "updateMany" },
                    `${g(a)} ${b(1, 4)}`,
                    `${$("updateMany")} ${h("Unsafe Input")}:`,
                    { model: i, data: r },
                  ));
                let n = r;
                (A.disableTransformInput || (n = await L(r, e, "update")),
                  I(
                    { method: "updateMany" },
                    `${g(a)} ${b(2, 4)}`,
                    `${$("updateMany")} ${h("Parsed Input")}:`,
                    { model: i, data: n },
                  ));
                let s = await F.updateMany({ model: i, where: d, update: n });
                return (
                  I(
                    { method: "updateMany" },
                    `${g(a)} ${b(3, 4)}`,
                    `${$("updateMany")} ${h("DB Result")}:`,
                    { model: i, data: s },
                  ),
                  I(
                    { method: "updateMany" },
                    `${g(a)} ${b(4, 4)}`,
                    `${$("updateMany")} ${h("Parsed Result")}:`,
                    { model: i, data: s },
                  ),
                  s
                );
              },
              findOne: async ({ model: e, where: t, select: r, join: a }) => {
                let i,
                  d = ++c,
                  n = D(e),
                  s = S({ model: e, where: t, action: "findOne" });
                e = T(e);
                let o = !0;
                if (A.disableTransformJoin) i = a;
                else {
                  let t = U(e, a, r);
                  (t && ((i = t.join), (r = t.select)),
                    !y.experimental?.joins && i && Object.keys(i).length > 0 && (o = !1));
                }
                I({ method: "findOne" }, `${g(d)} ${b(1, 3)}`, `${$("findOne")}:`, {
                  model: n,
                  where: s,
                  select: r,
                  join: i,
                });
                let l = await F.findOne({ model: n, where: s, select: r, join: o ? i : void 0 });
                I(
                  { method: "findOne" },
                  `${g(d)} ${b(2, 3)}`,
                  `${$("findOne")} ${h("DB Result")}:`,
                  { model: n, data: l },
                );
                let u = l;
                return (
                  A.disableTransformOutput || (u = await k(l, e, r, i)),
                  I(
                    { method: "findOne" },
                    `${g(d)} ${b(3, 3)}`,
                    `${$("findOne")} ${h("Parsed Result")}:`,
                    { model: n, data: u },
                  ),
                  u
                );
              },
              findMany: async ({ model: e, where: t, limit: r, sortBy: a, offset: i, join: d }) => {
                let n,
                  s = ++c,
                  o = r ?? y.advanced?.database?.defaultFindManyLimit ?? 100,
                  l = D(e),
                  u = S({ model: e, where: t, action: "findMany" });
                e = T(e);
                let f = !0;
                if (A.disableTransformJoin) n = d;
                else {
                  let t = U(e, d, void 0);
                  (t && (n = t.join),
                    !y.experimental?.joins && n && Object.keys(n).length > 0 && (f = !1));
                }
                I({ method: "findMany" }, `${g(s)} ${b(1, 3)}`, `${$("findMany")}:`, {
                  model: l,
                  where: u,
                  limit: o,
                  sortBy: a,
                  offset: i,
                  join: n,
                });
                let p = await F.findMany({
                  model: l,
                  where: u,
                  limit: o,
                  sortBy: a,
                  offset: i,
                  join: f ? n : void 0,
                });
                I(
                  { method: "findMany" },
                  `${g(s)} ${b(2, 3)}`,
                  `${$("findMany")} ${h("DB Result")}:`,
                  { model: l, data: p },
                );
                let m = p;
                return (
                  A.disableTransformOutput ||
                    (m = await Promise.all(p.map(async (t) => await k(t, e, void 0, n)))),
                  I(
                    { method: "findMany" },
                    `${g(s)} ${b(3, 3)}`,
                    `${$("findMany")} ${h("Parsed Result")}:`,
                    { model: l, data: m },
                  ),
                  m
                );
              },
              delete: async ({ model: e, where: t }) => {
                let r = ++c,
                  a = D(e),
                  i = S({ model: e, where: t, action: "delete" });
                ((e = T(e)),
                  I({ method: "delete" }, `${g(r)} ${b(1, 2)}`, `${$("delete")}:`, {
                    model: a,
                    where: i,
                  }),
                  await F.delete({ model: a, where: i }),
                  I(
                    { method: "delete" },
                    `${g(r)} ${b(2, 2)}`,
                    `${$("delete")} ${h("DB Result")}:`,
                    { model: a },
                  ));
              },
              deleteMany: async ({ model: e, where: t }) => {
                let r = ++c,
                  a = D(e),
                  i = S({ model: e, where: t, action: "deleteMany" });
                ((e = T(e)),
                  I(
                    { method: "deleteMany" },
                    `${g(r)} ${b(1, 2)}`,
                    `${$("deleteMany")} ${h("DeleteMany")}:`,
                    { model: a, where: i },
                  ));
                let d = await F.deleteMany({ model: a, where: i });
                return (
                  I(
                    { method: "deleteMany" },
                    `${g(r)} ${b(2, 2)}`,
                    `${$("deleteMany")} ${h("DB Result")}:`,
                    { model: a, data: d },
                  ),
                  d
                );
              },
              count: async ({ model: e, where: t }) => {
                let r = ++c,
                  a = D(e),
                  i = S({ model: e, where: t, action: "count" });
                ((e = T(e)),
                  I({ method: "count" }, `${g(r)} ${b(1, 2)}`, `${$("count")}:`, {
                    model: a,
                    where: i,
                  }));
                let d = await F.count({ model: a, where: i });
                return (
                  I({ method: "count" }, `${g(r)} ${b(2, 2)}`, `${$("count")}:`, {
                    model: a,
                    data: d,
                  }),
                  d
                );
              },
              createSchema: F.createSchema
                ? async (e, t) => {
                    let r = (0, o.getAuthTables)(y);
                    return (
                      y.secondaryStorage && !y.session?.storeSessionInDatabase && delete r.session,
                      F.createSchema({ file: t, tables: r })
                    );
                  }
                : void 0,
              options: { adapterConfig: A, ...(F.options ?? {}) },
              id: A.adapterId,
              ...(A.debugLogs?.isRunningAdapterTests
                ? {
                    adapterTestDebugLogs: {
                      resetDebugLogs() {
                        m = m.filter((e) => e.instance !== N);
                      },
                      printDebugLogs() {
                        let e = `â”€`.repeat(80),
                          t = m.filter((e) => e.instance === N);
                        0 === t.length ||
                          console.log(
                            ...t
                              .reverse()
                              .map(
                                (e) => (
                                  (e.args[0] = `
${e.args[0]}`),
                                  [...e.args, "\n"]
                                ),
                              )
                              .reduce(
                                (e, t) => [...t, ...e],
                                [
                                  `
${e}`,
                                ],
                              ),
                          );
                      },
                    },
                  }
                : {}),
            };
          return G;
        };
    function g(e) {
      return 8 > (0, l.getColorDepth)()
        ? `#${e}`
        : `${u.TTY_COLORS.fg.magenta}#${e}${u.TTY_COLORS.reset}`;
    }
    function b(e, t) {
      return `${u.TTY_COLORS.bg.black}${u.TTY_COLORS.fg.yellow}[${e}/${t}]${u.TTY_COLORS.reset}`;
    }
    function $(e) {
      return `${u.TTY_COLORS.bright}${e}${u.TTY_COLORS.reset}`;
    }
    function h(e) {
      return `${u.TTY_COLORS.dim}(${e})${u.TTY_COLORS.reset}`;
    }
    (e.s(["createAdapter", () => y, "createAdapterFactory", () => y], 5284), e.s([], 76757));
  },
];

//# sourceMappingURL=node_modules_%40better-auth_core_dist_db_4f35c68d._.js.map
