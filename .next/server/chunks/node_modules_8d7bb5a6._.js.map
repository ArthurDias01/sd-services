{"version":3,"sources":["../../../node_modules/better-auth/src/utils/url.ts","../../../node_modules/defu/dist/defu.mjs","../../../node_modules/%40better-fetch/fetch/src/error.ts","../../../node_modules/%40better-fetch/fetch/src/plugins.ts","../../../node_modules/%40better-fetch/fetch/src/retry.ts","../../../node_modules/%40better-fetch/fetch/src/auth.ts","../../../node_modules/%40better-fetch/fetch/src/utils.ts","../../../node_modules/%40better-fetch/fetch/src/create-fetch/schema.ts","../../../node_modules/%40better-fetch/fetch/src/create-fetch/index.ts","../../../node_modules/%40better-fetch/fetch/src/url.ts","../../../node_modules/%40better-fetch/fetch/src/fetch.ts"],"sourcesContent":["import { env } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\n\nfunction checkHasPath(url: string): boolean {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\tconst pathname = parsedUrl.pathname.replace(/\\/+$/, \"\") || \"/\";\n\t\treturn pathname !== \"/\";\n\t} catch {\n\t\tthrow new BetterAuthError(\n\t\t\t`Invalid base URL: ${url}. Please provide a valid base URL.`,\n\t\t);\n\t}\n}\n\nfunction assertHasProtocol(url: string): void {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\tif (parsedUrl.protocol !== \"http:\" && parsedUrl.protocol !== \"https:\") {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t`Invalid base URL: ${url}. URL must include 'http://' or 'https://'`,\n\t\t\t);\n\t\t}\n\t} catch (error) {\n\t\tif (error instanceof BetterAuthError) {\n\t\t\tthrow error;\n\t\t}\n\t\tthrow new BetterAuthError(\n\t\t\t`Invalid base URL: ${url}. Please provide a valid base URL.`,\n\t\t\t{\n\t\t\t\tcause: error,\n\t\t\t},\n\t\t);\n\t}\n}\n\nfunction withPath(url: string, path = \"/api/auth\") {\n\tassertHasProtocol(url);\n\n\tconst hasPath = checkHasPath(url);\n\tif (hasPath) {\n\t\treturn url;\n\t}\n\n\tconst trimmedUrl = url.replace(/\\/+$/, \"\");\n\n\tif (!path || path === \"/\") {\n\t\treturn trimmedUrl;\n\t}\n\n\tpath = path.startsWith(\"/\") ? path : `/${path}`;\n\treturn `${trimmedUrl}${path}`;\n}\n\nfunction validateProxyHeader(header: string, type: \"host\" | \"proto\"): boolean {\n\tif (!header || header.trim() === \"\") {\n\t\treturn false;\n\t}\n\n\tif (type === \"proto\") {\n\t\t// Only allow http and https protocols\n\t\treturn header === \"http\" || header === \"https\";\n\t}\n\n\tif (type === \"host\") {\n\t\tconst suspiciousPatterns = [\n\t\t\t/\\.\\./, // Path traversal\n\t\t\t/\\0/, // Null bytes\n\t\t\t/[\\s]/, // Whitespace (except legitimate spaces that should be trimmed)\n\t\t\t/^[.]/, // Starting with dot\n\t\t\t/[<>'\"]/, // HTML/script injection characters\n\t\t\t/javascript:/i, // Protocol injection\n\t\t\t/file:/i, // File protocol\n\t\t\t/data:/i, // Data protocol\n\t\t];\n\n\t\tif (suspiciousPatterns.some((pattern) => pattern.test(header))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Basic hostname validation (allows localhost, IPs, and domains with ports)\n\t\t// This is a simple check, not exhaustive RFC validation\n\t\tconst hostnameRegex =\n\t\t\t/^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(:[0-9]{1,5})?$/;\n\n\t\t// Also allow IPv4 addresses\n\t\tconst ipv4Regex = /^(\\d{1,3}\\.){3}\\d{1,3}(:[0-9]{1,5})?$/;\n\n\t\t// Also allow IPv6 addresses in brackets\n\t\tconst ipv6Regex = /^\\[[0-9a-fA-F:]+\\](:[0-9]{1,5})?$/;\n\n\t\t// Allow localhost variations\n\t\tconst localhostRegex = /^localhost(:[0-9]{1,5})?$/i;\n\n\t\treturn (\n\t\t\thostnameRegex.test(header) ||\n\t\t\tipv4Regex.test(header) ||\n\t\t\tipv6Regex.test(header) ||\n\t\t\tlocalhostRegex.test(header)\n\t\t);\n\t}\n\n\treturn false;\n}\n\nexport function getBaseURL(\n\turl?: string,\n\tpath?: string,\n\trequest?: Request,\n\tloadEnv?: boolean,\n\ttrustedProxyHeaders?: boolean | undefined,\n) {\n\tif (url) {\n\t\treturn withPath(url, path);\n\t}\n\n\tif (loadEnv !== false) {\n\t\tconst fromEnv =\n\t\t\tenv.BETTER_AUTH_URL ||\n\t\t\tenv.NEXT_PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.NUXT_PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.NUXT_PUBLIC_AUTH_URL ||\n\t\t\t(env.BASE_URL !== \"/\" ? env.BASE_URL : undefined);\n\n\t\tif (fromEnv) {\n\t\t\treturn withPath(fromEnv, path);\n\t\t}\n\t}\n\n\tconst fromRequest = request?.headers.get(\"x-forwarded-host\");\n\tconst fromRequestProto = request?.headers.get(\"x-forwarded-proto\");\n\tif (fromRequest && fromRequestProto && trustedProxyHeaders) {\n\t\tif (\n\t\t\tvalidateProxyHeader(fromRequestProto, \"proto\") &&\n\t\t\tvalidateProxyHeader(fromRequest, \"host\")\n\t\t) {\n\t\t\ttry {\n\t\t\t\treturn withPath(`${fromRequestProto}://${fromRequest}`, path);\n\t\t\t} catch (_error) {}\n\t\t}\n\t}\n\n\tif (request) {\n\t\tconst url = getOrigin(request.url);\n\t\tif (!url) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"Could not get origin from request. Please provide a valid base URL.\",\n\t\t\t);\n\t\t}\n\t\treturn withPath(url, path);\n\t}\n\n\tif (typeof window !== \"undefined\" && window.location) {\n\t\treturn withPath(window.location.origin, path);\n\t}\n\treturn undefined;\n}\n\nexport function getOrigin(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\t// For custom URL schemes (like exp://), the origin property returns the string \"null\"\n\t\t// instead of null. We need to handle this case and return null so the fallback logic works.\n\t\treturn parsedUrl.origin === \"null\" ? null : parsedUrl.origin;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport function getProtocol(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\treturn parsedUrl.protocol;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport function getHost(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\treturn parsedUrl.host;\n\t} catch {\n\t\treturn null;\n\t}\n}\n","function isPlainObject(value) {\n  if (value === null || typeof value !== \"object\") {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {\n    return false;\n  }\n  if (Symbol.iterator in value) {\n    return false;\n  }\n  if (Symbol.toStringTag in value) {\n    return Object.prototype.toString.call(value) === \"[object Module]\";\n  }\n  return true;\n}\n\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isPlainObject(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isPlainObject(value) && isPlainObject(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nconst defu = createDefu();\nconst defuFn = createDefu((object, key, currentValue) => {\n  if (object[key] !== void 0 && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((object, key, currentValue) => {\n  if (Array.isArray(object[key]) && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\n\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\n","export class BetterFetchError extends Error {\n\tconstructor(\n\t\tpublic status: number,\n\t\tpublic statusText: string,\n\t\tpublic error: any,\n\t) {\n\t\tsuper(statusText || status.toString(), {\n\t\t\tcause: error,\n\t\t});\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n","import type { StandardSchemaV1 } from \"./standard-schema\";\nimport type { Schema } from \"./create-fetch\";\nimport type { BetterFetchError } from \"./error\";\nimport type { BetterFetchOption } from \"./types\";\n\nexport type RequestContext<T extends Record<string, any> = any> = {\n\turl: URL | string;\n\theaders: Headers;\n\tbody: any;\n\tmethod: string;\n\tsignal: AbortSignal;\n} & BetterFetchOption<any, any, any, T>;\nexport type ResponseContext = {\n\tresponse: Response;\n\trequest: RequestContext;\n};\nexport type SuccessContext<Res = any> = {\n\tdata: Res;\n\tresponse: Response;\n\trequest: RequestContext;\n};\nexport type ErrorContext = {\n\tresponse: Response;\n\trequest: RequestContext;\n\terror: BetterFetchError & Record<string, any>;\n};\nexport interface FetchHooks<Res = any> {\n\t/**\n\t * a callback function that will be called when a\n\t * request is made.\n\t *\n\t * The returned context object will be reassigned to\n\t * the original request context.\n\t */\n\tonRequest?: <T extends Record<string, any>>(\n\t\tcontext: RequestContext<T>,\n\t) => Promise<RequestContext | void> | RequestContext | void;\n\t/**\n\t * a callback function that will be called when\n\t * response is received. This will be called before\n\t * the response is parsed and returned.\n\t *\n\t * The returned response will be reassigned to the\n\t * original response if it's changed.\n\t */\n\tonResponse?: (\n\t\tcontext: ResponseContext,\n\t) =>\n\t\t| Promise<Response | void | ResponseContext>\n\t\t| Response\n\t\t| ResponseContext\n\t\t| void;\n\t/**\n\t * a callback function that will be called when a\n\t * response is successful.\n\t */\n\tonSuccess?: (context: SuccessContext<Res>) => Promise<void> | void;\n\t/**\n\t * a callback function that will be called when an\n\t * error occurs.\n\t */\n\tonError?: (context: ErrorContext) => Promise<void> | void;\n\t/**\n\t * a callback function that will be called when a\n\t * request is retried.\n\t */\n\tonRetry?: (response: ResponseContext) => Promise<void> | void;\n\t/**\n\t * Options for the hooks\n\t */\n\thookOptions?: {\n\t\t/**\n\t\t * Clone the response\n\t\t * @see https://developer.mozilla.org/en-US/docs/Web/API/Response/clone\n\t\t */\n\t\tcloneResponse?: boolean;\n\t};\n}\n\n/**\n * A plugin that returns an id and hooks\n */\nexport type BetterFetchPlugin<\n\tExtraOptions extends Record<string, any> = Record<string, any>,\n> = {\n\t/**\n\t * A unique id for the plugin\n\t */\n\tid: string;\n\t/**\n\t * A name for the plugin\n\t */\n\tname: string;\n\t/**\n\t * A description for the plugin\n\t */\n\tdescription?: string;\n\t/**\n\t * A version for the plugin\n\t */\n\tversion?: string;\n\t/**\n\t * Hooks for the plugin\n\t */\n\thooks?: FetchHooks;\n\t/**\n\t * A function that will be called when the plugin is\n\t * initialized. This will be called before the any\n\t * of the other internal functions.\n\t *\n\t * The returned options will be merged with the\n\t * original options.\n\t */\n\tinit?: (\n\t\turl: string,\n\t\toptions?: BetterFetchOption & ExtraOptions,\n\t) =>\n\t\t| Promise<{\n\t\t\t\turl: string;\n\t\t\t\toptions?: BetterFetchOption;\n\t\t  }>\n\t\t| {\n\t\t\t\turl: string;\n\t\t\t\toptions?: BetterFetchOption;\n\t\t  };\n\t/**\n\t * A schema for the plugin\n\t */\n\tschema?: Schema;\n\t/**\n\t * Additional options that can be passed to the plugin\n\t *\n\t * @deprecated Use type inference through direct typescript instead\n\t * ```ts\n\t * const plugin = {\n\t *\n\t * } satisfies BetterFetchPlugin<{\n\t *  myCustomOptions: string;\n\t * }>\n\t * ```\n\t */\n\tgetOptions?: () => StandardSchemaV1;\n};\n\nexport const initializePlugins = async (\n\turl: string,\n\toptions?: BetterFetchOption,\n) => {\n\tlet opts = options || {};\n\tconst hooks: {\n\t\tonRequest: Array<FetchHooks[\"onRequest\"]>;\n\t\tonResponse: Array<FetchHooks[\"onResponse\"]>;\n\t\tonSuccess: Array<FetchHooks[\"onSuccess\"]>;\n\t\tonError: Array<FetchHooks[\"onError\"]>;\n\t\tonRetry: Array<FetchHooks[\"onRetry\"]>;\n\t} = {\n\t\tonRequest: [options?.onRequest],\n\t\tonResponse: [options?.onResponse],\n\t\tonSuccess: [options?.onSuccess],\n\t\tonError: [options?.onError],\n\t\tonRetry: [options?.onRetry],\n\t};\n\tif (!options || !options?.plugins) {\n\t\treturn {\n\t\t\turl,\n\t\t\toptions: opts,\n\t\t\thooks,\n\t\t};\n\t}\n\tfor (const plugin of options?.plugins || []) {\n\t\tif (plugin.init) {\n\t\t\tconst pluginRes = await plugin.init?.(url.toString(), options);\n\t\t\topts = pluginRes.options || opts;\n\t\t\turl = pluginRes.url;\n\t\t}\n\t\thooks.onRequest.push(plugin.hooks?.onRequest);\n\t\thooks.onResponse.push(plugin.hooks?.onResponse);\n\t\thooks.onSuccess.push(plugin.hooks?.onSuccess);\n\t\thooks.onError.push(plugin.hooks?.onError);\n\t\thooks.onRetry.push(plugin.hooks?.onRetry);\n\t}\n\n\treturn {\n\t\turl,\n\t\toptions: opts,\n\t\thooks,\n\t};\n};\n","export type RetryCondition = (\n\tresponse: Response | null,\n) => boolean | Promise<boolean>;\n\nexport type LinearRetry = {\n\ttype: \"linear\";\n\tattempts: number;\n\tdelay: number;\n\tshouldRetry?: RetryCondition;\n};\n\nexport type ExponentialRetry = {\n\ttype: \"exponential\";\n\tattempts: number;\n\tbaseDelay: number;\n\tmaxDelay: number;\n\tshouldRetry?: RetryCondition;\n};\n\nexport type RetryOptions = LinearRetry | ExponentialRetry | number;\n\nexport interface RetryStrategy {\n\tshouldAttemptRetry(\n\t\tattempt: number,\n\t\tresponse: Response | null,\n\t): Promise<boolean>;\n\tgetDelay(attempt: number): number;\n}\n\nclass LinearRetryStrategy implements RetryStrategy {\n\tconstructor(private options: LinearRetry) {}\n\n\tshouldAttemptRetry(\n\t\tattempt: number,\n\t\tresponse: Response | null,\n\t): Promise<boolean> {\n\t\tif (this.options.shouldRetry) {\n\t\t\treturn Promise.resolve(\n\t\t\t\tattempt < this.options.attempts && this.options.shouldRetry(response),\n\t\t\t);\n\t\t}\n\t\treturn Promise.resolve(attempt < this.options.attempts);\n\t}\n\n\tgetDelay(): number {\n\t\treturn this.options.delay;\n\t}\n}\n\nclass ExponentialRetryStrategy implements RetryStrategy {\n\tconstructor(private options: ExponentialRetry) {}\n\n\tshouldAttemptRetry(\n\t\tattempt: number,\n\t\tresponse: Response | null,\n\t): Promise<boolean> {\n\t\tif (this.options.shouldRetry) {\n\t\t\treturn Promise.resolve(\n\t\t\t\tattempt < this.options.attempts && this.options.shouldRetry(response),\n\t\t\t);\n\t\t}\n\t\treturn Promise.resolve(attempt < this.options.attempts);\n\t}\n\n\tgetDelay(attempt: number): number {\n\t\tconst delay = Math.min(\n\t\t\tthis.options.maxDelay,\n\t\t\tthis.options.baseDelay * 2 ** attempt,\n\t\t);\n\t\treturn delay;\n\t}\n}\n\nexport function createRetryStrategy(options: RetryOptions): RetryStrategy {\n\tif (typeof options === \"number\") {\n\t\treturn new LinearRetryStrategy({\n\t\t\ttype: \"linear\",\n\t\t\tattempts: options,\n\t\t\tdelay: 1000,\n\t\t});\n\t}\n\n\tswitch (options.type) {\n\t\tcase \"linear\":\n\t\t\treturn new LinearRetryStrategy(options);\n\t\tcase \"exponential\":\n\t\t\treturn new ExponentialRetryStrategy(options);\n\t\tdefault:\n\t\t\tthrow new Error(\"Invalid retry strategy\");\n\t}\n}\n","import type { BetterFetchOption } from \"./types\";\n\nexport type typeOrTypeReturning<T> = T | (() => T);\n/**\n * Bearer token authentication\n *\n * the value of `token` will be added to a header as\n * `auth: Bearer token`,\n */\nexport type Bearer = {\n\ttype: \"Bearer\";\n\ttoken: typeOrTypeReturning<string | undefined | Promise<string | undefined>>;\n};\n\n/**\n * Basic auth\n */\nexport type Basic = {\n\ttype: \"Basic\";\n\tusername: typeOrTypeReturning<string | undefined>;\n\tpassword: typeOrTypeReturning<string | undefined>;\n};\n\n/**\n * Custom auth\n *\n * @param prefix - prefix of the header\n * @param value - value of the header\n *\n * @example\n * ```ts\n * {\n *  type: \"Custom\",\n *  prefix: \"Token\",\n *  value: \"token\"\n * }\n * ```\n */\nexport type Custom = {\n\ttype: \"Custom\";\n\tprefix: typeOrTypeReturning<string | undefined>;\n\tvalue: typeOrTypeReturning<string | undefined>;\n};\n\nexport type Auth = Bearer | Basic | Custom;\n\nexport const getAuthHeader = async (options?: BetterFetchOption) => {\n\tconst headers: Record<string, string> = {};\n\tconst getValue = async (\n\t\tvalue: typeOrTypeReturning<\n\t\t\tstring | undefined | Promise<string | undefined>\n\t\t>,\n\t) => (typeof value === \"function\" ? await value() : value);\n\tif (options?.auth) {\n\t\tif (options.auth.type === \"Bearer\") {\n\t\t\tconst token = await getValue(options.auth.token);\n\t\t\tif (!token) {\n\t\t\t\treturn headers;\n\t\t\t}\n\t\t\theaders[\"authorization\"] = `Bearer ${token}`;\n\t\t} else if (options.auth.type === \"Basic\") {\n\t\t\tconst [username, password] = await Promise.all([\n\t\t\t\tgetValue(options.auth.username),\n\t\t\t\tgetValue(options.auth.password),\n\t\t\t]);\n\t\t\tif (!username || !password) {\n\t\t\t\treturn headers;\n\t\t\t}\n\t\t\theaders[\"authorization\"] = `Basic ${btoa(`${username}:${password}`)}`;\n\t\t} else if (options.auth.type === \"Custom\") {\n\t\t\tconst [prefix, value] = await Promise.all([\n\t\t\t\tgetValue(options.auth.prefix),\n\t\t\t\tgetValue(options.auth.value),\n\t\t\t]);\n\t\t\tif (!value) {\n\t\t\t\treturn headers;\n\t\t\t}\n\t\t\theaders[\"authorization\"] = `${prefix ?? \"\"} ${value}`;\n\t\t}\n\t}\n\treturn headers;\n};\n","import type { StandardSchemaV1 } from \"./standard-schema\";\nimport { getAuthHeader } from \"./auth\";\nimport { methods } from \"./create-fetch\";\nimport type { BetterFetchOption, FetchEsque } from \"./types\";\n\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\n\nexport type ResponseType = \"json\" | \"text\" | \"blob\";\nexport function detectResponseType(request: Response): ResponseType {\n\tconst _contentType = request.headers.get(\"content-type\");\n\tconst textTypes = new Set([\n\t\t\"image/svg\",\n\t\t\"application/xml\",\n\t\t\"application/xhtml\",\n\t\t\"application/html\",\n\t]);\n\tif (!_contentType) {\n\t\treturn \"json\";\n\t}\n\tconst contentType = _contentType.split(\";\").shift() || \"\";\n\tif (JSON_RE.test(contentType)) {\n\t\treturn \"json\";\n\t}\n\tif (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n\t\treturn \"text\";\n\t}\n\treturn \"blob\";\n}\n\nexport function isJSONParsable(value: any) {\n\ttry {\n\t\tJSON.parse(value);\n\t\treturn true;\n\t} catch (error) {\n\t\treturn false;\n\t}\n}\n\n//https://github.com/unjs/ofetch/blob/main/src/utils.ts\nexport function isJSONSerializable(value: any) {\n\tif (value === undefined) {\n\t\treturn false;\n\t}\n\tconst t = typeof value;\n\tif (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n\t\treturn true;\n\t}\n\tif (t !== \"object\") {\n\t\treturn false;\n\t}\n\tif (Array.isArray(value)) {\n\t\treturn true;\n\t}\n\tif (value.buffer) {\n\t\treturn false;\n\t}\n\treturn (\n\t\t(value.constructor && value.constructor.name === \"Object\") ||\n\t\ttypeof value.toJSON === \"function\"\n\t);\n}\n\nexport function jsonParse(text: string) {\n\ttry {\n\t\treturn JSON.parse(text);\n\t} catch (error) {\n\t\treturn text;\n\t}\n}\n\nexport function isFunction(value: any): value is () => any {\n\treturn typeof value === \"function\";\n}\n\nexport function getFetch(options?: BetterFetchOption): FetchEsque {\n\tif (options?.customFetchImpl) {\n\t\treturn options.customFetchImpl;\n\t}\n\tif (typeof globalThis !== \"undefined\" && isFunction(globalThis.fetch)) {\n\t\treturn globalThis.fetch;\n\t}\n\tif (typeof window !== \"undefined\" && isFunction(window.fetch)) {\n\t\treturn window.fetch;\n\t}\n\tthrow new Error(\"No fetch implementation found\");\n}\n\nexport function isPayloadMethod(method?: string) {\n\tif (!method) {\n\t\treturn false;\n\t}\n\tconst payloadMethod = [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n\treturn payloadMethod.includes(method.toUpperCase());\n}\n\nexport function isRouteMethod(method?: string) {\n\tconst routeMethod = [\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"];\n\tif (!method) {\n\t\treturn false;\n\t}\n\treturn routeMethod.includes(method.toUpperCase());\n}\n\nexport async function getHeaders(opts?: BetterFetchOption) {\n\tconst headers = new Headers(opts?.headers);\n\tconst authHeader = await getAuthHeader(opts);\n\tfor (const [key, value] of Object.entries(authHeader || {})) {\n\t\theaders.set(key, value);\n\t}\n\tif (!headers.has(\"content-type\")) {\n\t\tconst t = detectContentType(opts?.body);\n\t\tif (t) {\n\t\t\theaders.set(\"content-type\", t);\n\t\t}\n\t}\n\n\treturn headers;\n}\n\nexport function getURL(url: string, options?: BetterFetchOption) {\n\tif (url.startsWith(\"@\")) {\n\t\tconst m = url.toString().split(\"@\")[1].split(\"/\")[0];\n\t\tif (methods.includes(m)) {\n\t\t\turl = url.replace(`@${m}/`, \"/\");\n\t\t}\n\t}\n\tlet _url: string | URL;\n\ttry {\n\t\tif (url.startsWith(\"http\")) {\n\t\t\t_url = url;\n\t\t} else {\n\t\t\tlet baseURL = options?.baseURL;\n\t\t\tif (baseURL && !baseURL?.endsWith(\"/\")) {\n\t\t\t\tbaseURL = baseURL + \"/\";\n\t\t\t}\n\t\t\tif (url.startsWith(\"/\")) {\n\t\t\t\t_url = new URL(url.substring(1), baseURL);\n\t\t\t} else {\n\t\t\t\t_url = new URL(url, options?.baseURL);\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\tif (e instanceof TypeError) {\n\t\t\tif (!options?.baseURL) {\n\t\t\t\tthrow TypeError(\n\t\t\t\t\t`Invalid URL ${url}. Are you passing in a relative url but not setting the baseURL?`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow TypeError(\n\t\t\t\t`Invalid URL ${url}. Please validate that you are passing the correct input.`,\n\t\t\t);\n\t\t}\n\t\tthrow e;\n\t}\n\n\t/**\n\t * Dynamic Parameters.\n\t */\n\tif (options?.params) {\n\t\tif (Array.isArray(options?.params)) {\n\t\t\tconst params = options?.params\n\t\t\t\t? Array.isArray(options.params)\n\t\t\t\t\t? `/${options.params.join(\"/\")}`\n\t\t\t\t\t: `/${Object.values(options.params).join(\"/\")}`\n\t\t\t\t: \"\";\n\t\t\t_url = _url.toString().split(\"/:\")[0];\n\t\t\t_url = `${_url.toString()}${params}`;\n\t\t} else {\n\t\t\tfor (const [key, value] of Object.entries(options?.params)) {\n\t\t\t\t_url = _url.toString().replace(`:${key}`, String(value));\n\t\t\t}\n\t\t}\n\t}\n\tconst __url = new URL(_url);\n\t/**\n\t * Query Parameters\n\t */\n\tconst queryParams = options?.query;\n\tif (queryParams) {\n\t\tfor (const [key, value] of Object.entries(queryParams)) {\n\t\t\t__url.searchParams.append(key, String(value));\n\t\t}\n\t}\n\treturn __url;\n}\n\nexport function detectContentType(body: any) {\n\tif (isJSONSerializable(body)) {\n\t\treturn \"application/json\";\n\t}\n\n\treturn null;\n}\n\nexport function getBody(options?: BetterFetchOption) {\n\tif (!options?.body) {\n\t\treturn null;\n\t}\n\tconst headers = new Headers(options?.headers);\n\tif (isJSONSerializable(options.body) && !headers.has(\"content-type\")) {\n\t\tfor (const [key, value] of Object.entries(options?.body)) {\n\t\t\tif (value instanceof Date) {\n\t\t\t\toptions.body[key] = value.toISOString();\n\t\t\t}\n\t\t}\n\t\treturn JSON.stringify(options.body);\n\t}\n\n\tif (\n\t\theaders.has(\"content-type\") &&\n\t\theaders.get(\"content-type\") === \"application/x-www-form-urlencoded\"\n\t) {\n\t\tif (isJSONSerializable(options.body)) {\n\t\t\treturn new URLSearchParams(options.body).toString();\n\t\t}\n\t\treturn options.body;\n\t}\n\n\treturn options.body;\n}\n\nexport function getMethod(url: string, options?: BetterFetchOption) {\n\tif (options?.method) {\n\t\treturn options.method.toUpperCase();\n\t}\n\tif (url.startsWith(\"@\")) {\n\t\tconst pMethod = url.split(\"@\")[1]?.split(\"/\")[0];\n\t\tif (!methods.includes(pMethod)) {\n\t\t\treturn options?.body ? \"POST\" : \"GET\";\n\t\t}\n\t\treturn pMethod.toUpperCase();\n\t}\n\treturn options?.body ? \"POST\" : \"GET\";\n}\n\nexport function getTimeout(\n\toptions?: BetterFetchOption,\n\tcontroller?: AbortController,\n) {\n\tlet abortTimeout: ReturnType<typeof setTimeout> | undefined;\n\tif (!options?.signal && options?.timeout) {\n\t\tabortTimeout = setTimeout(() => controller?.abort(), options?.timeout);\n\t}\n\treturn {\n\t\tabortTimeout,\n\t\tclearTimeout: () => {\n\t\t\tif (abortTimeout) {\n\t\t\t\tclearTimeout(abortTimeout);\n\t\t\t}\n\t\t},\n\t};\n}\n\nexport function bodyParser(data: any, responseType: ResponseType) {\n\tif (responseType === \"json\") {\n\t\treturn JSON.parse(data);\n\t}\n\treturn data;\n}\n\nexport class ValidationError extends Error {\n\tpublic readonly issues: ReadonlyArray<StandardSchemaV1.Issue>;\n\n\tconstructor(issues: ReadonlyArray<StandardSchemaV1.Issue>, message?: string) {\n\t\t// Default message fallback in case one isn't supplied.\n\t\tsuper(message || JSON.stringify(issues, null, 2));\n\t\tthis.issues = issues;\n\n\t\t// Set the prototype explicitly to ensure that instanceof works correctly.\n\t\tObject.setPrototypeOf(this, ValidationError.prototype);\n\t}\n}\n\nexport async function parseStandardSchema<TSchema extends StandardSchemaV1>(\n\tschema: TSchema,\n\tinput: StandardSchemaV1.InferInput<TSchema>,\n): Promise<StandardSchemaV1.InferOutput<TSchema>> {\n\tconst result = await schema[\"~standard\"].validate(input);\n\n\tif (result.issues) {\n\t\tthrow new ValidationError(result.issues);\n\t}\n\treturn result.value;\n}\n","import type { StandardSchemaV1 } from \"../standard-schema\";\nimport type { StringLiteralUnion } from \"../type-utils\";\n\nexport type FetchSchema = {\n\tinput?: StandardSchemaV1;\n\toutput?: StandardSchemaV1;\n\tquery?: StandardSchemaV1;\n\tparams?: StandardSchemaV1<Record<string, unknown>> | undefined;\n\tmethod?: Methods;\n};\n\nexport type Methods = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\n\nexport const methods = [\"get\", \"post\", \"put\", \"patch\", \"delete\"];\n\ntype RouteKey = StringLiteralUnion<`@${Methods}/`>;\n\nexport type FetchSchemaRoutes = {\n\t[key in RouteKey]?: FetchSchema;\n};\n\nexport const createSchema = <\n\tF extends FetchSchemaRoutes,\n\tS extends SchemaConfig,\n>(\n\tschema: F,\n\tconfig?: S,\n) => {\n\treturn {\n\t\tschema: schema as F,\n\t\tconfig: config as S,\n\t};\n};\n\nexport type SchemaConfig = {\n\tstrict?: boolean;\n\t/**\n\t * A prefix that will be prepended when it's\n\t * calling the schema.\n\t *\n\t * NOTE: Make sure to handle converting\n\t * the prefix to the baseURL in the init\n\t * function if you you are defining for a\n\t * plugin.\n\t */\n\tprefix?: \"\" | (string & Record<never, never>);\n\t/**\n\t * The base url of the schema. By default it's the baseURL of the fetch instance.\n\t */\n\tbaseURL?: \"\" | (string & Record<never, never>);\n};\n\nexport type Schema = {\n\tschema: FetchSchemaRoutes;\n\tconfig: SchemaConfig;\n};\n","import { betterFetch } from \"../fetch\";\nimport { BetterFetchPlugin } from \"../plugins\";\nimport type { BetterFetchOption } from \"../types\";\nimport { parseStandardSchema } from \"../utils\";\nimport type { BetterFetch, CreateFetchOption } from \"./types\";\n\nexport const applySchemaPlugin = (config: CreateFetchOption) =>\n\t({\n\t\tid: \"apply-schema\",\n\t\tname: \"Apply Schema\",\n\t\tversion: \"1.0.0\",\n\t\tasync init(url, options) {\n\t\t\tconst schema =\n\t\t\t\tconfig.plugins?.find((plugin) =>\n\t\t\t\t\tplugin.schema?.config\n\t\t\t\t\t\t? url.startsWith(plugin.schema.config.baseURL || \"\") ||\n\t\t\t\t\t\t\turl.startsWith(plugin.schema.config.prefix || \"\")\n\t\t\t\t\t\t: false,\n\t\t\t\t)?.schema || config.schema;\n\t\t\tif (schema) {\n\t\t\t\tlet urlKey = url;\n\t\t\t\tif (schema.config?.prefix) {\n\t\t\t\t\tif (urlKey.startsWith(schema.config.prefix)) {\n\t\t\t\t\t\turlKey = urlKey.replace(schema.config.prefix, \"\");\n\t\t\t\t\t\tif (schema.config.baseURL) {\n\t\t\t\t\t\t\turl = url.replace(schema.config.prefix, schema.config.baseURL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (schema.config?.baseURL) {\n\t\t\t\t\tif (urlKey.startsWith(schema.config.baseURL)) {\n\t\t\t\t\t\turlKey = urlKey.replace(schema.config.baseURL, \"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst keySchema = schema.schema[urlKey];\n\t\t\t\tif (keySchema) {\n\t\t\t\t\tlet opts = {\n\t\t\t\t\t\t...options,\n\t\t\t\t\t\tmethod: keySchema.method,\n\t\t\t\t\t\toutput: keySchema.output,\n\t\t\t\t\t};\n\t\t\t\t\tif (!options?.disableValidation) {\n\t\t\t\t\t\topts = {\n\t\t\t\t\t\t\t...opts,\n\t\t\t\t\t\t\tbody: keySchema.input\n\t\t\t\t\t\t\t\t? await parseStandardSchema(keySchema.input, options?.body)\n\t\t\t\t\t\t\t\t: options?.body,\n\t\t\t\t\t\t\tparams: keySchema.params\n\t\t\t\t\t\t\t\t? await parseStandardSchema(keySchema.params, options?.params)\n\t\t\t\t\t\t\t\t: options?.params,\n\t\t\t\t\t\t\tquery: keySchema.query\n\t\t\t\t\t\t\t\t? await parseStandardSchema(keySchema.query, options?.query)\n\t\t\t\t\t\t\t\t: options?.query,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\turl,\n\t\t\t\t\t\toptions: opts,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\turl,\n\t\t\t\toptions,\n\t\t\t};\n\t\t},\n\t}) satisfies BetterFetchPlugin;\n\nexport const createFetch = <Option extends CreateFetchOption>(\n\tconfig?: Option,\n) => {\n\tasync function $fetch(url: string, options?: BetterFetchOption) {\n\t\tconst opts = {\n\t\t\t...config,\n\t\t\t...options,\n\t\t\tplugins: [...(config?.plugins || []), applySchemaPlugin(config || {}), ...(options?.plugins || [])],\n\t\t} as BetterFetchOption;\n\n\t\tif (config?.catchAllError) {\n\t\t\ttry {\n\t\t\t\treturn await betterFetch(url, opts);\n\t\t\t} catch (error) {\n\t\t\t\treturn {\n\t\t\t\t\tdata: null,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tstatus: 500,\n\t\t\t\t\t\tstatusText: \"Fetch Error\",\n\t\t\t\t\t\tmessage:\n\t\t\t\t\t\t\t\"Fetch related error. Captured by catchAllError option. See error property for more details.\",\n\t\t\t\t\t\terror,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn await betterFetch(url, opts);\n\t}\n\treturn $fetch as BetterFetch<Option>;\n};\n\nexport * from \"./schema\";\nexport * from \"./types\";\n","import { methods } from \"./create-fetch\";\nimport type { BetterFetchOption } from \"./types\";\n\n/**\n * Normalize URL\n */\nexport function getURL(url: string, option?: BetterFetchOption) {\n\tconst { baseURL, params, query } = option || {\n\t\tquery: {},\n\t\tparams: {},\n\t\tbaseURL: \"\",\n\t};\n\tlet basePath = url.startsWith(\"http\")\n\t\t? url.split(\"/\").slice(0, 3).join(\"/\")\n\t\t: baseURL || \"\";\n\n\t/**\n\t * Remove method modifiers\n\t */\n\tif (url.startsWith(\"@\")) {\n\t\tconst m = url.toString().split(\"@\")[1].split(\"/\")[0];\n\t\tif (methods.includes(m)) {\n\t\t\turl = url.replace(`@${m}/`, \"/\");\n\t\t}\n\t}\n\n\tif (!basePath.endsWith(\"/\")) basePath += \"/\";\n\tlet [path, urlQuery] = url.replace(basePath, \"\").split(\"?\");\n\tconst queryParams = new URLSearchParams(urlQuery);\n\tfor (const [key, value] of Object.entries(query || {})) {\n\t\tif (value == null) continue;\n\t\tlet serializedValue;\n\t\tif (typeof value === \"string\") {\n\t\t\tserializedValue = value;\n\t\t} else if (Array.isArray(value)) {\n\t\t\tfor (const val of value) {\n\t\t\t\tqueryParams.append(key, val);\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tserializedValue = JSON.stringify(value);\n\t\t}\n\t\tqueryParams.set(key, serializedValue);\n\t}\n\tif (params) {\n\t\tif (Array.isArray(params)) {\n\t\t\tconst paramPaths = path.split(\"/\").filter((p) => p.startsWith(\":\"));\n\t\t\tfor (const [index, key] of paramPaths.entries()) {\n\t\t\t\tconst value = params[index];\n\t\t\t\tpath = path.replace(key, value);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [key, value] of Object.entries(params)) {\n\t\t\t\tpath = path.replace(`:${key}`, String(value));\n\t\t\t}\n\t\t}\n\t}\n\n\tpath = path.split(\"/\").map(encodeURIComponent).join(\"/\");\n\tif (path.startsWith(\"/\")) path = path.slice(1);\n\tlet queryParamString = queryParams.toString();\n\tqueryParamString =\n\t\tqueryParamString.length > 0\n\t\t\t? `?${queryParamString}`.replace(/\\+/g, \"%20\")\n\t\t\t: \"\";\n\tif (!basePath.startsWith(\"http\")) {\n\t\treturn `${basePath}${path}${queryParamString}`;\n\t}\n\tconst _url = new URL(`${path}${queryParamString}`, basePath);\n\treturn _url;\n}\n","import { BetterFetchError } from \"./error\";\nimport { initializePlugins } from \"./plugins\";\nimport { createRetryStrategy } from \"./retry\";\nimport type { StandardSchemaV1 } from \"./standard-schema\";\nimport type { BetterFetchOption, BetterFetchResponse } from \"./types\";\nimport { getURL } from \"./url\";\nimport {\n\tdetectResponseType,\n\tgetBody,\n\tgetFetch,\n\tgetHeaders,\n\tgetMethod,\n\tgetTimeout,\n\tisJSONParsable,\n\tjsonParse,\n\tparseStandardSchema,\n} from \"./utils\";\n\nexport const betterFetch = async <\n\tTRes extends Option[\"output\"] extends StandardSchemaV1\n\t\t? StandardSchemaV1.InferOutput<Option[\"output\"]>\n\t\t: unknown,\n\tTErr = unknown,\n\tOption extends BetterFetchOption = BetterFetchOption<any, any, any, TRes>,\n>(\n\turl: string,\n\toptions?: Option,\n): Promise<\n\tBetterFetchResponse<\n\t\tTRes,\n\t\tTErr,\n\t\tOption[\"throw\"] extends true ? true : TErr extends false ? true : false\n\t>\n> => {\n\tconst {\n\t\thooks,\n\t\turl: __url,\n\t\toptions: opts,\n\t} = await initializePlugins(url, options);\n\tconst fetch = getFetch(opts);\n\tconst controller = new AbortController();\n\tconst signal = opts.signal ?? controller.signal;\n\tconst _url = getURL(__url, opts);\n\tconst body = getBody(opts);\n\tconst headers = await getHeaders(opts);\n\tconst method = getMethod(__url, opts);\n\tlet context = {\n\t\t...opts,\n\t\turl: _url,\n\t\theaders,\n\t\tbody,\n\t\tmethod,\n\t\tsignal,\n\t};\n\t/**\n\t * Run all on request hooks\n\t */\n\tfor (const onRequest of hooks.onRequest) {\n\t\tif (onRequest) {\n\t\t\tconst res = await onRequest(context);\n\t\t\tif (typeof res === \"object\" && res !== null) {\n\t\t\t\tcontext = res;\n\t\t\t}\n\t\t}\n\t}\n\tif (\n\t\t(\"pipeTo\" in context && typeof context.pipeTo === \"function\") ||\n\t\ttypeof options?.body?.pipe === \"function\"\n\t) {\n\t\tif (!(\"duplex\" in context)) {\n\t\t\tcontext.duplex = \"half\";\n\t\t}\n\t}\n\n\tconst { clearTimeout } = getTimeout(opts, controller);\n\tlet response = await fetch(context.url, context);\n\tclearTimeout();\n\n\tconst responseContext = {\n\t\tresponse,\n\t\trequest: context,\n\t};\n\n\tfor (const onResponse of hooks.onResponse) {\n\t\tif (onResponse) {\n\t\t\tconst r = await onResponse({\n\t\t\t\t...responseContext,\n\t\t\t\tresponse: options?.hookOptions?.cloneResponse\n\t\t\t\t\t? response.clone()\n\t\t\t\t\t: response,\n\t\t\t});\n\t\t\tif (r instanceof Response) {\n\t\t\t\tresponse = r;\n\t\t\t} else if (typeof r === \"object\" && r !== null) {\n\t\t\t\tresponse = r.response;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * OK Branch\n\t */\n\tif (response.ok) {\n\t\tconst hasBody = context.method !== \"HEAD\";\n\t\tif (!hasBody) {\n\t\t\treturn {\n\t\t\t\tdata: \"\" as any,\n\t\t\t\terror: null,\n\t\t\t} as any;\n\t\t}\n\t\tconst responseType = detectResponseType(response);\n\t\tconst successContext = {\n\t\t\tdata: null as any,\n\t\t\tresponse,\n\t\t\trequest: context,\n\t\t};\n\t\tif (responseType === \"json\" || responseType === \"text\") {\n\t\t\tconst text = await response.text();\n\t\t\tconst parser = context.jsonParser ?? jsonParse;\n\t\t\tsuccessContext.data = await parser(text);\n\t\t} else {\n\t\t\tsuccessContext.data = await response[responseType]();\n\t\t}\n\n\t\t/**\n\t\t * Parse the data if the output schema is defined\n\t\t */\n\t\tif (context?.output) {\n\t\t\tif (context.output && !context.disableValidation) {\n\t\t\t\tsuccessContext.data = await parseStandardSchema(\n\t\t\t\t\tcontext.output as StandardSchemaV1,\n\t\t\t\t\tsuccessContext.data,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tfor (const onSuccess of hooks.onSuccess) {\n\t\t\tif (onSuccess) {\n\t\t\t\tawait onSuccess({\n\t\t\t\t\t...successContext,\n\t\t\t\t\tresponse: options?.hookOptions?.cloneResponse\n\t\t\t\t\t\t? response.clone()\n\t\t\t\t\t\t: response,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (options?.throw) {\n\t\t\treturn successContext.data;\n\t\t}\n\n\t\treturn {\n\t\t\tdata: successContext.data,\n\t\t\terror: null,\n\t\t} as any;\n\t}\n\tconst parser = options?.jsonParser ?? jsonParse;\n\tconst responseText = await response.text();\n\tconst isJSONResponse = isJSONParsable(responseText);\n\tconst errorObject = isJSONResponse ? await parser(responseText) : null;\n\t/**\n\t * Error Branch\n\t */\n\tconst errorContext = {\n\t\tresponse,\n\t\tresponseText,\n\t\trequest: context,\n\t\terror: {\n\t\t\t...errorObject,\n\t\t\tstatus: response.status,\n\t\t\tstatusText: response.statusText,\n\t\t},\n\t};\n\tfor (const onError of hooks.onError) {\n\t\tif (onError) {\n\t\t\tawait onError({\n\t\t\t\t...errorContext,\n\t\t\t\tresponse: options?.hookOptions?.cloneResponse\n\t\t\t\t\t? response.clone()\n\t\t\t\t\t: response,\n\t\t\t});\n\t\t}\n\t}\n\n\tif (options?.retry) {\n\t\tconst retryStrategy = createRetryStrategy(options.retry);\n\t\tconst _retryAttempt = options.retryAttempt ?? 0;\n\t\tif (await retryStrategy.shouldAttemptRetry(_retryAttempt, response)) {\n\t\t\tfor (const onRetry of hooks.onRetry) {\n\t\t\t\tif (onRetry) {\n\t\t\t\t\tawait onRetry(responseContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst delay = retryStrategy.getDelay(_retryAttempt);\n\t\t\tawait new Promise((resolve) => setTimeout(resolve, delay));\n\t\t\treturn await betterFetch(url, {\n\t\t\t\t...options,\n\t\t\t\tretryAttempt: _retryAttempt + 1,\n\t\t\t});\n\t\t}\n\t}\n\n\tif (options?.throw) {\n\t\tthrow new BetterFetchError(\n\t\t\tresponse.status,\n\t\t\tresponse.statusText,\n\t\t\tisJSONResponse ? errorObject : responseText,\n\t\t);\n\t}\n\treturn {\n\t\tdata: null,\n\t\terror: {\n\t\t\t...errorObject,\n\t\t\tstatus: response.status,\n\t\t\tstatusText: response.statusText,\n\t\t},\n\t} as any;\n};\n"],"names":["url","_a","getURL","clearTimeout","parser"],"mappings":"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","ignoreList":[1]}