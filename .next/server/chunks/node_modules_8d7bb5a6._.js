module.exports = [
  96481,
  (t) => {
    "use strict";
    t.i(89139);
    var e = t.i(47391),
      r = t.i(71616);
    function o(t, e = "/api/auth") {
      try {
        let e = new URL(t);
        if ("http:" !== e.protocol && "https:" !== e.protocol)
          throw new r.BetterAuthError(
            `Invalid base URL: ${t}. URL must include 'http://' or 'https://'`,
          );
      } catch (e) {
        if (e instanceof r.BetterAuthError) throw e;
        throw new r.BetterAuthError(`Invalid base URL: ${t}. Please provide a valid base URL.`, {
          cause: e,
        });
      }
      if (
        (function (t) {
          try {
            return "/" !== (new URL(t).pathname.replace(/\/+$/, "") || "/");
          } catch {
            throw new r.BetterAuthError(`Invalid base URL: ${t}. Please provide a valid base URL.`);
          }
        })(t)
      )
        return t;
      let n = t.replace(/\/+$/, "");
      return e && "/" !== e ? ((e = e.startsWith("/") ? e : `/${e}`), `${n}${e}`) : n;
    }
    function n(t, e) {
      return (
        !!t &&
        "" !== t.trim() &&
        ("proto" === e
          ? "http" === t || "https" === t
          : "host" === e &&
            ![/\.\./, /\0/, /[\s]/, /^[.]/, /[<>'"]/, /javascript:/i, /file:/i, /data:/i].some(
              (e) => e.test(t),
            ) &&
            (/^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(:[0-9]{1,5})?$/.test(
              t,
            ) ||
              /^(\d{1,3}\.){3}\d{1,3}(:[0-9]{1,5})?$/.test(t) ||
              /^\[[0-9a-fA-F:]+\](:[0-9]{1,5})?$/.test(t) ||
              /^localhost(:[0-9]{1,5})?$/i.test(t)))
      );
    }
    function i(t, i, s, a, u) {
      if (t) return o(t, i);
      if (!1 !== a) {
        let t =
          e.env.BETTER_AUTH_URL ||
          e.env.NEXT_PUBLIC_BETTER_AUTH_URL ||
          e.env.PUBLIC_BETTER_AUTH_URL ||
          e.env.NUXT_PUBLIC_BETTER_AUTH_URL ||
          e.env.NUXT_PUBLIC_AUTH_URL ||
          ("/" !== e.env.BASE_URL ? e.env.BASE_URL : void 0);
        if (t) return o(t, i);
      }
      let c = s?.headers.get("x-forwarded-host"),
        p = s?.headers.get("x-forwarded-proto");
      if (c && p && u && n(p, "proto") && n(c, "host"))
        try {
          return o(`${p}://${c}`, i);
        } catch (t) {}
      if (s) {
        let t = l(s.url);
        if (!t)
          throw new r.BetterAuthError(
            "Could not get origin from request. Please provide a valid base URL.",
          );
        return o(t, i);
      }
    }
    function l(t) {
      try {
        let e = new URL(t);
        return "null" === e.origin ? null : e.origin;
      } catch {
        return null;
      }
    }
    function s(t) {
      try {
        return new URL(t).protocol;
      } catch {
        return null;
      }
    }
    function a(t) {
      try {
        return new URL(t).host;
      } catch {
        return null;
      }
    }
    t.s(["getBaseURL", () => i, "getHost", () => a, "getOrigin", () => l, "getProtocol", () => s]);
  },
  29776,
  (t) => {
    "use strict";
    function e(t) {
      if (null === t || "object" != typeof t) return !1;
      let e = Object.getPrototypeOf(t);
      return (
        (null === e || e === Object.prototype || null === Object.getPrototypeOf(e)) &&
        !(Symbol.iterator in t) &&
        (!(Symbol.toStringTag in t) || "[object Module]" === Object.prototype.toString.call(t))
      );
    }
    function r(t) {
      return (...r) =>
        r.reduce(
          (r, o) =>
            (function t(r, o, n = ".", i) {
              if (!e(o)) return t(r, {}, n, i);
              let l = Object.assign({}, o);
              for (let o in r) {
                if ("__proto__" === o || "constructor" === o) continue;
                let s = r[o];
                null != s &&
                  ((i && i(l, o, s, n)) ||
                    (Array.isArray(s) && Array.isArray(l[o])
                      ? (l[o] = [...s, ...l[o]])
                      : e(s) && e(l[o])
                        ? (l[o] = t(s, l[o], (n ? `${n}.` : "") + o.toString(), i))
                        : (l[o] = s)));
              }
              return l;
            })(r, o, "", t),
          {},
        );
    }
    let o = r();
    (r((t, e, r) => {
      if (void 0 !== t[e] && "function" == typeof r) return ((t[e] = r(t[e])), !0);
    }),
      r((t, e, r) => {
        if (Array.isArray(t[e]) && "function" == typeof r) return ((t[e] = r(t[e])), !0);
      }),
      t.s(["createDefu", () => r, "default", () => o, "defu", () => o]));
  },
  33078,
  (t) => {
    "use strict";
    var e = Object.defineProperty,
      r = Object.defineProperties,
      o = Object.getOwnPropertyDescriptors,
      n = Object.getOwnPropertySymbols,
      i = Object.prototype.hasOwnProperty,
      l = Object.prototype.propertyIsEnumerable,
      s = (t, r, o) =>
        r in t ? e(t, r, { enumerable: !0, configurable: !0, writable: !0, value: o }) : (t[r] = o),
      a = (t, e) => {
        for (var r in e || (e = {})) i.call(e, r) && s(t, r, e[r]);
        if (n) for (var r of n(e)) l.call(e, r) && s(t, r, e[r]);
        return t;
      },
      u = (t, e) => r(t, o(e)),
      c = class extends Error {
        constructor(t, e, r) {
          (super(e || t.toString(), { cause: r }),
            (this.status = t),
            (this.statusText = e),
            (this.error = r),
            Error.captureStackTrace(this, this.constructor));
        }
      },
      p = async (t, e) => {
        var r, o, n, i, l, s;
        let a = e || {},
          u = {
            onRequest: [null == e ? void 0 : e.onRequest],
            onResponse: [null == e ? void 0 : e.onResponse],
            onSuccess: [null == e ? void 0 : e.onSuccess],
            onError: [null == e ? void 0 : e.onError],
            onRetry: [null == e ? void 0 : e.onRetry],
          };
        if (!e || !(null == e ? void 0 : e.plugins)) return { url: t, options: a, hooks: u };
        for (let c of (null == e ? void 0 : e.plugins) || []) {
          if (c.init) {
            let o = await (null == (r = c.init) ? void 0 : r.call(c, t.toString(), e));
            ((a = o.options || a), (t = o.url));
          }
          (u.onRequest.push(null == (o = c.hooks) ? void 0 : o.onRequest),
            u.onResponse.push(null == (n = c.hooks) ? void 0 : n.onResponse),
            u.onSuccess.push(null == (i = c.hooks) ? void 0 : i.onSuccess),
            u.onError.push(null == (l = c.hooks) ? void 0 : l.onError),
            u.onRetry.push(null == (s = c.hooks) ? void 0 : s.onRetry));
        }
        return { url: t, options: a, hooks: u };
      },
      f = class {
        constructor(t) {
          this.options = t;
        }
        shouldAttemptRetry(t, e) {
          return this.options.shouldRetry
            ? Promise.resolve(t < this.options.attempts && this.options.shouldRetry(e))
            : Promise.resolve(t < this.options.attempts);
        }
        getDelay() {
          return this.options.delay;
        }
      },
      d = class {
        constructor(t) {
          this.options = t;
        }
        shouldAttemptRetry(t, e) {
          return this.options.shouldRetry
            ? Promise.resolve(t < this.options.attempts && this.options.shouldRetry(e))
            : Promise.resolve(t < this.options.attempts);
        }
        getDelay(t) {
          return Math.min(this.options.maxDelay, this.options.baseDelay * 2 ** t);
        }
      },
      h = async (t) => {
        let e = {},
          r = async (t) => ("function" == typeof t ? await t() : t);
        if (null == t ? void 0 : t.auth) {
          if ("Bearer" === t.auth.type) {
            let o = await r(t.auth.token);
            if (!o) return e;
            e.authorization = `Bearer ${o}`;
          } else if ("Basic" === t.auth.type) {
            let [o, n] = await Promise.all([r(t.auth.username), r(t.auth.password)]);
            if (!o || !n) return e;
            e.authorization = `Basic ${btoa(`${o}:${n}`)}`;
          } else if ("Custom" === t.auth.type) {
            let [o, n] = await Promise.all([r(t.auth.prefix), r(t.auth.value)]);
            if (!n) return e;
            e.authorization = `${null != o ? o : ""} ${n}`;
          }
        }
        return e;
      },
      y = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
    function v(t) {
      if (void 0 === t) return !1;
      let e = typeof t;
      return (
        "string" === e ||
        "number" === e ||
        "boolean" === e ||
        null === e ||
        ("object" === e &&
          (!!Array.isArray(t) ||
            (!t.buffer &&
              ((t.constructor && "Object" === t.constructor.name) ||
                "function" == typeof t.toJSON))))
      );
    }
    function m(t) {
      try {
        return JSON.parse(t);
      } catch (e) {
        return t;
      }
    }
    async function b(t) {
      let e = new Headers(null == t ? void 0 : t.headers);
      for (let [r, o] of Object.entries((await h(t)) || {})) e.set(r, o);
      if (!e.has("content-type")) {
        let r = v(null == t ? void 0 : t.body) ? "application/json" : null;
        r && e.set("content-type", r);
      }
      return e;
    }
    var w = class t extends Error {
      constructor(e, r) {
        (super(r || JSON.stringify(e, null, 2)),
          (this.issues = e),
          Object.setPrototypeOf(this, t.prototype));
      }
    };
    async function g(t, e) {
      let r = await t["~standard"].validate(e);
      if (r.issues) throw new w(r.issues);
      return r.value;
    }
    var R = ["get", "post", "put", "patch", "delete"],
      U = (t) =>
        async function (e, r) {
          let o,
            n = u(a(a({}, t), r), {
              plugins: [
                ...((null == t ? void 0 : t.plugins) || []),
                ((o = t || {}),
                {
                  id: "apply-schema",
                  name: "Apply Schema",
                  version: "1.0.0",
                  async init(t, e) {
                    var r, n, i, l;
                    let s =
                      (null ==
                      (n =
                        null == (r = o.plugins)
                          ? void 0
                          : r.find((e) => {
                              var r;
                              return (
                                null != (r = e.schema) &&
                                !!r.config &&
                                (t.startsWith(e.schema.config.baseURL || "") ||
                                  t.startsWith(e.schema.config.prefix || ""))
                              );
                            }))
                        ? void 0
                        : n.schema) || o.schema;
                    if (s) {
                      let r = t;
                      ((null == (i = s.config) ? void 0 : i.prefix) &&
                        r.startsWith(s.config.prefix) &&
                        ((r = r.replace(s.config.prefix, "")),
                        s.config.baseURL && (t = t.replace(s.config.prefix, s.config.baseURL))),
                        (null == (l = s.config) ? void 0 : l.baseURL) &&
                          r.startsWith(s.config.baseURL) &&
                          (r = r.replace(s.config.baseURL, "")));
                      let o = s.schema[r];
                      if (o) {
                        let r = u(a({}, e), { method: o.method, output: o.output });
                        return (
                          (null == e ? void 0 : e.disableValidation) ||
                            (r = u(a({}, r), {
                              body: o.input
                                ? await g(o.input, null == e ? void 0 : e.body)
                                : null == e
                                  ? void 0
                                  : e.body,
                              params: o.params
                                ? await g(o.params, null == e ? void 0 : e.params)
                                : null == e
                                  ? void 0
                                  : e.params,
                              query: o.query
                                ? await g(o.query, null == e ? void 0 : e.query)
                                : null == e
                                  ? void 0
                                  : e.query,
                            })),
                          { url: t, options: r }
                        );
                      }
                    }
                    return { url: t, options: e };
                  },
                }),
                ...((null == r ? void 0 : r.plugins) || []),
              ],
            });
          if (null == t ? void 0 : t.catchAllError)
            try {
              return await A(e, n);
            } catch (t) {
              return {
                data: null,
                error: {
                  status: 500,
                  statusText: "Fetch Error",
                  message:
                    "Fetch related error. Captured by catchAllError option. See error property for more details.",
                  error: t,
                },
              };
            }
          return await A(e, n);
        },
      A = async (t, e) => {
        var r, o, n, i, l, s, h, w;
        let U,
          { hooks: T, url: O, options: S } = await p(t, e),
          L = (function (t) {
            if (null == t ? void 0 : t.customFetchImpl) return t.customFetchImpl;
            if ("u" > typeof globalThis && "function" == typeof globalThis.fetch)
              return globalThis.fetch;
            throw Error("No fetch implementation found");
          })(S),
          E = new AbortController(),
          j = null != (r = S.signal) ? r : E.signal,
          $ = (function (t, e) {
            let { baseURL: r, params: o, query: n } = e || { query: {}, params: {}, baseURL: "" },
              i = t.startsWith("http") ? t.split("/").slice(0, 3).join("/") : r || "";
            if (t.startsWith("@")) {
              let e = t.toString().split("@")[1].split("/")[0];
              R.includes(e) && (t = t.replace(`@${e}/`, "/"));
            }
            i.endsWith("/") || (i += "/");
            let [l, s] = t.replace(i, "").split("?"),
              a = new URLSearchParams(s);
            for (let [t, e] of Object.entries(n || {})) {
              let r;
              if (null != e) {
                if ("string" == typeof e) r = e;
                else if (Array.isArray(e)) {
                  for (let r of e) a.append(t, r);
                  continue;
                } else r = JSON.stringify(e);
                a.set(t, r);
              }
            }
            if (o)
              if (Array.isArray(o))
                for (let [t, e] of l
                  .split("/")
                  .filter((t) => t.startsWith(":"))
                  .entries()) {
                  let r = o[t];
                  l = l.replace(e, r);
                }
              else for (let [t, e] of Object.entries(o)) l = l.replace(`:${t}`, String(e));
            (l = l.split("/").map(encodeURIComponent).join("/")).startsWith("/") &&
              (l = l.slice(1));
            let u = a.toString();
            return ((u = u.length > 0 ? `?${u}`.replace(/\+/g, "%20") : ""), i.startsWith("http"))
              ? new URL(`${l}${u}`, i)
              : `${i}${l}${u}`;
          })(O, S),
          x = (function (t) {
            if (!(null == t ? void 0 : t.body)) return null;
            let e = new Headers(null == t ? void 0 : t.headers);
            if (v(t.body) && !e.has("content-type")) {
              for (let [e, r] of Object.entries(null == t ? void 0 : t.body))
                r instanceof Date && (t.body[e] = r.toISOString());
              return JSON.stringify(t.body);
            }
            return e.has("content-type") &&
              "application/x-www-form-urlencoded" === e.get("content-type") &&
              v(t.body)
              ? new URLSearchParams(t.body).toString()
              : t.body;
          })(S),
          P = await b(S),
          _ = (function (t, e) {
            var r;
            if (null == e ? void 0 : e.method) return e.method.toUpperCase();
            if (t.startsWith("@")) {
              let o = null == (r = t.split("@")[1]) ? void 0 : r.split("/")[0];
              return R.includes(o)
                ? o.toUpperCase()
                : (null == e ? void 0 : e.body)
                  ? "POST"
                  : "GET";
            }
            return (null == e ? void 0 : e.body) ? "POST" : "GET";
          })(O, S),
          B = u(a({}, S), { url: $, headers: P, body: x, method: _, signal: j });
        for (let t of T.onRequest)
          if (t) {
            let e = await t(B);
            "object" == typeof e && null !== e && (B = e);
          }
        (("pipeTo" in B && "function" == typeof B.pipeTo) ||
          "function" == typeof (null == (o = null == e ? void 0 : e.body) ? void 0 : o.pipe)) &&
          !("duplex" in B) &&
          (B.duplex = "half");
        let { clearTimeout: q } =
            (!(null == S ? void 0 : S.signal) &&
              (null == S ? void 0 : S.timeout) &&
              (U = setTimeout(
                () => (null == E ? void 0 : E.abort()),
                null == S ? void 0 : S.timeout,
              )),
            {
              abortTimeout: U,
              clearTimeout: () => {
                U && clearTimeout(U);
              },
            }),
          I = await L(B.url, B);
        q();
        let W = { response: I, request: B };
        for (let t of T.onResponse)
          if (t) {
            let r = await t(
              u(a({}, W), {
                response: (
                  null == (n = null == e ? void 0 : e.hookOptions) ? void 0 : n.cloneResponse
                )
                  ? I.clone()
                  : I,
              }),
            );
            r instanceof Response
              ? (I = r)
              : "object" == typeof r && null !== r && (I = r.response);
          }
        if (I.ok) {
          if ("HEAD" === B.method) return { data: "", error: null };
          let t = (function (t) {
              let e = t.headers.get("content-type"),
                r = new Set([
                  "image/svg",
                  "application/xml",
                  "application/xhtml",
                  "application/html",
                ]);
              if (!e) return "json";
              let o = e.split(";").shift() || "";
              return y.test(o) ? "json" : r.has(o) || o.startsWith("text/") ? "text" : "blob";
            })(I),
            r = { data: null, response: I, request: B };
          if ("json" === t || "text" === t) {
            let t = await I.text(),
              e = null != (i = B.jsonParser) ? i : m;
            r.data = await e(t);
          } else r.data = await I[t]();
          for (let t of ((null == B ? void 0 : B.output) &&
            B.output &&
            !B.disableValidation &&
            (r.data = await g(B.output, r.data)),
          T.onSuccess))
            t &&
              (await t(
                u(a({}, r), {
                  response: (
                    null == (l = null == e ? void 0 : e.hookOptions) ? void 0 : l.cloneResponse
                  )
                    ? I.clone()
                    : I,
                }),
              ));
          return (null == e ? void 0 : e.throw) ? r.data : { data: r.data, error: null };
        }
        let k = null != (s = null == e ? void 0 : e.jsonParser) ? s : m,
          C = await I.text(),
          N = (function (t) {
            try {
              return (JSON.parse(t), !0);
            } catch (t) {
              return !1;
            }
          })(C),
          z = N ? await k(C) : null,
          D = {
            response: I,
            responseText: C,
            request: B,
            error: u(a({}, z), { status: I.status, statusText: I.statusText }),
          };
        for (let t of T.onError)
          t &&
            (await t(
              u(a({}, D), {
                response: (
                  null == (h = null == e ? void 0 : e.hookOptions) ? void 0 : h.cloneResponse
                )
                  ? I.clone()
                  : I,
              }),
            ));
        if (null == e ? void 0 : e.retry) {
          let r = (function (t) {
              if ("number" == typeof t) return new f({ type: "linear", attempts: t, delay: 1e3 });
              switch (t.type) {
                case "linear":
                  return new f(t);
                case "exponential":
                  return new d(t);
                default:
                  throw Error("Invalid retry strategy");
              }
            })(e.retry),
            o = null != (w = e.retryAttempt) ? w : 0;
          if (await r.shouldAttemptRetry(o, I)) {
            for (let t of T.onRetry) t && (await t(W));
            let n = r.getDelay(o);
            return (
              await new Promise((t) => setTimeout(t, n)),
              await A(t, u(a({}, e), { retryAttempt: o + 1 }))
            );
          }
        }
        if (null == e ? void 0 : e.throw) throw new c(I.status, I.statusText, N ? z : C);
        return { data: null, error: u(a({}, z), { status: I.status, statusText: I.statusText }) };
      };
    t.s(["betterFetch", () => A, "createFetch", () => U]);
  },
];

//# sourceMappingURL=node_modules_8d7bb5a6._.js.map
