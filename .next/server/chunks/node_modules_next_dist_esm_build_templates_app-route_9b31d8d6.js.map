{"version":3,"sources":["../../../src/lib/api/routers/project.ts","../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../node_modules/%40orpc/server/dist/shared/server.DZ5BIITo.mjs","../../../src/lib/api/context.ts","../../../node_modules/%40orpc/client/dist/shared/client.BF1R3smX.mjs","../../../node_modules/%40orpc/standard-server/dist/index.mjs","../../../node_modules/%40orpc/contract/dist/shared/contract.D_dZrO__.mjs","../../../node_modules/%40orpc/shared/dist/index.mjs","../../../node_modules/%40orpc/standard-server/dist/batch/index.mjs","../../../node_modules/%40orpc/server/dist/shared/server.TEVCLCFC.mjs","../../../node_modules/%40orpc/standard-server-fetch/dist/index.mjs","../../../node_modules/%40orpc/client/dist/shared/client.BLtwTQUg.mjs","../../../src/lib/api/routers/setting.ts","../../../src/lib/api/index.ts","../../../node_modules/%40orpc/server/dist/shared/server.Ds4HPpvH.mjs","../../../node_modules/%40orpc/client/dist/shared/client.BcDRUyT-.mjs","../../../node_modules/%40orpc/server/dist/shared/server.Bxx6tqNe.mjs","../../../src/app/api/rpc/%5B%5B...path%5D%5D/route.ts","../../../node_modules/%40orpc/client/dist/index.mjs","../../../src/lib/api/routers/index.ts","../../../node_modules/%40orpc/contract/dist/index.mjs","../../../node_modules/%40orpc/server/dist/index.mjs","../../../node_modules/%40orpc/server/dist/adapters/fetch/index.mjs"],"sourcesContent":["import { desc, eq } from \"drizzle-orm\";\nimport { ORPCError, type RouterClient } from \"@orpc/server\";\nimport { z } from \"zod\";\n\nimport { db } from \"@/lib/db\";\nimport { project, projectImage } from \"@/lib/db/schema/project\";\n\nimport { adminProcedure, publicProcedure } from \"../index\";\n\nconst slugSchema = z\n  .string()\n  .min(1)\n  .regex(/^[a-z0-9]+(?:-[a-z0-9]+)*$/, \"Slug must be URL-safe (lowercase letters, numbers, hyphens)\");\n\nconst projectCreateSchema = z.object({\n  slug: slugSchema,\n  title: z.string().min(1),\n  description: z.string(),\n  featuredImageUrl: z.string().optional().nullable(),\n  published: z.boolean().optional(),\n  imageUrls: z.array(z.string().min(1)).optional(),\n});\n\nconst projectUpdateSchema = projectCreateSchema.partial().extend({\n  id: z.string().min(1),\n});\n\nexport const projectRouter = {\n  list: publicProcedure.handler(async () => {\n    const rows = await db\n      .select({\n        id: project.id,\n        slug: project.slug,\n        title: project.title,\n        description: project.description,\n        featuredImageUrl: project.featuredImageUrl,\n      })\n      .from(project)\n      .where(eq(project.published, true))\n      .orderBy(desc(project.updatedAt));\n    return rows;\n  }),\n\n  getBySlug: publicProcedure\n    .input(z.object({ slug: z.string().min(1) }))\n    .handler(async ({ input }) => {\n      const [row] = await db\n        .select()\n        .from(project)\n        .where(eq(project.slug, input.slug))\n        .limit(1);\n      if (!row || !row.published) return null;\n      const images = await db\n        .select({ id: projectImage.id, url: projectImage.url, sortOrder: projectImage.sortOrder })\n        .from(projectImage)\n        .where(eq(projectImage.projectId, row.id))\n        .orderBy(projectImage.sortOrder);\n      return {\n        id: row.id,\n        slug: row.slug,\n        title: row.title,\n        description: row.description,\n        featuredImageUrl: row.featuredImageUrl,\n        images,\n      };\n    }),\n\n  listAdmin: adminProcedure.handler(async () => {\n    const rows = await db\n      .select({\n        id: project.id,\n        slug: project.slug,\n        title: project.title,\n        published: project.published,\n        updatedAt: project.updatedAt,\n      })\n      .from(project)\n      .orderBy(desc(project.updatedAt));\n    return rows;\n  }),\n\n  getById: adminProcedure\n    .input(z.object({ id: z.string().min(1) }))\n    .handler(async ({ input }) => {\n      const [row] = await db.select().from(project).where(eq(project.id, input.id)).limit(1);\n      if (!row) return null;\n      const images = await db\n        .select({ id: projectImage.id, url: projectImage.url, sortOrder: projectImage.sortOrder })\n        .from(projectImage)\n        .where(eq(projectImage.projectId, row.id))\n        .orderBy(projectImage.sortOrder);\n      return {\n        ...row,\n        images,\n      };\n    }),\n\n  create: adminProcedure.input(projectCreateSchema).handler(async ({ input }) => {\n    try {\n      const [existing] = await db\n        .select({ id: project.id })\n        .from(project)\n        .where(eq(project.slug, input.slug))\n        .limit(1);\n      if (existing) {\n        throw new ORPCError(\"CONFLICT\", {\n          message: \"A project with this slug already exists.\",\n        });\n      }\n      const id = crypto.randomUUID();\n      await db.insert(project).values({\n        id,\n        slug: input.slug,\n        title: input.title,\n        description: input.description ?? \"\",\n        featuredImageUrl: input.featuredImageUrl ?? null,\n        published: input.published ?? false,\n      });\n      const urls = input.imageUrls ?? [];\n      if (urls.length > 0) {\n        await db.insert(projectImage).values(\n          urls.map((url, i) => ({\n            id: crypto.randomUUID(),\n            projectId: id,\n            url,\n            sortOrder: i,\n          })),\n        );\n      }\n      return { id };\n    } catch (err) {\n      const message = err instanceof Error ? err.message : String(err);\n      throw new ORPCError(\"INTERNAL_SERVER_ERROR\", { message });\n    }\n  }),\n\n  update: adminProcedure.input(projectUpdateSchema).handler(async ({ input }) => {\n    try {\n      const { id, imageUrls, ...rest } = input;\n      if (rest.slug !== undefined) {\n        const [existing] = await db\n          .select({ id: project.id })\n          .from(project)\n          .where(eq(project.slug, rest.slug))\n          .limit(1);\n        if (existing && existing.id !== id) {\n          throw new ORPCError(\"CONFLICT\", {\n            message: \"A project with this slug already exists.\",\n          });\n        }\n      }\n      const payload: {\n        slug?: string;\n        title?: string;\n        description?: string;\n        featuredImageUrl?: string | null;\n        published?: boolean;\n      } = {};\n      if (rest.slug !== undefined) payload.slug = rest.slug;\n      if (rest.title !== undefined) payload.title = rest.title;\n      if (rest.description !== undefined) payload.description = rest.description;\n      if (rest.featuredImageUrl !== undefined) payload.featuredImageUrl = rest.featuredImageUrl;\n      if (rest.published !== undefined) payload.published = rest.published;\n      if (Object.keys(payload).length > 0) {\n        await db.update(project).set(payload).where(eq(project.id, id));\n      }\n      if (imageUrls !== undefined) {\n        await db.delete(projectImage).where(eq(projectImage.projectId, id));\n        if (imageUrls.length > 0) {\n          await db.insert(projectImage).values(\n            imageUrls.map((url, i) => ({\n              id: crypto.randomUUID(),\n              projectId: id,\n              url,\n              sortOrder: i,\n            })),\n          );\n        }\n      }\n      return { id };\n    } catch (err) {\n      const message = err instanceof Error ? err.message : String(err);\n      throw new ORPCError(\"INTERNAL_SERVER_ERROR\", { message });\n    }\n  }),\n\n  delete: adminProcedure\n    .input(z.object({ id: z.string().min(1) }))\n    .handler(async ({ input }) => {\n      await db.delete(project).where(eq(project.id, input.id));\n      return { ok: true };\n    }),\n};\n\nexport type ProjectRouter = typeof projectRouter;\nexport type ProjectRouterClient = RouterClient<typeof projectRouter>;\n","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/rpc/[[...path]]/route\",\n        pathname: \"/api/rpc/[[...path]]\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/rpc/[[...path]]/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/rpc/[[...path]]/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        const silenceLog = false;\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, silenceLog, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","function resolveFriendlyStandardHandleOptions(options) {\n  return {\n    ...options,\n    context: options.context ?? {}\n    // Context only optional if all fields are optional\n  };\n}\n\nexport { resolveFriendlyStandardHandleOptions as r };\n","import { auth } from \"@/lib/auth\";\nimport { getServerEnv } from \"@/lib/env/server\";\n\nexport type CreateContextOptions = {\n  request: Request;\n};\n\nfunction isAllowedAdmin(email: string): boolean {\n  const env = getServerEnv();\n  const allowed = env.CMS_ALLOWED_EMAILS;\n  if (!allowed) return true;\n  const emails = String(allowed).split(\",\").map((e) => e.trim().toLowerCase());\n  return emails.includes(email.toLowerCase());\n}\n\nexport async function createContext({ request }: CreateContextOptions) {\n  const session = await auth.api.getSession({\n    headers: request.headers,\n  });\n  const isAdmin =\n    !!session?.user?.email && isAllowedAdmin(session.user.email);\n  return {\n    session,\n    isAdmin,\n  };\n}\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n","import { resolveMaybeOptionalOptions, getConstructor, isObject } from '@orpc/shared';\n\nconst ORPC_CLIENT_PACKAGE_NAME = \"@orpc/client\";\nconst ORPC_CLIENT_PACKAGE_VERSION = \"1.13.5\";\n\nconst COMMON_ORPC_ERROR_DEFS = {\n  BAD_REQUEST: {\n    status: 400,\n    message: \"Bad Request\"\n  },\n  UNAUTHORIZED: {\n    status: 401,\n    message: \"Unauthorized\"\n  },\n  FORBIDDEN: {\n    status: 403,\n    message: \"Forbidden\"\n  },\n  NOT_FOUND: {\n    status: 404,\n    message: \"Not Found\"\n  },\n  METHOD_NOT_SUPPORTED: {\n    status: 405,\n    message: \"Method Not Supported\"\n  },\n  NOT_ACCEPTABLE: {\n    status: 406,\n    message: \"Not Acceptable\"\n  },\n  TIMEOUT: {\n    status: 408,\n    message: \"Request Timeout\"\n  },\n  CONFLICT: {\n    status: 409,\n    message: \"Conflict\"\n  },\n  PRECONDITION_FAILED: {\n    status: 412,\n    message: \"Precondition Failed\"\n  },\n  PAYLOAD_TOO_LARGE: {\n    status: 413,\n    message: \"Payload Too Large\"\n  },\n  UNSUPPORTED_MEDIA_TYPE: {\n    status: 415,\n    message: \"Unsupported Media Type\"\n  },\n  UNPROCESSABLE_CONTENT: {\n    status: 422,\n    message: \"Unprocessable Content\"\n  },\n  TOO_MANY_REQUESTS: {\n    status: 429,\n    message: \"Too Many Requests\"\n  },\n  CLIENT_CLOSED_REQUEST: {\n    status: 499,\n    message: \"Client Closed Request\"\n  },\n  INTERNAL_SERVER_ERROR: {\n    status: 500,\n    message: \"Internal Server Error\"\n  },\n  NOT_IMPLEMENTED: {\n    status: 501,\n    message: \"Not Implemented\"\n  },\n  BAD_GATEWAY: {\n    status: 502,\n    message: \"Bad Gateway\"\n  },\n  SERVICE_UNAVAILABLE: {\n    status: 503,\n    message: \"Service Unavailable\"\n  },\n  GATEWAY_TIMEOUT: {\n    status: 504,\n    message: \"Gateway Timeout\"\n  }\n};\nfunction fallbackORPCErrorStatus(code, status) {\n  return status ?? COMMON_ORPC_ERROR_DEFS[code]?.status ?? 500;\n}\nfunction fallbackORPCErrorMessage(code, message) {\n  return message || COMMON_ORPC_ERROR_DEFS[code]?.message || code;\n}\nconst GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL = Symbol.for(`__${ORPC_CLIENT_PACKAGE_NAME}@${ORPC_CLIENT_PACKAGE_VERSION}/error/ORPC_ERROR_CONSTRUCTORS__`);\nvoid (globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL] ??= /* @__PURE__ */ new WeakSet());\nconst globalORPCErrorConstructors = globalThis[GLOBAL_ORPC_ERROR_CONSTRUCTORS_SYMBOL];\nclass ORPCError extends Error {\n  defined;\n  code;\n  status;\n  data;\n  constructor(code, ...rest) {\n    const options = resolveMaybeOptionalOptions(rest);\n    if (options.status !== void 0 && !isORPCErrorStatus(options.status)) {\n      throw new Error(\"[ORPCError] Invalid error status code.\");\n    }\n    const message = fallbackORPCErrorMessage(code, options.message);\n    super(message, options);\n    this.code = code;\n    this.status = fallbackORPCErrorStatus(code, options.status);\n    this.defined = options.defined ?? false;\n    this.data = options.data;\n  }\n  toJSON() {\n    return {\n      defined: this.defined,\n      code: this.code,\n      status: this.status,\n      message: this.message,\n      data: this.data\n    };\n  }\n  /**\n   * Workaround for Next.js where different contexts use separate\n   * dependency graphs, causing multiple ORPCError constructors existing and breaking\n   * `instanceof` checks across contexts.\n   *\n   * This is particularly problematic with \"Optimized SSR\", where orpc-client\n   * executes in one context but is invoked from another. When an error is thrown\n   * in the execution context, `instanceof ORPCError` checks fail in the\n   * invocation context due to separate class constructors.\n   *\n   * @todo Remove this and related code if Next.js resolves the multiple dependency graph issue.\n   */\n  static [Symbol.hasInstance](instance) {\n    if (globalORPCErrorConstructors.has(this)) {\n      const constructor = getConstructor(instance);\n      if (constructor && globalORPCErrorConstructors.has(constructor)) {\n        return true;\n      }\n    }\n    return super[Symbol.hasInstance](instance);\n  }\n}\nglobalORPCErrorConstructors.add(ORPCError);\nfunction isDefinedError(error) {\n  return error instanceof ORPCError && error.defined;\n}\nfunction toORPCError(error) {\n  return error instanceof ORPCError ? error : new ORPCError(\"INTERNAL_SERVER_ERROR\", {\n    message: \"Internal server error\",\n    cause: error\n  });\n}\nfunction isORPCErrorStatus(status) {\n  return status < 200 || status >= 400;\n}\nfunction isORPCErrorJson(json) {\n  if (!isObject(json)) {\n    return false;\n  }\n  const validKeys = [\"defined\", \"code\", \"status\", \"message\", \"data\"];\n  if (Object.keys(json).some((k) => !validKeys.includes(k))) {\n    return false;\n  }\n  return \"defined\" in json && typeof json.defined === \"boolean\" && \"code\" in json && typeof json.code === \"string\" && \"status\" in json && typeof json.status === \"number\" && isORPCErrorStatus(json.status) && \"message\" in json && typeof json.message === \"string\";\n}\nfunction createORPCErrorFromJson(json, options = {}) {\n  return new ORPCError(json.code, {\n    ...options,\n    ...json\n  });\n}\n\nexport { COMMON_ORPC_ERROR_DEFS as C, ORPC_CLIENT_PACKAGE_NAME as O, ORPC_CLIENT_PACKAGE_VERSION as a, fallbackORPCErrorMessage as b, ORPCError as c, isORPCErrorStatus as d, isORPCErrorJson as e, fallbackORPCErrorStatus as f, createORPCErrorFromJson as g, isDefinedError as i, toORPCError as t };\n","import { isTypescriptObject, AsyncIteratorClass, tryDecodeURIComponent, toArray, once, isAsyncIteratorObject, replicateAsyncIterator } from '@orpc/shared';\n\nclass EventEncoderError extends TypeError {\n}\nclass EventDecoderError extends TypeError {\n}\nclass ErrorEvent extends Error {\n  data;\n  constructor(options) {\n    super(options?.message ?? \"An error event was received\", options);\n    this.data = options?.data;\n  }\n}\n\nfunction decodeEventMessage(encoded) {\n  const lines = encoded.replace(/\\n+$/, \"\").split(/\\n/);\n  const message = {\n    data: void 0,\n    event: void 0,\n    id: void 0,\n    retry: void 0,\n    comments: []\n  };\n  for (const line of lines) {\n    const index = line.indexOf(\":\");\n    const key = index === -1 ? line : line.slice(0, index);\n    const value = index === -1 ? \"\" : line.slice(index + 1).replace(/^\\s/, \"\");\n    if (index === 0) {\n      message.comments.push(value);\n    } else if (key === \"data\") {\n      message.data ??= \"\";\n      message.data += `${value}\n`;\n    } else if (key === \"event\") {\n      message.event = value;\n    } else if (key === \"id\") {\n      message.id = value;\n    } else if (key === \"retry\") {\n      const maybeInteger = Number.parseInt(value);\n      if (Number.isInteger(maybeInteger) && maybeInteger >= 0 && maybeInteger.toString() === value) {\n        message.retry = maybeInteger;\n      }\n    }\n  }\n  message.data = message.data?.replace(/\\n$/, \"\");\n  return message;\n}\nclass EventDecoder {\n  constructor(options = {}) {\n    this.options = options;\n  }\n  incomplete = \"\";\n  feed(chunk) {\n    this.incomplete += chunk;\n    const lastCompleteIndex = this.incomplete.lastIndexOf(\"\\n\\n\");\n    if (lastCompleteIndex === -1) {\n      return;\n    }\n    const completes = this.incomplete.slice(0, lastCompleteIndex).split(/\\n\\n/);\n    this.incomplete = this.incomplete.slice(lastCompleteIndex + 2);\n    for (const encoded of completes) {\n      const message = decodeEventMessage(`${encoded}\n\n`);\n      if (this.options.onEvent) {\n        this.options.onEvent(message);\n      }\n    }\n  }\n  end() {\n    if (this.incomplete) {\n      throw new EventDecoderError(\"Event Iterator ended before complete\");\n    }\n  }\n}\nclass EventDecoderStream extends TransformStream {\n  constructor() {\n    let decoder;\n    super({\n      start(controller) {\n        decoder = new EventDecoder({\n          onEvent: (event) => {\n            controller.enqueue(event);\n          }\n        });\n      },\n      transform(chunk) {\n        decoder.feed(chunk);\n      },\n      flush() {\n        decoder.end();\n      }\n    });\n  }\n}\n\nfunction assertEventId(id) {\n  if (id.includes(\"\\n\")) {\n    throw new EventEncoderError(\"Event's id must not contain a newline character\");\n  }\n}\nfunction assertEventName(event) {\n  if (event.includes(\"\\n\")) {\n    throw new EventEncoderError(\"Event's event must not contain a newline character\");\n  }\n}\nfunction assertEventRetry(retry) {\n  if (!Number.isInteger(retry) || retry < 0) {\n    throw new EventEncoderError(\"Event's retry must be a integer and >= 0\");\n  }\n}\nfunction assertEventComment(comment) {\n  if (comment.includes(\"\\n\")) {\n    throw new EventEncoderError(\"Event's comment must not contain a newline character\");\n  }\n}\nfunction encodeEventData(data) {\n  const lines = data?.split(/\\n/) ?? [];\n  let output = \"\";\n  for (const line of lines) {\n    output += `data: ${line}\n`;\n  }\n  return output;\n}\nfunction encodeEventComments(comments) {\n  let output = \"\";\n  for (const comment of comments ?? []) {\n    assertEventComment(comment);\n    output += `: ${comment}\n`;\n  }\n  return output;\n}\nfunction encodeEventMessage(message) {\n  let output = \"\";\n  output += encodeEventComments(message.comments);\n  if (message.event !== void 0) {\n    assertEventName(message.event);\n    output += `event: ${message.event}\n`;\n  }\n  if (message.retry !== void 0) {\n    assertEventRetry(message.retry);\n    output += `retry: ${message.retry}\n`;\n  }\n  if (message.id !== void 0) {\n    assertEventId(message.id);\n    output += `id: ${message.id}\n`;\n  }\n  output += encodeEventData(message.data);\n  output += \"\\n\";\n  return output;\n}\n\nconst EVENT_SOURCE_META_SYMBOL = Symbol(\"ORPC_EVENT_SOURCE_META\");\nfunction withEventMeta(container, meta) {\n  if (meta.id === void 0 && meta.retry === void 0 && !meta.comments?.length) {\n    return container;\n  }\n  if (meta.id !== void 0) {\n    assertEventId(meta.id);\n  }\n  if (meta.retry !== void 0) {\n    assertEventRetry(meta.retry);\n  }\n  if (meta.comments !== void 0) {\n    for (const comment of meta.comments) {\n      assertEventComment(comment);\n    }\n  }\n  return new Proxy(container, {\n    get(target, prop, receiver) {\n      if (prop === EVENT_SOURCE_META_SYMBOL) {\n        return meta;\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction getEventMeta(container) {\n  return isTypescriptObject(container) ? Reflect.get(container, EVENT_SOURCE_META_SYMBOL) : void 0;\n}\n\nclass HibernationEventIterator extends AsyncIteratorClass {\n  /**\n   * this property is not transferred to the client, so it should be optional for type safety\n   */\n  hibernationCallback;\n  constructor(hibernationCallback) {\n    super(async () => {\n      throw new Error(\"Cannot iterate over hibernating iterator directly\");\n    }, async (reason) => {\n      if (reason !== \"next\") {\n        throw new Error(\"Cannot cleanup hibernating iterator directly\");\n      }\n    });\n    this.hibernationCallback = hibernationCallback;\n  }\n}\n\nfunction generateContentDisposition(filename) {\n  const escapedFileName = filename.replace(/\"/g, '\\\\\"');\n  const encodedFilenameStar = encodeURIComponent(filename).replace(/['()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`).replace(/%(7C|60|5E)/g, (str, hex) => String.fromCharCode(Number.parseInt(hex, 16)));\n  return `inline; filename=\"${escapedFileName}\"; filename*=utf-8''${encodedFilenameStar}`;\n}\nfunction getFilenameFromContentDisposition(contentDisposition) {\n  const encodedFilenameStarMatch = contentDisposition.match(/filename\\*=(UTF-8'')?([^;]*)/i);\n  if (encodedFilenameStarMatch && typeof encodedFilenameStarMatch[2] === \"string\") {\n    return tryDecodeURIComponent(encodedFilenameStarMatch[2]);\n  }\n  const encodedFilenameMatch = contentDisposition.match(/filename=\"((?:\\\\\"|[^\"])*)\"/i);\n  if (encodedFilenameMatch && typeof encodedFilenameMatch[1] === \"string\") {\n    return encodedFilenameMatch[1].replace(/\\\\\"/g, '\"');\n  }\n}\nfunction mergeStandardHeaders(a, b) {\n  const merged = { ...a };\n  for (const key in b) {\n    if (Array.isArray(b[key])) {\n      merged[key] = [...toArray(merged[key]), ...b[key]];\n    } else if (b[key] !== void 0) {\n      if (Array.isArray(merged[key])) {\n        merged[key] = [...merged[key], b[key]];\n      } else if (merged[key] !== void 0) {\n        merged[key] = [merged[key], b[key]];\n      } else {\n        merged[key] = b[key];\n      }\n    }\n  }\n  return merged;\n}\nfunction flattenHeader(header) {\n  if (typeof header === \"string\" || header === void 0) {\n    return header;\n  }\n  if (header.length === 0) {\n    return void 0;\n  }\n  return header.join(\", \");\n}\nfunction replicateStandardLazyResponse(response, count) {\n  const replicated = [];\n  let bodyPromise;\n  let replicatedAsyncIteratorObjects;\n  for (let i = 0; i < count; i++) {\n    replicated.push({\n      ...response,\n      body: once(async () => {\n        const body = await (bodyPromise ??= response.body());\n        if (!isAsyncIteratorObject(body)) {\n          return body;\n        }\n        replicatedAsyncIteratorObjects ??= replicateAsyncIterator(body, count);\n        return replicatedAsyncIteratorObjects.shift();\n      })\n    });\n  }\n  return replicated;\n}\nfunction isEventIteratorHeaders(headers) {\n  return Boolean(flattenHeader(headers[\"content-type\"])?.startsWith(\"text/event-stream\") && flattenHeader(headers[\"content-disposition\"]) === void 0);\n}\n\nexport { ErrorEvent, EventDecoder, EventDecoderError, EventDecoderStream, EventEncoderError, HibernationEventIterator, assertEventComment, assertEventId, assertEventName, assertEventRetry, decodeEventMessage, encodeEventComments, encodeEventData, encodeEventMessage, flattenHeader, generateContentDisposition, getEventMeta, getFilenameFromContentDisposition, isEventIteratorHeaders, mergeStandardHeaders, replicateStandardLazyResponse, withEventMeta };\n","import { fallbackORPCErrorStatus, ORPCError, isORPCErrorStatus } from '@orpc/client';\n\nclass ValidationError extends Error {\n  issues;\n  data;\n  constructor(options) {\n    super(options.message, options);\n    this.issues = options.issues;\n    this.data = options.data;\n  }\n}\nfunction mergeErrorMap(errorMap1, errorMap2) {\n  return { ...errorMap1, ...errorMap2 };\n}\nasync function validateORPCError(map, error) {\n  const { code, status, message, data, cause, defined } = error;\n  const config = map?.[error.code];\n  if (!config || fallbackORPCErrorStatus(error.code, config.status) !== error.status) {\n    return defined ? new ORPCError(code, { defined: false, status, message, data, cause }) : error;\n  }\n  if (!config.data) {\n    return defined ? error : new ORPCError(code, { defined: true, status, message, data, cause });\n  }\n  const validated = await config.data[\"~standard\"].validate(error.data);\n  if (validated.issues) {\n    return defined ? new ORPCError(code, { defined: false, status, message, data, cause }) : error;\n  }\n  return new ORPCError(code, { defined: true, status, message, data: validated.value, cause });\n}\n\nclass ContractProcedure {\n  /**\n   * This property holds the defined options for the contract procedure.\n   */\n  \"~orpc\";\n  constructor(def) {\n    if (def.route?.successStatus && isORPCErrorStatus(def.route.successStatus)) {\n      throw new Error(\"[ContractProcedure] Invalid successStatus.\");\n    }\n    if (Object.values(def.errorMap).some((val) => val && val.status && !isORPCErrorStatus(val.status))) {\n      throw new Error(\"[ContractProcedure] Invalid error status code.\");\n    }\n    this[\"~orpc\"] = def;\n  }\n}\nfunction isContractProcedure(item) {\n  if (item instanceof ContractProcedure) {\n    return true;\n  }\n  return (typeof item === \"object\" || typeof item === \"function\") && item !== null && \"~orpc\" in item && typeof item[\"~orpc\"] === \"object\" && item[\"~orpc\"] !== null && \"errorMap\" in item[\"~orpc\"] && \"route\" in item[\"~orpc\"] && \"meta\" in item[\"~orpc\"];\n}\n\nexport { ContractProcedure as C, ValidationError as V, isContractProcedure as i, mergeErrorMap as m, validateORPCError as v };\n","export { group, guard, mapEntries, mapValues, omit, retry, sleep } from 'radash';\n\nfunction resolveMaybeOptionalOptions(rest) {\n  return rest[0] ?? {};\n}\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : value === void 0 || value === null ? [] : [value];\n}\nfunction splitInHalf(arr) {\n  const half = Math.ceil(arr.length / 2);\n  return [arr.slice(0, half), arr.slice(half)];\n}\n\nfunction readAsBuffer(source) {\n  if (typeof source.bytes === \"function\") {\n    return source.bytes();\n  }\n  return source.arrayBuffer();\n}\n\nconst ORPC_NAME = \"orpc\";\nconst ORPC_SHARED_PACKAGE_NAME = \"@orpc/shared\";\nconst ORPC_SHARED_PACKAGE_VERSION = \"1.13.5\";\n\nclass AbortError extends Error {\n  constructor(...rest) {\n    super(...rest);\n    this.name = \"AbortError\";\n  }\n}\n\nfunction once(fn) {\n  let cached;\n  return () => {\n    if (cached) {\n      return cached.result;\n    }\n    const result = fn();\n    cached = { result };\n    return result;\n  };\n}\nfunction sequential(fn) {\n  let lastOperationPromise = Promise.resolve();\n  return (...args) => {\n    return lastOperationPromise = lastOperationPromise.catch(() => {\n    }).then(() => {\n      return fn(...args);\n    });\n  };\n}\nfunction defer(callback) {\n  if (typeof setTimeout === \"function\") {\n    setTimeout(callback, 0);\n  } else {\n    Promise.resolve().then(() => Promise.resolve().then(() => Promise.resolve().then(callback)));\n  }\n}\n\nconst SPAN_ERROR_STATUS = 2;\nconst GLOBAL_OTEL_CONFIG_KEY = `__${ORPC_SHARED_PACKAGE_NAME}@${ORPC_SHARED_PACKAGE_VERSION}/otel/config__`;\nfunction setGlobalOtelConfig(config) {\n  globalThis[GLOBAL_OTEL_CONFIG_KEY] = config;\n}\nfunction getGlobalOtelConfig() {\n  return globalThis[GLOBAL_OTEL_CONFIG_KEY];\n}\nfunction startSpan(name, options = {}, context) {\n  const tracer = getGlobalOtelConfig()?.tracer;\n  return tracer?.startSpan(name, options, context);\n}\nfunction setSpanError(span, error, options = {}) {\n  if (!span) {\n    return;\n  }\n  const exception = toOtelException(error);\n  span.recordException(exception);\n  if (!options.signal?.aborted || options.signal.reason !== error) {\n    span.setStatus({\n      code: SPAN_ERROR_STATUS,\n      message: exception.message\n    });\n  }\n}\nfunction setSpanAttribute(span, key, value) {\n  if (!span || value === void 0) {\n    return;\n  }\n  span.setAttribute(key, value);\n}\nfunction toOtelException(error) {\n  if (error instanceof Error) {\n    const exception = {\n      message: error.message,\n      name: error.name,\n      stack: error.stack\n    };\n    if (\"code\" in error && (typeof error.code === \"string\" || typeof error.code === \"number\")) {\n      exception.code = error.code;\n    }\n    return exception;\n  }\n  return { message: String(error) };\n}\nfunction toSpanAttributeValue(data) {\n  if (data === void 0) {\n    return \"undefined\";\n  }\n  try {\n    return JSON.stringify(data, (_, value) => {\n      if (typeof value === \"bigint\") {\n        return value.toString();\n      }\n      if (value instanceof Map || value instanceof Set) {\n        return Array.from(value);\n      }\n      return value;\n    });\n  } catch {\n    return String(data);\n  }\n}\nasync function runWithSpan({ name, context, ...options }, fn) {\n  const tracer = getGlobalOtelConfig()?.tracer;\n  if (!tracer) {\n    return fn();\n  }\n  const callback = async (span) => {\n    try {\n      return await fn(span);\n    } catch (e) {\n      setSpanError(span, e, options);\n      throw e;\n    } finally {\n      span.end();\n    }\n  };\n  if (context) {\n    return tracer.startActiveSpan(name, options, context, callback);\n  } else {\n    return tracer.startActiveSpan(name, options, callback);\n  }\n}\nasync function runInSpanContext(span, fn) {\n  const otelConfig = getGlobalOtelConfig();\n  if (!span || !otelConfig) {\n    return fn();\n  }\n  const ctx = otelConfig.trace.setSpan(otelConfig.context.active(), span);\n  return otelConfig.context.with(ctx, fn);\n}\n\nclass AsyncIdQueue {\n  openIds = /* @__PURE__ */ new Set();\n  queues = /* @__PURE__ */ new Map();\n  waiters = /* @__PURE__ */ new Map();\n  get length() {\n    return this.openIds.size;\n  }\n  get waiterIds() {\n    return Array.from(this.waiters.keys());\n  }\n  hasBufferedItems(id) {\n    return Boolean(this.queues.get(id)?.length);\n  }\n  open(id) {\n    this.openIds.add(id);\n  }\n  isOpen(id) {\n    return this.openIds.has(id);\n  }\n  push(id, item) {\n    this.assertOpen(id);\n    const pending = this.waiters.get(id);\n    if (pending?.length) {\n      pending.shift()[0](item);\n      if (pending.length === 0) {\n        this.waiters.delete(id);\n      }\n    } else {\n      const items = this.queues.get(id);\n      if (items) {\n        items.push(item);\n      } else {\n        this.queues.set(id, [item]);\n      }\n    }\n  }\n  async pull(id) {\n    this.assertOpen(id);\n    const items = this.queues.get(id);\n    if (items?.length) {\n      const item = items.shift();\n      if (items.length === 0) {\n        this.queues.delete(id);\n      }\n      return item;\n    }\n    return new Promise((resolve, reject) => {\n      const waitingPulls = this.waiters.get(id);\n      const pending = [resolve, reject];\n      if (waitingPulls) {\n        waitingPulls.push(pending);\n      } else {\n        this.waiters.set(id, [pending]);\n      }\n    });\n  }\n  close({ id, reason } = {}) {\n    if (id === void 0) {\n      this.waiters.forEach((pendingPulls, id2) => {\n        const error2 = reason ?? new AbortError(`[AsyncIdQueue] Queue[${id2}] was closed or aborted while waiting for pulling.`);\n        pendingPulls.forEach(([, reject]) => reject(error2));\n      });\n      this.waiters.clear();\n      this.openIds.clear();\n      this.queues.clear();\n      return;\n    }\n    const error = reason ?? new AbortError(`[AsyncIdQueue] Queue[${id}] was closed or aborted while waiting for pulling.`);\n    this.waiters.get(id)?.forEach(([, reject]) => reject(error));\n    this.waiters.delete(id);\n    this.openIds.delete(id);\n    this.queues.delete(id);\n  }\n  assertOpen(id) {\n    if (!this.isOpen(id)) {\n      throw new Error(`[AsyncIdQueue] Cannot access queue[${id}] because it is not open or aborted.`);\n    }\n  }\n}\n\nfunction isAsyncIteratorObject(maybe) {\n  if (!maybe || typeof maybe !== \"object\") {\n    return false;\n  }\n  return \"next\" in maybe && typeof maybe.next === \"function\" && Symbol.asyncIterator in maybe && typeof maybe[Symbol.asyncIterator] === \"function\";\n}\nconst fallbackAsyncDisposeSymbol = Symbol.for(\"asyncDispose\");\nconst asyncDisposeSymbol = Symbol.asyncDispose ?? fallbackAsyncDisposeSymbol;\nclass AsyncIteratorClass {\n  #isDone = false;\n  #isExecuteComplete = false;\n  #cleanup;\n  #next;\n  constructor(next, cleanup) {\n    this.#cleanup = cleanup;\n    this.#next = sequential(async () => {\n      if (this.#isDone) {\n        return { done: true, value: void 0 };\n      }\n      try {\n        const result = await next();\n        if (result.done) {\n          this.#isDone = true;\n        }\n        return result;\n      } catch (err) {\n        this.#isDone = true;\n        throw err;\n      } finally {\n        if (this.#isDone && !this.#isExecuteComplete) {\n          this.#isExecuteComplete = true;\n          await this.#cleanup(\"next\");\n        }\n      }\n    });\n  }\n  next() {\n    return this.#next();\n  }\n  async return(value) {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"return\");\n    }\n    return { done: true, value };\n  }\n  async throw(err) {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"throw\");\n    }\n    throw err;\n  }\n  /**\n   * asyncDispose symbol only available in esnext, we should fallback to Symbol.for('asyncDispose')\n   */\n  async [asyncDisposeSymbol]() {\n    this.#isDone = true;\n    if (!this.#isExecuteComplete) {\n      this.#isExecuteComplete = true;\n      await this.#cleanup(\"dispose\");\n    }\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n}\nfunction replicateAsyncIterator(source, count) {\n  const queue = new AsyncIdQueue();\n  const ids = Array.from({ length: count }, (_, i) => i.toString());\n  let isSourceFinished = false;\n  const start = once(async () => {\n    try {\n      while (true) {\n        const item = await source.next();\n        ids.forEach((id) => {\n          if (queue.isOpen(id)) {\n            queue.push(id, { next: item });\n          }\n        });\n        if (item.done) {\n          break;\n        }\n      }\n    } catch (error) {\n      ids.forEach((id) => {\n        if (queue.isOpen(id)) {\n          queue.push(id, { error });\n        }\n      });\n    } finally {\n      isSourceFinished = true;\n    }\n  });\n  const replicated = ids.map((id) => {\n    queue.open(id);\n    return new AsyncIteratorClass(\n      async () => {\n        start();\n        const item = await queue.pull(id);\n        if (item.next) {\n          return item.next;\n        }\n        throw item.error;\n      },\n      async (reason) => {\n        queue.close({ id });\n        if (reason !== \"next\" && !queue.length && !isSourceFinished) {\n          isSourceFinished = true;\n          await source?.return?.();\n        }\n      }\n    );\n  });\n  return replicated;\n}\nfunction asyncIteratorWithSpan({ name, ...options }, iterator) {\n  let span;\n  return new AsyncIteratorClass(\n    async () => {\n      span ??= startSpan(name);\n      try {\n        const result = await runInSpanContext(span, () => iterator.next());\n        span?.addEvent(result.done ? \"completed\" : \"yielded\");\n        return result;\n      } catch (err) {\n        setSpanError(span, err, options);\n        throw err;\n      }\n    },\n    async (reason) => {\n      try {\n        if (reason !== \"next\") {\n          await runInSpanContext(span, () => iterator.return?.());\n        }\n      } catch (err) {\n        setSpanError(span, err, options);\n        throw err;\n      } finally {\n        span?.end();\n      }\n    }\n  );\n}\n\nclass EventPublisher {\n  #listenersMap = /* @__PURE__ */ new Map();\n  #maxBufferedEvents;\n  constructor(options = {}) {\n    this.#maxBufferedEvents = options.maxBufferedEvents ?? 100;\n  }\n  get size() {\n    return this.#listenersMap.size;\n  }\n  /**\n   * Emits an event and delivers the payload to all subscribed listeners.\n   */\n  publish(event, payload) {\n    const listeners = this.#listenersMap.get(event);\n    if (!listeners) {\n      return;\n    }\n    for (const listener of listeners) {\n      listener(payload);\n    }\n  }\n  subscribe(event, listenerOrOptions) {\n    if (typeof listenerOrOptions === \"function\") {\n      let listeners = this.#listenersMap.get(event);\n      if (!listeners) {\n        this.#listenersMap.set(event, listeners = []);\n      }\n      listeners.push(listenerOrOptions);\n      return once(() => {\n        listeners.splice(listeners.indexOf(listenerOrOptions), 1);\n        if (listeners.length === 0) {\n          this.#listenersMap.delete(event);\n        }\n      });\n    }\n    const signal = listenerOrOptions?.signal;\n    const maxBufferedEvents = listenerOrOptions?.maxBufferedEvents ?? this.#maxBufferedEvents;\n    signal?.throwIfAborted();\n    const bufferedEvents = [];\n    const pullResolvers = [];\n    const unsubscribe = this.subscribe(event, (payload) => {\n      const resolver = pullResolvers.shift();\n      if (resolver) {\n        resolver[0]({ done: false, value: payload });\n      } else {\n        bufferedEvents.push(payload);\n        if (bufferedEvents.length > maxBufferedEvents) {\n          bufferedEvents.shift();\n        }\n      }\n    });\n    const abortListener = (event2) => {\n      unsubscribe();\n      pullResolvers.forEach((resolver) => resolver[1](event2.target.reason));\n      pullResolvers.length = 0;\n      bufferedEvents.length = 0;\n    };\n    signal?.addEventListener(\"abort\", abortListener, { once: true });\n    return new AsyncIteratorClass(async () => {\n      if (signal?.aborted) {\n        throw signal.reason;\n      }\n      if (bufferedEvents.length > 0) {\n        return { done: false, value: bufferedEvents.shift() };\n      }\n      return new Promise((resolve, reject) => {\n        pullResolvers.push([resolve, reject]);\n      });\n    }, async () => {\n      unsubscribe();\n      signal?.removeEventListener(\"abort\", abortListener);\n      pullResolvers.forEach((resolver) => resolver[0]({ done: true, value: void 0 }));\n      pullResolvers.length = 0;\n      bufferedEvents.length = 0;\n    });\n  }\n}\n\nclass SequentialIdGenerator {\n  index = BigInt(1);\n  generate() {\n    const id = this.index.toString(36);\n    this.index++;\n    return id;\n  }\n}\nfunction compareSequentialIds(a, b) {\n  if (a.length !== b.length) {\n    return a.length - b.length;\n  }\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction onStart(callback) {\n  return async (options, ...rest) => {\n    await callback(options, ...rest);\n    return await options.next();\n  };\n}\nfunction onSuccess(callback) {\n  return async (options, ...rest) => {\n    const result = await options.next();\n    await callback(result, options, ...rest);\n    return result;\n  };\n}\nfunction onError(callback) {\n  return async (options, ...rest) => {\n    try {\n      return await options.next();\n    } catch (error) {\n      await callback(error, options, ...rest);\n      throw error;\n    }\n  };\n}\nfunction onFinish(callback) {\n  let state;\n  return async (options, ...rest) => {\n    try {\n      const result = await options.next();\n      state = [null, result, true];\n      return result;\n    } catch (error) {\n      state = [error, void 0, false];\n      throw error;\n    } finally {\n      await callback(state, options, ...rest);\n    }\n  };\n}\nfunction intercept(interceptors, options, main) {\n  const next = (options2, index) => {\n    const interceptor = interceptors[index];\n    if (!interceptor) {\n      return main(options2);\n    }\n    return interceptor({\n      ...options2,\n      next: (newOptions = options2) => next(newOptions, index + 1)\n    });\n  };\n  return next(options, 0);\n}\n\nfunction parseEmptyableJSON(text) {\n  if (!text) {\n    return void 0;\n  }\n  return JSON.parse(text);\n}\nfunction stringifyJSON(value) {\n  return JSON.stringify(value);\n}\n\nfunction findDeepMatches(check, payload, segments = [], maps = [], values = []) {\n  if (check(payload)) {\n    maps.push(segments);\n    values.push(payload);\n  } else if (Array.isArray(payload)) {\n    payload.forEach((v, i) => {\n      findDeepMatches(check, v, [...segments, i], maps, values);\n    });\n  } else if (isObject(payload)) {\n    for (const key in payload) {\n      findDeepMatches(check, payload[key], [...segments, key], maps, values);\n    }\n  }\n  return { maps, values };\n}\nfunction getConstructor(value) {\n  if (!isTypescriptObject(value)) {\n    return null;\n  }\n  return Object.getPrototypeOf(value)?.constructor;\n}\nfunction isObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  return proto === Object.prototype || !proto || !proto.constructor;\n}\nfunction isTypescriptObject(value) {\n  return !!value && (typeof value === \"object\" || typeof value === \"function\");\n}\nfunction clone(value) {\n  if (Array.isArray(value)) {\n    return value.map(clone);\n  }\n  if (isObject(value)) {\n    const result = {};\n    for (const key in value) {\n      result[key] = clone(value[key]);\n    }\n    for (const sym of Object.getOwnPropertySymbols(value)) {\n      result[sym] = clone(value[sym]);\n    }\n    return result;\n  }\n  return value;\n}\nfunction get(object, path) {\n  let current = object;\n  for (const key of path) {\n    if (!isTypescriptObject(current)) {\n      return void 0;\n    }\n    current = current[key];\n  }\n  return current;\n}\nfunction isPropertyKey(value) {\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"symbol\";\n}\nconst NullProtoObj = /* @__PURE__ */ (() => {\n  const e = function() {\n  };\n  e.prototype = /* @__PURE__ */ Object.create(null);\n  Object.freeze(e.prototype);\n  return e;\n})();\n\nfunction value(value2, ...args) {\n  if (typeof value2 === \"function\") {\n    return value2(...args);\n  }\n  return value2;\n}\nfunction fallback(value2, fallback2) {\n  return value2 === void 0 ? fallback2 : value2;\n}\n\nfunction preventNativeAwait(target) {\n  return new Proxy(target, {\n    get(target2, prop, receiver) {\n      const value2 = Reflect.get(target2, prop, receiver);\n      if (prop !== \"then\" || typeof value2 !== \"function\") {\n        return value2;\n      }\n      return new Proxy(value2, {\n        apply(targetFn, thisArg, args) {\n          if (args.length !== 2 || args.some((arg) => !isNativeFunction(arg))) {\n            return Reflect.apply(targetFn, thisArg, args);\n          }\n          let shouldOmit = true;\n          args[0].call(thisArg, preventNativeAwait(new Proxy(target2, {\n            get: (target3, prop2, receiver2) => {\n              if (shouldOmit && prop2 === \"then\") {\n                shouldOmit = false;\n                return void 0;\n              }\n              return Reflect.get(target3, prop2, receiver2);\n            }\n          })));\n        }\n      });\n    }\n  });\n}\nconst NATIVE_FUNCTION_REGEX = /^\\s*function\\s*\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}\\s*$/;\nfunction isNativeFunction(fn) {\n  return typeof fn === \"function\" && NATIVE_FUNCTION_REGEX.test(fn.toString());\n}\nfunction overlayProxy(target, partial) {\n  const proxy = new Proxy(typeof target === \"function\" ? partial : target, {\n    get(_, prop) {\n      const targetValue = prop in partial ? partial : value(target);\n      const v = Reflect.get(targetValue, prop);\n      return typeof v === \"function\" ? v.bind(targetValue) : v;\n    },\n    has(_, prop) {\n      return Reflect.has(partial, prop) || Reflect.has(value(target), prop);\n    }\n  });\n  return proxy;\n}\n\nfunction streamToAsyncIteratorClass(stream) {\n  const reader = stream.getReader();\n  return new AsyncIteratorClass(\n    async () => {\n      return reader.read();\n    },\n    async () => {\n      await reader.cancel();\n    }\n  );\n}\nfunction asyncIteratorToStream(iterator) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n    async cancel() {\n      await iterator.return?.();\n    }\n  });\n}\nfunction asyncIteratorToUnproxiedDataStream(iterator) {\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await iterator.next();\n      if (done) {\n        controller.close();\n      } else {\n        const unproxied = isObject(value) ? { ...value } : Array.isArray(value) ? value.map((i) => i) : value;\n        controller.enqueue(unproxied);\n      }\n    },\n    async cancel() {\n      await iterator.return?.();\n    }\n  });\n}\n\nfunction tryDecodeURIComponent(value) {\n  try {\n    return decodeURIComponent(value);\n  } catch {\n    return value;\n  }\n}\n\nexport { AbortError, AsyncIdQueue, AsyncIteratorClass, EventPublisher, NullProtoObj, ORPC_NAME, ORPC_SHARED_PACKAGE_NAME, ORPC_SHARED_PACKAGE_VERSION, SequentialIdGenerator, asyncIteratorToStream, asyncIteratorToUnproxiedDataStream, asyncIteratorWithSpan, clone, compareSequentialIds, defer, fallback, findDeepMatches, get, getConstructor, getGlobalOtelConfig, intercept, isAsyncIteratorObject, isObject, isPropertyKey, isTypescriptObject, onError, onFinish, onStart, onSuccess, once, overlayProxy, parseEmptyableJSON, preventNativeAwait, readAsBuffer, replicateAsyncIterator, resolveMaybeOptionalOptions, runInSpanContext, runWithSpan, sequential, setGlobalOtelConfig, setSpanAttribute, setSpanError, splitInHalf, startSpan, streamToAsyncIteratorClass, stringifyJSON, toArray, toOtelException, toSpanAttributeValue, tryDecodeURIComponent, value };\n","import { stringifyJSON, parseEmptyableJSON, AsyncIteratorClass, isAsyncIteratorObject, isObject } from '@orpc/shared';\n\nfunction toBatchAbortSignal(signals) {\n  const realSignals = signals.filter((signal) => signal !== void 0);\n  if (realSignals.length === 0 || realSignals.length !== signals.length) {\n    return void 0;\n  }\n  const controller = new AbortController();\n  const abortIfAllInputsAborted = () => {\n    if (realSignals.every((signal) => signal.aborted)) {\n      controller.abort();\n    }\n  };\n  abortIfAllInputsAborted();\n  for (const signal of realSignals) {\n    signal.addEventListener(\"abort\", () => {\n      abortIfAllInputsAborted();\n    }, {\n      once: true,\n      signal: controller.signal\n    });\n  }\n  return controller.signal;\n}\n\nfunction toBatchRequest(options) {\n  const url = new URL(options.url);\n  let body;\n  const batchRequestItems = options.requests.map((request) => ({\n    body: request.body,\n    headers: Object.keys(request.headers).length ? request.headers : void 0,\n    method: request.method === options.method ? void 0 : request.method,\n    url: request.url\n  }));\n  if (options.method === \"GET\") {\n    url.searchParams.append(\"batch\", stringifyJSON(batchRequestItems));\n  } else if (options.method === \"POST\") {\n    body = batchRequestItems;\n  }\n  return {\n    method: options.method,\n    url,\n    headers: options.headers,\n    body,\n    signal: toBatchAbortSignal(options.requests.map((request) => request.signal))\n  };\n}\nfunction parseBatchRequest(request) {\n  const items = request.method === \"GET\" ? parseEmptyableJSON(request.url.searchParams.getAll(\"batch\").at(-1)) : request.body;\n  if (!Array.isArray(items)) {\n    throw new TypeError(\"Invalid batch request\");\n  }\n  return items.map((item) => {\n    return {\n      method: item.method ?? request.method,\n      url: new URL(item.url),\n      headers: item.headers ?? {},\n      body: item.body,\n      signal: request.signal\n    };\n  });\n}\n\nfunction toBatchResponse(options) {\n  const mode = options.mode ?? \"streaming\";\n  const minifyResponseItem = (item) => {\n    return {\n      index: item.index,\n      status: item.status === options.status ? void 0 : item.status,\n      headers: Object.keys(item.headers).length ? item.headers : void 0,\n      body: item.body\n    };\n  };\n  if (mode === \"buffered\") {\n    return (async () => {\n      try {\n        const body = [];\n        for await (const item of options.body) {\n          body.push(minifyResponseItem(item));\n        }\n        return {\n          headers: options.headers,\n          status: options.status,\n          body\n        };\n      } finally {\n        await options.body.return?.();\n      }\n    })();\n  }\n  return {\n    headers: options.headers,\n    status: options.status,\n    body: new AsyncIteratorClass(\n      async () => {\n        const { done, value } = await options.body.next();\n        if (done) {\n          return { done, value };\n        }\n        return {\n          done,\n          value: {\n            index: value.index,\n            status: value.status === options.status ? void 0 : value.status,\n            headers: Object.keys(value.headers).length ? value.headers : void 0,\n            body: value.body\n          }\n        };\n      },\n      async (reason) => {\n        if (reason !== \"next\") {\n          await options.body.return?.();\n        }\n      }\n    )\n  };\n}\nfunction parseBatchResponse(response) {\n  const body = response.body;\n  if (isAsyncIteratorObject(body) || Array.isArray(body)) {\n    const iterator = (async function* () {\n      for await (const item of body) {\n        if (!isObject(item) || !(\"index\" in item) || typeof item.index !== \"number\") {\n          throw new TypeError(\"Invalid batch response\", {\n            cause: item\n          });\n        }\n        yield {\n          index: item.index,\n          status: item.status ?? response.status,\n          headers: item.headers ?? {},\n          body: item.body\n        };\n      }\n    })();\n    return new AsyncIteratorClass(\n      () => iterator.next(),\n      async (reason) => {\n        if (reason !== \"next\" && isAsyncIteratorObject(body)) {\n          await body.return?.();\n        }\n      }\n    );\n  }\n  throw new TypeError(\"Invalid batch response\", {\n    cause: response\n  });\n}\n\nexport { parseBatchRequest, parseBatchResponse, toBatchAbortSignal, toBatchRequest, toBatchResponse };\n","import { ORPCError, fallbackContractConfig } from '@orpc/contract';\n\nconst STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT_SYMBOL = Symbol(\"STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT\");\nclass StrictGetMethodPlugin {\n  error;\n  /**\n   * make sure execute before batch plugin to get real method\n   */\n  order = 7e6;\n  constructor(options = {}) {\n    this.error = options.error ?? new ORPCError(\"METHOD_NOT_SUPPORTED\");\n  }\n  init(options) {\n    options.rootInterceptors ??= [];\n    options.clientInterceptors ??= [];\n    options.rootInterceptors.unshift((options2) => {\n      const isGetMethod = options2.request.method === \"GET\";\n      return options2.next({\n        ...options2,\n        context: {\n          ...options2.context,\n          [STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT_SYMBOL]: isGetMethod\n        }\n      });\n    });\n    options.clientInterceptors.unshift((options2) => {\n      if (typeof options2.context[STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT_SYMBOL] !== \"boolean\") {\n        throw new TypeError(\"[StrictGetMethodPlugin] strict GET method context has been corrupted or modified by another plugin or interceptor\");\n      }\n      const procedureMethod = fallbackContractConfig(\"defaultMethod\", options2.procedure[\"~orpc\"].route.method);\n      if (options2.context[STRICT_GET_METHOD_PLUGIN_IS_GET_METHOD_CONTEXT_SYMBOL] && procedureMethod !== \"GET\") {\n        throw this.error;\n      }\n      return options2.next();\n    });\n  }\n}\n\nexport { StrictGetMethodPlugin as S };\n","import { AsyncIteratorClass, startSpan, runInSpanContext, AbortError, parseEmptyableJSON, isTypescriptObject, setSpanError, stringifyJSON, runWithSpan, isAsyncIteratorObject, once } from '@orpc/shared';\nimport { EventDecoderStream, withEventMeta, ErrorEvent, encodeEventMessage, getEventMeta, getFilenameFromContentDisposition, generateContentDisposition } from '@orpc/standard-server';\n\nfunction toEventIterator(stream, options = {}) {\n  const eventStream = stream?.pipeThrough(new TextDecoderStream()).pipeThrough(new EventDecoderStream());\n  const reader = eventStream?.getReader();\n  let span;\n  let isCancelled = false;\n  return new AsyncIteratorClass(async () => {\n    span ??= startSpan(\"consume_event_iterator_stream\");\n    try {\n      while (true) {\n        if (reader === void 0) {\n          return { done: true, value: void 0 };\n        }\n        const { done, value } = await runInSpanContext(span, () => reader.read());\n        if (done) {\n          if (isCancelled) {\n            throw new AbortError(\"Stream was cancelled\");\n          }\n          return { done: true, value: void 0 };\n        }\n        switch (value.event) {\n          case \"message\": {\n            let message = parseEmptyableJSON(value.data);\n            if (isTypescriptObject(message)) {\n              message = withEventMeta(message, value);\n            }\n            span?.addEvent(\"message\");\n            return { done: false, value: message };\n          }\n          case \"error\": {\n            let error = new ErrorEvent({\n              data: parseEmptyableJSON(value.data)\n            });\n            error = withEventMeta(error, value);\n            span?.addEvent(\"error\");\n            throw error;\n          }\n          case \"done\": {\n            let done2 = parseEmptyableJSON(value.data);\n            if (isTypescriptObject(done2)) {\n              done2 = withEventMeta(done2, value);\n            }\n            span?.addEvent(\"done\");\n            return { done: true, value: done2 };\n          }\n          default: {\n            span?.addEvent(\"maybe_keepalive\");\n          }\n        }\n      }\n    } catch (e) {\n      if (!(e instanceof ErrorEvent)) {\n        setSpanError(span, e, options);\n      }\n      throw e;\n    }\n  }, async (reason) => {\n    try {\n      if (reason !== \"next\") {\n        isCancelled = true;\n        span?.addEvent(\"cancelled\");\n      }\n      await runInSpanContext(span, () => reader?.cancel());\n    } catch (e) {\n      setSpanError(span, e, options);\n      throw e;\n    } finally {\n      span?.end();\n    }\n  });\n}\nfunction toEventStream(iterator, options = {}) {\n  const keepAliveEnabled = options.eventIteratorKeepAliveEnabled ?? true;\n  const keepAliveInterval = options.eventIteratorKeepAliveInterval ?? 5e3;\n  const keepAliveComment = options.eventIteratorKeepAliveComment ?? \"\";\n  const initialCommentEnabled = options.eventIteratorInitialCommentEnabled ?? true;\n  const initialComment = options.eventIteratorInitialComment ?? \"\";\n  let cancelled = false;\n  let timeout;\n  let span;\n  const stream = new ReadableStream({\n    start(controller) {\n      span = startSpan(\"stream_event_iterator\");\n      if (initialCommentEnabled) {\n        controller.enqueue(encodeEventMessage({\n          comments: [initialComment]\n        }));\n      }\n    },\n    async pull(controller) {\n      try {\n        if (keepAliveEnabled) {\n          timeout = setInterval(() => {\n            controller.enqueue(encodeEventMessage({\n              comments: [keepAliveComment]\n            }));\n            span?.addEvent(\"keepalive\");\n          }, keepAliveInterval);\n        }\n        const value = await runInSpanContext(span, () => iterator.next());\n        clearInterval(timeout);\n        if (cancelled) {\n          return;\n        }\n        const meta = getEventMeta(value.value);\n        if (!value.done || value.value !== void 0 || meta !== void 0) {\n          const event = value.done ? \"done\" : \"message\";\n          controller.enqueue(encodeEventMessage({\n            ...meta,\n            event,\n            data: stringifyJSON(value.value)\n          }));\n          span?.addEvent(event);\n        }\n        if (value.done) {\n          controller.close();\n          span?.end();\n        }\n      } catch (err) {\n        clearInterval(timeout);\n        if (cancelled) {\n          return;\n        }\n        if (err instanceof ErrorEvent) {\n          controller.enqueue(encodeEventMessage({\n            ...getEventMeta(err),\n            event: \"error\",\n            data: stringifyJSON(err.data)\n          }));\n          span?.addEvent(\"error\");\n          controller.close();\n        } else {\n          setSpanError(span, err);\n          controller.error(err);\n        }\n        span?.end();\n      }\n    },\n    async cancel() {\n      try {\n        cancelled = true;\n        clearInterval(timeout);\n        span?.addEvent(\"cancelled\");\n        await runInSpanContext(span, () => iterator.return?.());\n      } catch (e) {\n        setSpanError(span, e);\n        throw e;\n      } finally {\n        span?.end();\n      }\n    }\n  }).pipeThrough(new TextEncoderStream());\n  return stream;\n}\n\nfunction toStandardBody(re, options = {}) {\n  return runWithSpan(\n    { name: \"parse_standard_body\", signal: options.signal },\n    async () => {\n      const contentDisposition = re.headers.get(\"content-disposition\");\n      if (typeof contentDisposition === \"string\") {\n        const fileName = getFilenameFromContentDisposition(contentDisposition) ?? \"blob\";\n        const blob2 = await re.blob();\n        return new File([blob2], fileName, {\n          type: blob2.type\n        });\n      }\n      const contentType = re.headers.get(\"content-type\");\n      if (!contentType || contentType.startsWith(\"application/json\")) {\n        const text = await re.text();\n        return parseEmptyableJSON(text);\n      }\n      if (contentType.startsWith(\"multipart/form-data\")) {\n        return await re.formData();\n      }\n      if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n        const text = await re.text();\n        return new URLSearchParams(text);\n      }\n      if (contentType.startsWith(\"text/event-stream\")) {\n        return toEventIterator(re.body, options);\n      }\n      if (contentType.startsWith(\"text/plain\")) {\n        return await re.text();\n      }\n      const blob = await re.blob();\n      return new File([blob], \"blob\", {\n        type: blob.type\n      });\n    }\n  );\n}\nfunction toFetchBody(body, headers, options = {}) {\n  const currentContentDisposition = headers.get(\"content-disposition\");\n  headers.delete(\"content-type\");\n  headers.delete(\"content-disposition\");\n  if (body === void 0) {\n    return void 0;\n  }\n  if (body instanceof Blob) {\n    headers.set(\"content-type\", body.type);\n    headers.set(\"content-length\", body.size.toString());\n    headers.set(\n      \"content-disposition\",\n      currentContentDisposition ?? generateContentDisposition(body instanceof File ? body.name : \"blob\")\n    );\n    return body;\n  }\n  if (body instanceof FormData) {\n    return body;\n  }\n  if (body instanceof URLSearchParams) {\n    return body;\n  }\n  if (isAsyncIteratorObject(body)) {\n    headers.set(\"content-type\", \"text/event-stream\");\n    return toEventStream(body, options);\n  }\n  headers.set(\"content-type\", \"application/json\");\n  return stringifyJSON(body);\n}\n\nfunction toStandardHeaders(headers, standardHeaders = {}) {\n  headers.forEach((value, key) => {\n    if (Array.isArray(standardHeaders[key])) {\n      standardHeaders[key].push(value);\n    } else if (standardHeaders[key] !== void 0) {\n      standardHeaders[key] = [standardHeaders[key], value];\n    } else {\n      standardHeaders[key] = value;\n    }\n  });\n  return standardHeaders;\n}\nfunction toFetchHeaders(headers, fetchHeaders = new Headers()) {\n  for (const [key, value] of Object.entries(headers)) {\n    if (Array.isArray(value)) {\n      for (const v of value) {\n        fetchHeaders.append(key, v);\n      }\n    } else if (value !== void 0) {\n      fetchHeaders.append(key, value);\n    }\n  }\n  return fetchHeaders;\n}\n\nfunction toStandardLazyRequest(request) {\n  return {\n    url: new URL(request.url),\n    signal: request.signal,\n    method: request.method,\n    body: once(() => toStandardBody(request, { signal: request.signal })),\n    get headers() {\n      const headers = toStandardHeaders(request.headers);\n      Object.defineProperty(this, \"headers\", { value: headers, writable: true });\n      return headers;\n    },\n    set headers(value) {\n      Object.defineProperty(this, \"headers\", { value, writable: true });\n    }\n  };\n}\nfunction toFetchRequest(request, options = {}) {\n  const headers = toFetchHeaders(request.headers);\n  const body = toFetchBody(request.body, headers, options);\n  return new Request(request.url, {\n    signal: request.signal,\n    method: request.method,\n    headers,\n    body\n  });\n}\n\nfunction toFetchResponse(response, options = {}) {\n  const headers = toFetchHeaders(response.headers);\n  const body = toFetchBody(response.body, headers, options);\n  return new Response(body, { headers, status: response.status });\n}\nfunction toStandardLazyResponse(response, options = {}) {\n  return {\n    body: once(() => toStandardBody(response, options)),\n    status: response.status,\n    get headers() {\n      const headers = toStandardHeaders(response.headers);\n      Object.defineProperty(this, \"headers\", { value: headers, writable: true });\n      return headers;\n    },\n    set headers(value) {\n      Object.defineProperty(this, \"headers\", { value, writable: true });\n    }\n  };\n}\n\nexport { toEventIterator, toEventStream, toFetchBody, toFetchHeaders, toFetchRequest, toFetchResponse, toStandardBody, toStandardHeaders, toStandardLazyRequest, toStandardLazyResponse };\n","import { AsyncIteratorClass, isTypescriptObject } from '@orpc/shared';\nimport { getEventMeta, withEventMeta } from '@orpc/standard-server';\n\nfunction mapEventIterator(iterator, maps) {\n  const mapError = async (error) => {\n    let mappedError = await maps.error(error);\n    if (mappedError !== error) {\n      const meta = getEventMeta(error);\n      if (meta && isTypescriptObject(mappedError)) {\n        mappedError = withEventMeta(mappedError, meta);\n      }\n    }\n    return mappedError;\n  };\n  return new AsyncIteratorClass(async () => {\n    const { done, value } = await (async () => {\n      try {\n        return await iterator.next();\n      } catch (error) {\n        throw await mapError(error);\n      }\n    })();\n    let mappedValue = await maps.value(value, done);\n    if (mappedValue !== value) {\n      const meta = getEventMeta(value);\n      if (meta && isTypescriptObject(mappedValue)) {\n        mappedValue = withEventMeta(mappedValue, meta);\n      }\n    }\n    return { done, value: mappedValue };\n  }, async () => {\n    try {\n      await iterator.return?.();\n    } catch (error) {\n      throw await mapError(error);\n    }\n  });\n}\n\nexport { mapEventIterator as m };\n","import { eq } from \"drizzle-orm\";\nimport { z } from \"zod\";\n\nimport { db } from \"@/lib/db\";\nimport { siteSetting } from \"@/lib/db/schema/siteSetting\";\n\nimport { adminProcedure, publicProcedure } from \"../index\";\n\nexport const settingRouter = {\n  get: publicProcedure\n    .input(z.object({ key: z.string().min(1) }))\n    .handler(async ({ input }) => {\n      const [row] = await db\n        .select()\n        .from(siteSetting)\n        .where(eq(siteSetting.key, input.key))\n        .limit(1);\n      return row?.value ?? null;\n    }),\n\n  upsert: adminProcedure\n    .input(z.object({ key: z.string().min(1), value: z.string() }))\n    .handler(async ({ input }) => {\n      await db\n        .insert(siteSetting)\n        .values({ key: input.key, value: input.value })\n        .onConflictDoUpdate({\n          target: siteSetting.key,\n          set: { value: input.value },\n        });\n      return { ok: true };\n    }),\n};\n","import { ORPCError, os } from \"@orpc/server\";\n\nimport type { Context } from \"./context\";\n\nexport const o = os.$context<Context>();\n\nexport const publicProcedure = o;\n\nconst requireAuth = o.middleware(async ({ context, next }) => {\n  if (!context.session?.user) {\n    throw new ORPCError(\"UNAUTHORIZED\");\n  }\n  return next({\n    context: {\n      session: context.session,\n    },\n  });\n});\n\nconst requireAdmin = o.middleware(async ({ context, next }) => {\n  if (!context.session?.user) {\n    throw new ORPCError(\"UNAUTHORIZED\");\n  }\n  if (!context.isAdmin) {\n    throw new ORPCError(\"FORBIDDEN\");\n  }\n  return next({\n    context: {\n      session: context.session,\n    },\n  });\n});\n\nexport const protectedProcedure = publicProcedure.use(requireAuth);\nexport const adminProcedure = publicProcedure.use(requireAdmin);\n","import { isContractProcedure, validateORPCError, ValidationError, mergePrefix, mergeErrorMap, enhanceRoute } from '@orpc/contract';\nimport { resolveMaybeOptionalOptions, toArray, value, runWithSpan, intercept, isAsyncIteratorObject, overlayProxy, asyncIteratorWithSpan } from '@orpc/shared';\nimport { ORPCError, mapEventIterator } from '@orpc/client';\nimport { HibernationEventIterator } from '@orpc/standard-server';\n\nconst LAZY_SYMBOL = Symbol(\"ORPC_LAZY_SYMBOL\");\nfunction lazy(loader, meta = {}) {\n  return {\n    [LAZY_SYMBOL]: {\n      loader,\n      meta\n    }\n  };\n}\nfunction isLazy(item) {\n  return (typeof item === \"object\" || typeof item === \"function\") && item !== null && LAZY_SYMBOL in item;\n}\nfunction getLazyMeta(lazied) {\n  return lazied[LAZY_SYMBOL].meta;\n}\nfunction unlazy(lazied) {\n  return isLazy(lazied) ? lazied[LAZY_SYMBOL].loader() : Promise.resolve({ default: lazied });\n}\n\nfunction isStartWithMiddlewares(middlewares, compare) {\n  if (compare.length > middlewares.length) {\n    return false;\n  }\n  for (let i = 0; i < middlewares.length; i++) {\n    if (compare[i] === void 0) {\n      return true;\n    }\n    if (middlewares[i] !== compare[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction mergeMiddlewares(first, second, options) {\n  if (options.dedupeLeading && isStartWithMiddlewares(second, first)) {\n    return second;\n  }\n  return [...first, ...second];\n}\nfunction addMiddleware(middlewares, addition) {\n  return [...middlewares, addition];\n}\n\nclass Procedure {\n  /**\n   * This property holds the defined options.\n   */\n  \"~orpc\";\n  constructor(def) {\n    this[\"~orpc\"] = def;\n  }\n}\nfunction isProcedure(item) {\n  if (item instanceof Procedure) {\n    return true;\n  }\n  return isContractProcedure(item) && \"middlewares\" in item[\"~orpc\"] && \"inputValidationIndex\" in item[\"~orpc\"] && \"outputValidationIndex\" in item[\"~orpc\"] && \"handler\" in item[\"~orpc\"];\n}\n\nfunction mergeCurrentContext(context, other) {\n  return { ...context, ...other };\n}\n\nfunction createORPCErrorConstructorMap(errors) {\n  const proxy = new Proxy(errors, {\n    get(target, code) {\n      if (typeof code !== \"string\") {\n        return Reflect.get(target, code);\n      }\n      const item = (...rest) => {\n        const options = resolveMaybeOptionalOptions(rest);\n        const config = errors[code];\n        return new ORPCError(code, {\n          defined: Boolean(config),\n          status: config?.status,\n          message: options.message ?? config?.message,\n          data: options.data,\n          cause: options.cause\n        });\n      };\n      return item;\n    }\n  });\n  return proxy;\n}\n\nfunction middlewareOutputFn(output) {\n  return { output, context: {} };\n}\n\nfunction createProcedureClient(lazyableProcedure, ...rest) {\n  const options = resolveMaybeOptionalOptions(rest);\n  return async (...[input, callerOptions]) => {\n    const path = toArray(options.path);\n    const { default: procedure } = await unlazy(lazyableProcedure);\n    const clientContext = callerOptions?.context ?? {};\n    const context = await value(options.context ?? {}, clientContext);\n    const errors = createORPCErrorConstructorMap(procedure[\"~orpc\"].errorMap);\n    const validateError = async (e) => {\n      if (e instanceof ORPCError) {\n        return await validateORPCError(procedure[\"~orpc\"].errorMap, e);\n      }\n      return e;\n    };\n    try {\n      const output = await runWithSpan(\n        { name: \"call_procedure\", signal: callerOptions?.signal },\n        (span) => {\n          span?.setAttribute(\"procedure.path\", [...path]);\n          return intercept(\n            toArray(options.interceptors),\n            {\n              context,\n              input,\n              // input only optional when it undefinable so we can safely cast it\n              errors,\n              path,\n              procedure,\n              signal: callerOptions?.signal,\n              lastEventId: callerOptions?.lastEventId\n            },\n            (interceptorOptions) => executeProcedureInternal(interceptorOptions.procedure, interceptorOptions)\n          );\n        }\n      );\n      if (isAsyncIteratorObject(output)) {\n        if (output instanceof HibernationEventIterator) {\n          return output;\n        }\n        return overlayProxy(output, mapEventIterator(\n          asyncIteratorWithSpan(\n            { name: \"consume_event_iterator_output\", signal: callerOptions?.signal },\n            output\n          ),\n          {\n            value: (v) => v,\n            error: (e) => validateError(e)\n          }\n        ));\n      }\n      return output;\n    } catch (e) {\n      throw await validateError(e);\n    }\n  };\n}\nasync function validateInput(procedure, input) {\n  const schema = procedure[\"~orpc\"].inputSchema;\n  if (!schema) {\n    return input;\n  }\n  return runWithSpan(\n    { name: \"validate_input\" },\n    async () => {\n      const result = await schema[\"~standard\"].validate(input);\n      if (result.issues) {\n        throw new ORPCError(\"BAD_REQUEST\", {\n          message: \"Input validation failed\",\n          data: {\n            issues: result.issues\n          },\n          cause: new ValidationError({\n            message: \"Input validation failed\",\n            issues: result.issues,\n            data: input\n          })\n        });\n      }\n      return result.value;\n    }\n  );\n}\nasync function validateOutput(procedure, output) {\n  const schema = procedure[\"~orpc\"].outputSchema;\n  if (!schema) {\n    return output;\n  }\n  return runWithSpan(\n    { name: \"validate_output\" },\n    async () => {\n      const result = await schema[\"~standard\"].validate(output);\n      if (result.issues) {\n        throw new ORPCError(\"INTERNAL_SERVER_ERROR\", {\n          message: \"Output validation failed\",\n          cause: new ValidationError({\n            message: \"Output validation failed\",\n            issues: result.issues,\n            data: output\n          })\n        });\n      }\n      return result.value;\n    }\n  );\n}\nasync function executeProcedureInternal(procedure, options) {\n  const middlewares = procedure[\"~orpc\"].middlewares;\n  const inputValidationIndex = Math.min(Math.max(0, procedure[\"~orpc\"].inputValidationIndex), middlewares.length);\n  const outputValidationIndex = Math.min(Math.max(0, procedure[\"~orpc\"].outputValidationIndex), middlewares.length);\n  const next = async (index, context, input) => {\n    let currentInput = input;\n    if (index === inputValidationIndex) {\n      currentInput = await validateInput(procedure, currentInput);\n    }\n    const mid = middlewares[index];\n    const output = mid ? await runWithSpan(\n      { name: `middleware.${mid.name}`, signal: options.signal },\n      async (span) => {\n        span?.setAttribute(\"middleware.index\", index);\n        span?.setAttribute(\"middleware.name\", mid.name);\n        const result = await mid({\n          ...options,\n          context,\n          next: async (...[nextOptions]) => {\n            const nextContext = nextOptions?.context ?? {};\n            return {\n              output: await next(index + 1, mergeCurrentContext(context, nextContext), currentInput),\n              context: nextContext\n            };\n          }\n        }, currentInput, middlewareOutputFn);\n        return result.output;\n      }\n    ) : await runWithSpan(\n      { name: \"handler\", signal: options.signal },\n      () => procedure[\"~orpc\"].handler({ ...options, context, input: currentInput })\n    );\n    if (index === outputValidationIndex) {\n      return await validateOutput(procedure, output);\n    }\n    return output;\n  };\n  return next(0, options.context, options.input);\n}\n\nconst HIDDEN_ROUTER_CONTRACT_SYMBOL = Symbol(\"ORPC_HIDDEN_ROUTER_CONTRACT\");\nfunction setHiddenRouterContract(router, contract) {\n  return new Proxy(router, {\n    get(target, key) {\n      if (key === HIDDEN_ROUTER_CONTRACT_SYMBOL) {\n        return contract;\n      }\n      return Reflect.get(target, key);\n    }\n  });\n}\nfunction getHiddenRouterContract(router) {\n  return router[HIDDEN_ROUTER_CONTRACT_SYMBOL];\n}\n\nfunction getRouter(router, path) {\n  let current = router;\n  for (let i = 0; i < path.length; i++) {\n    const segment = path[i];\n    if (!current) {\n      return void 0;\n    }\n    if (isProcedure(current)) {\n      return void 0;\n    }\n    if (!isLazy(current)) {\n      current = current[segment];\n      continue;\n    }\n    const lazied = current;\n    const rest = path.slice(i);\n    return lazy(async () => {\n      const unwrapped = await unlazy(lazied);\n      const next = getRouter(unwrapped.default, rest);\n      return unlazy(next);\n    }, getLazyMeta(lazied));\n  }\n  return current;\n}\nfunction createAccessibleLazyRouter(lazied) {\n  const recursive = new Proxy(lazied, {\n    get(target, key) {\n      if (typeof key !== \"string\") {\n        return Reflect.get(target, key);\n      }\n      const next = getRouter(lazied, [key]);\n      return createAccessibleLazyRouter(next);\n    }\n  });\n  return recursive;\n}\nfunction enhanceRouter(router, options) {\n  if (isLazy(router)) {\n    const laziedMeta = getLazyMeta(router);\n    const enhancedPrefix = laziedMeta?.prefix ? mergePrefix(options.prefix, laziedMeta?.prefix) : options.prefix;\n    const enhanced2 = lazy(async () => {\n      const { default: unlaziedRouter } = await unlazy(router);\n      const enhanced3 = enhanceRouter(unlaziedRouter, options);\n      return unlazy(enhanced3);\n    }, {\n      ...laziedMeta,\n      prefix: enhancedPrefix\n    });\n    const accessible = createAccessibleLazyRouter(enhanced2);\n    return accessible;\n  }\n  if (isProcedure(router)) {\n    const newMiddlewares = mergeMiddlewares(options.middlewares, router[\"~orpc\"].middlewares, { dedupeLeading: options.dedupeLeadingMiddlewares });\n    const newMiddlewareAdded = newMiddlewares.length - router[\"~orpc\"].middlewares.length;\n    const enhanced2 = new Procedure({\n      ...router[\"~orpc\"],\n      route: enhanceRoute(router[\"~orpc\"].route, options),\n      errorMap: mergeErrorMap(options.errorMap, router[\"~orpc\"].errorMap),\n      middlewares: newMiddlewares,\n      inputValidationIndex: router[\"~orpc\"].inputValidationIndex + newMiddlewareAdded,\n      outputValidationIndex: router[\"~orpc\"].outputValidationIndex + newMiddlewareAdded\n    });\n    return enhanced2;\n  }\n  const enhanced = {};\n  for (const key in router) {\n    enhanced[key] = enhanceRouter(router[key], options);\n  }\n  return enhanced;\n}\nfunction traverseContractProcedures(options, callback, lazyOptions = []) {\n  let currentRouter = options.router;\n  const hiddenContract = getHiddenRouterContract(options.router);\n  if (hiddenContract !== void 0) {\n    currentRouter = hiddenContract;\n  }\n  if (isLazy(currentRouter)) {\n    lazyOptions.push({\n      router: currentRouter,\n      path: options.path\n    });\n  } else if (isContractProcedure(currentRouter)) {\n    callback({\n      contract: currentRouter,\n      path: options.path\n    });\n  } else {\n    for (const key in currentRouter) {\n      traverseContractProcedures(\n        {\n          router: currentRouter[key],\n          path: [...options.path, key]\n        },\n        callback,\n        lazyOptions\n      );\n    }\n  }\n  return lazyOptions;\n}\nasync function resolveContractProcedures(options, callback) {\n  const pending = [options];\n  for (const options2 of pending) {\n    const lazyOptions = traverseContractProcedures(options2, callback);\n    for (const options3 of lazyOptions) {\n      const { default: router } = await unlazy(options3.router);\n      pending.push({\n        router,\n        path: options3.path\n      });\n    }\n  }\n}\nasync function unlazyRouter(router) {\n  if (isProcedure(router)) {\n    return router;\n  }\n  const unlazied = {};\n  for (const key in router) {\n    const item = router[key];\n    const { default: unlaziedRouter } = await unlazy(item);\n    unlazied[key] = await unlazyRouter(unlaziedRouter);\n  }\n  return unlazied;\n}\n\nfunction createAssertedLazyProcedure(lazied) {\n  const lazyProcedure = lazy(async () => {\n    const { default: maybeProcedure } = await unlazy(lazied);\n    if (!isProcedure(maybeProcedure)) {\n      throw new Error(`\n            Expected a lazy<procedure> but got lazy<unknown>.\n            This should be caught by TypeScript compilation.\n            Please report this issue if this makes you feel uncomfortable.\n        `);\n    }\n    return { default: maybeProcedure };\n  }, getLazyMeta(lazied));\n  return lazyProcedure;\n}\nfunction createContractedProcedure(procedure, contract) {\n  return new Procedure({\n    ...procedure[\"~orpc\"],\n    errorMap: contract[\"~orpc\"].errorMap,\n    route: contract[\"~orpc\"].route,\n    meta: contract[\"~orpc\"].meta\n  });\n}\nfunction call(procedure, input, ...rest) {\n  const options = resolveMaybeOptionalOptions(rest);\n  return createProcedureClient(procedure, options)(input, options);\n}\n\nexport { LAZY_SYMBOL as L, Procedure as P, createContractedProcedure as a, addMiddleware as b, createProcedureClient as c, isLazy as d, enhanceRouter as e, createAssertedLazyProcedure as f, getRouter as g, createORPCErrorConstructorMap as h, isProcedure as i, getLazyMeta as j, middlewareOutputFn as k, lazy as l, mergeCurrentContext as m, isStartWithMiddlewares as n, mergeMiddlewares as o, call as p, getHiddenRouterContract as q, createAccessibleLazyRouter as r, setHiddenRouterContract as s, traverseContractProcedures as t, unlazy as u, resolveContractProcedures as v, unlazyRouter as w };\n","import { toArray, runWithSpan, ORPC_NAME, isAsyncIteratorObject, asyncIteratorWithSpan, intercept, getGlobalOtelConfig, isObject, value, stringifyJSON } from '@orpc/shared';\nimport { mergeStandardHeaders, ErrorEvent } from '@orpc/standard-server';\nimport { C as COMMON_ORPC_ERROR_DEFS, d as isORPCErrorStatus, e as isORPCErrorJson, g as createORPCErrorFromJson, c as ORPCError, t as toORPCError } from './client.BF1R3smX.mjs';\nimport { toStandardHeaders as toStandardHeaders$1 } from '@orpc/standard-server-fetch';\nimport { m as mapEventIterator } from './client.BLtwTQUg.mjs';\n\nclass CompositeStandardLinkPlugin {\n  plugins;\n  constructor(plugins = []) {\n    this.plugins = [...plugins].sort((a, b) => (a.order ?? 0) - (b.order ?? 0));\n  }\n  init(options) {\n    for (const plugin of this.plugins) {\n      plugin.init?.(options);\n    }\n  }\n}\n\nclass StandardLink {\n  constructor(codec, sender, options = {}) {\n    this.codec = codec;\n    this.sender = sender;\n    const plugin = new CompositeStandardLinkPlugin(options.plugins);\n    plugin.init(options);\n    this.interceptors = toArray(options.interceptors);\n    this.clientInterceptors = toArray(options.clientInterceptors);\n  }\n  interceptors;\n  clientInterceptors;\n  call(path, input, options) {\n    return runWithSpan(\n      { name: `${ORPC_NAME}.${path.join(\"/\")}`, signal: options.signal },\n      (span) => {\n        span?.setAttribute(\"rpc.system\", ORPC_NAME);\n        span?.setAttribute(\"rpc.method\", path.join(\".\"));\n        if (isAsyncIteratorObject(input)) {\n          input = asyncIteratorWithSpan(\n            { name: \"consume_event_iterator_input\", signal: options.signal },\n            input\n          );\n        }\n        return intercept(this.interceptors, { ...options, path, input }, async ({ path: path2, input: input2, ...options2 }) => {\n          const otelConfig = getGlobalOtelConfig();\n          let otelContext;\n          const currentSpan = otelConfig?.trace.getActiveSpan() ?? span;\n          if (currentSpan && otelConfig) {\n            otelContext = otelConfig?.trace.setSpan(otelConfig.context.active(), currentSpan);\n          }\n          const request = await runWithSpan(\n            { name: \"encode_request\", context: otelContext },\n            () => this.codec.encode(path2, input2, options2)\n          );\n          const response = await intercept(\n            this.clientInterceptors,\n            { ...options2, input: input2, path: path2, request },\n            ({ input: input3, path: path3, request: request2, ...options3 }) => {\n              return runWithSpan(\n                { name: \"send_request\", signal: options3.signal, context: otelContext },\n                () => this.sender.call(request2, options3, path3, input3)\n              );\n            }\n          );\n          const output = await runWithSpan(\n            { name: \"decode_response\", context: otelContext },\n            () => this.codec.decode(response, options2, path2, input2)\n          );\n          if (isAsyncIteratorObject(output)) {\n            return asyncIteratorWithSpan(\n              { name: \"consume_event_iterator_output\", signal: options2.signal },\n              output\n            );\n          }\n          return output;\n        });\n      }\n    );\n  }\n}\n\nconst STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES = {\n  BIGINT: 0,\n  DATE: 1,\n  NAN: 2,\n  UNDEFINED: 3,\n  URL: 4,\n  REGEXP: 5,\n  SET: 6,\n  MAP: 7\n};\nclass StandardRPCJsonSerializer {\n  customSerializers;\n  constructor(options = {}) {\n    this.customSerializers = options.customJsonSerializers ?? [];\n    if (this.customSerializers.length !== new Set(this.customSerializers.map((custom) => custom.type)).size) {\n      throw new Error(\"Custom serializer type must be unique.\");\n    }\n  }\n  serialize(data, segments = [], meta = [], maps = [], blobs = []) {\n    for (const custom of this.customSerializers) {\n      if (custom.condition(data)) {\n        const result = this.serialize(custom.serialize(data), segments, meta, maps, blobs);\n        meta.push([custom.type, ...segments]);\n        return result;\n      }\n    }\n    if (data instanceof Blob) {\n      maps.push(segments);\n      blobs.push(data);\n      return [data, meta, maps, blobs];\n    }\n    if (typeof data === \"bigint\") {\n      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.BIGINT, ...segments]);\n      return [data.toString(), meta, maps, blobs];\n    }\n    if (data instanceof Date) {\n      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.DATE, ...segments]);\n      if (Number.isNaN(data.getTime())) {\n        return [null, meta, maps, blobs];\n      }\n      return [data.toISOString(), meta, maps, blobs];\n    }\n    if (Number.isNaN(data)) {\n      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.NAN, ...segments]);\n      return [null, meta, maps, blobs];\n    }\n    if (data instanceof URL) {\n      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.URL, ...segments]);\n      return [data.toString(), meta, maps, blobs];\n    }\n    if (data instanceof RegExp) {\n      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.REGEXP, ...segments]);\n      return [data.toString(), meta, maps, blobs];\n    }\n    if (data instanceof Set) {\n      const result = this.serialize(Array.from(data), segments, meta, maps, blobs);\n      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.SET, ...segments]);\n      return result;\n    }\n    if (data instanceof Map) {\n      const result = this.serialize(Array.from(data.entries()), segments, meta, maps, blobs);\n      meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.MAP, ...segments]);\n      return result;\n    }\n    if (Array.isArray(data)) {\n      const json = data.map((v, i) => {\n        if (v === void 0) {\n          meta.push([STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.UNDEFINED, ...segments, i]);\n          return v;\n        }\n        return this.serialize(v, [...segments, i], meta, maps, blobs)[0];\n      });\n      return [json, meta, maps, blobs];\n    }\n    if (isObject(data)) {\n      const json = {};\n      for (const k in data) {\n        if (k === \"toJSON\" && typeof data[k] === \"function\") {\n          continue;\n        }\n        json[k] = this.serialize(data[k], [...segments, k], meta, maps, blobs)[0];\n      }\n      return [json, meta, maps, blobs];\n    }\n    return [data, meta, maps, blobs];\n  }\n  deserialize(json, meta, maps, getBlob) {\n    const ref = { data: json };\n    if (maps && getBlob) {\n      maps.forEach((segments, i) => {\n        let currentRef = ref;\n        let preSegment = \"data\";\n        segments.forEach((segment) => {\n          currentRef = currentRef[preSegment];\n          preSegment = segment;\n        });\n        currentRef[preSegment] = getBlob(i);\n      });\n    }\n    for (const item of meta) {\n      const type = item[0];\n      let currentRef = ref;\n      let preSegment = \"data\";\n      for (let i = 1; i < item.length; i++) {\n        currentRef = currentRef[preSegment];\n        preSegment = item[i];\n      }\n      for (const custom of this.customSerializers) {\n        if (custom.type === type) {\n          currentRef[preSegment] = custom.deserialize(currentRef[preSegment]);\n          break;\n        }\n      }\n      switch (type) {\n        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.BIGINT:\n          currentRef[preSegment] = BigInt(currentRef[preSegment]);\n          break;\n        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.DATE:\n          currentRef[preSegment] = new Date(currentRef[preSegment] ?? \"Invalid Date\");\n          break;\n        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.NAN:\n          currentRef[preSegment] = Number.NaN;\n          break;\n        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.UNDEFINED:\n          currentRef[preSegment] = void 0;\n          break;\n        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.URL:\n          currentRef[preSegment] = new URL(currentRef[preSegment]);\n          break;\n        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.REGEXP: {\n          const [, pattern, flags] = currentRef[preSegment].match(/^\\/(.*)\\/([a-z]*)$/);\n          currentRef[preSegment] = new RegExp(pattern, flags);\n          break;\n        }\n        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.SET:\n          currentRef[preSegment] = new Set(currentRef[preSegment]);\n          break;\n        case STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES.MAP:\n          currentRef[preSegment] = new Map(currentRef[preSegment]);\n          break;\n      }\n    }\n    return ref.data;\n  }\n}\n\nfunction toHttpPath(path) {\n  return `/${path.map(encodeURIComponent).join(\"/\")}`;\n}\nfunction toStandardHeaders(headers) {\n  if (typeof headers.forEach === \"function\") {\n    return toStandardHeaders$1(headers);\n  }\n  return headers;\n}\nfunction getMalformedResponseErrorCode(status) {\n  return Object.entries(COMMON_ORPC_ERROR_DEFS).find(([, def]) => def.status === status)?.[0] ?? \"MALFORMED_ORPC_ERROR_RESPONSE\";\n}\n\nclass StandardRPCLinkCodec {\n  constructor(serializer, options) {\n    this.serializer = serializer;\n    this.baseUrl = options.url;\n    this.maxUrlLength = options.maxUrlLength ?? 2083;\n    this.fallbackMethod = options.fallbackMethod ?? \"POST\";\n    this.expectedMethod = options.method ?? this.fallbackMethod;\n    this.headers = options.headers ?? {};\n  }\n  baseUrl;\n  maxUrlLength;\n  fallbackMethod;\n  expectedMethod;\n  headers;\n  async encode(path, input, options) {\n    let headers = toStandardHeaders(await value(this.headers, options, path, input));\n    if (options.lastEventId !== void 0) {\n      headers = mergeStandardHeaders(headers, { \"last-event-id\": options.lastEventId });\n    }\n    const expectedMethod = await value(this.expectedMethod, options, path, input);\n    const baseUrl = await value(this.baseUrl, options, path, input);\n    const url = new URL(baseUrl);\n    url.pathname = `${url.pathname.replace(/\\/$/, \"\")}${toHttpPath(path)}`;\n    const serialized = this.serializer.serialize(input);\n    if (expectedMethod === \"GET\" && !(serialized instanceof FormData) && !isAsyncIteratorObject(serialized)) {\n      const maxUrlLength = await value(this.maxUrlLength, options, path, input);\n      const getUrl = new URL(url);\n      getUrl.searchParams.append(\"data\", stringifyJSON(serialized));\n      if (getUrl.toString().length <= maxUrlLength) {\n        return {\n          body: void 0,\n          method: expectedMethod,\n          headers,\n          url: getUrl,\n          signal: options.signal\n        };\n      }\n    }\n    return {\n      url,\n      method: expectedMethod === \"GET\" ? this.fallbackMethod : expectedMethod,\n      headers,\n      body: serialized,\n      signal: options.signal\n    };\n  }\n  async decode(response) {\n    const isOk = !isORPCErrorStatus(response.status);\n    const deserialized = await (async () => {\n      let isBodyOk = false;\n      try {\n        const body = await response.body();\n        isBodyOk = true;\n        return this.serializer.deserialize(body);\n      } catch (error) {\n        if (!isBodyOk) {\n          throw new Error(\"Cannot parse response body, please check the response body and content-type.\", {\n            cause: error\n          });\n        }\n        throw new Error(\"Invalid RPC response format.\", {\n          cause: error\n        });\n      }\n    })();\n    if (!isOk) {\n      if (isORPCErrorJson(deserialized)) {\n        throw createORPCErrorFromJson(deserialized);\n      }\n      throw new ORPCError(getMalformedResponseErrorCode(response.status), {\n        status: response.status,\n        data: { ...response, body: deserialized }\n      });\n    }\n    return deserialized;\n  }\n}\n\nclass StandardRPCSerializer {\n  constructor(jsonSerializer) {\n    this.jsonSerializer = jsonSerializer;\n  }\n  serialize(data) {\n    if (isAsyncIteratorObject(data)) {\n      return mapEventIterator(data, {\n        value: async (value) => this.#serialize(value, false),\n        error: async (e) => {\n          return new ErrorEvent({\n            data: this.#serialize(toORPCError(e).toJSON(), false),\n            cause: e\n          });\n        }\n      });\n    }\n    return this.#serialize(data, true);\n  }\n  #serialize(data, enableFormData) {\n    const [json, meta_, maps, blobs] = this.jsonSerializer.serialize(data);\n    const meta = meta_.length === 0 ? void 0 : meta_;\n    if (!enableFormData || blobs.length === 0) {\n      return {\n        json,\n        meta\n      };\n    }\n    const form = new FormData();\n    form.set(\"data\", stringifyJSON({ json, meta, maps }));\n    blobs.forEach((blob, i) => {\n      form.set(i.toString(), blob);\n    });\n    return form;\n  }\n  deserialize(data) {\n    if (isAsyncIteratorObject(data)) {\n      return mapEventIterator(data, {\n        value: async (value) => this.#deserialize(value),\n        error: async (e) => {\n          if (!(e instanceof ErrorEvent)) {\n            return e;\n          }\n          const deserialized = this.#deserialize(e.data);\n          if (isORPCErrorJson(deserialized)) {\n            return createORPCErrorFromJson(deserialized, { cause: e });\n          }\n          return new ErrorEvent({\n            data: deserialized,\n            cause: e\n          });\n        }\n      });\n    }\n    return this.#deserialize(data);\n  }\n  #deserialize(data) {\n    if (data === void 0) {\n      return void 0;\n    }\n    if (!(data instanceof FormData)) {\n      return this.jsonSerializer.deserialize(data.json, data.meta ?? []);\n    }\n    const serialized = JSON.parse(data.get(\"data\"));\n    return this.jsonSerializer.deserialize(\n      serialized.json,\n      serialized.meta ?? [],\n      serialized.maps,\n      (i) => data.get(i.toString())\n    );\n  }\n}\n\nclass StandardRPCLink extends StandardLink {\n  constructor(linkClient, options) {\n    const jsonSerializer = new StandardRPCJsonSerializer(options);\n    const serializer = new StandardRPCSerializer(jsonSerializer);\n    const linkCodec = new StandardRPCLinkCodec(serializer, options);\n    super(linkCodec, linkClient, options);\n  }\n}\n\nexport { CompositeStandardLinkPlugin as C, StandardLink as S, STANDARD_RPC_JSON_SERIALIZER_BUILT_IN_TYPES as a, StandardRPCJsonSerializer as b, StandardRPCLink as c, StandardRPCLinkCodec as d, StandardRPCSerializer as e, toStandardHeaders as f, getMalformedResponseErrorCode as g, toHttpPath as t };\n","import { toHttpPath, StandardRPCJsonSerializer, StandardRPCSerializer } from '@orpc/client/standard';\nimport { ORPCError, toORPCError } from '@orpc/client';\nimport { toArray, intercept, runWithSpan, ORPC_NAME, isAsyncIteratorObject, asyncIteratorWithSpan, setSpanError, parseEmptyableJSON, NullProtoObj, value } from '@orpc/shared';\nimport { flattenHeader } from '@orpc/standard-server';\nimport { c as createProcedureClient, t as traverseContractProcedures, i as isProcedure, u as unlazy, g as getRouter, a as createContractedProcedure } from './server.Ds4HPpvH.mjs';\n\nclass CompositeStandardHandlerPlugin {\n  plugins;\n  constructor(plugins = []) {\n    this.plugins = [...plugins].sort((a, b) => (a.order ?? 0) - (b.order ?? 0));\n  }\n  init(options, router) {\n    for (const plugin of this.plugins) {\n      plugin.init?.(options, router);\n    }\n  }\n}\n\nclass StandardHandler {\n  constructor(router, matcher, codec, options) {\n    this.matcher = matcher;\n    this.codec = codec;\n    const plugins = new CompositeStandardHandlerPlugin(options.plugins);\n    plugins.init(options, router);\n    this.interceptors = toArray(options.interceptors);\n    this.clientInterceptors = toArray(options.clientInterceptors);\n    this.rootInterceptors = toArray(options.rootInterceptors);\n    this.matcher.init(router);\n  }\n  interceptors;\n  clientInterceptors;\n  rootInterceptors;\n  async handle(request, options) {\n    const prefix = options.prefix?.replace(/\\/$/, \"\") || void 0;\n    if (prefix && !request.url.pathname.startsWith(`${prefix}/`) && request.url.pathname !== prefix) {\n      return { matched: false, response: void 0 };\n    }\n    return intercept(\n      this.rootInterceptors,\n      { ...options, request, prefix },\n      async (interceptorOptions) => {\n        return runWithSpan(\n          { name: `${request.method} ${request.url.pathname}` },\n          async (span) => {\n            let step;\n            try {\n              return await intercept(\n                this.interceptors,\n                interceptorOptions,\n                async ({ request: request2, context, prefix: prefix2 }) => {\n                  const method = request2.method;\n                  const url = request2.url;\n                  const pathname = prefix2 ? url.pathname.replace(prefix2, \"\") : url.pathname;\n                  const match = await runWithSpan(\n                    { name: \"find_procedure\" },\n                    () => this.matcher.match(method, `/${pathname.replace(/^\\/|\\/$/g, \"\")}`)\n                  );\n                  if (!match) {\n                    return { matched: false, response: void 0 };\n                  }\n                  span?.updateName(`${ORPC_NAME}.${match.path.join(\"/\")}`);\n                  span?.setAttribute(\"rpc.system\", ORPC_NAME);\n                  span?.setAttribute(\"rpc.method\", match.path.join(\".\"));\n                  step = \"decode_input\";\n                  let input = await runWithSpan(\n                    { name: \"decode_input\" },\n                    () => this.codec.decode(request2, match.params, match.procedure)\n                  );\n                  step = void 0;\n                  if (isAsyncIteratorObject(input)) {\n                    input = asyncIteratorWithSpan(\n                      { name: \"consume_event_iterator_input\", signal: request2.signal },\n                      input\n                    );\n                  }\n                  const client = createProcedureClient(match.procedure, {\n                    context,\n                    path: match.path,\n                    interceptors: this.clientInterceptors\n                  });\n                  step = \"call_procedure\";\n                  const output = await client(input, {\n                    signal: request2.signal,\n                    lastEventId: flattenHeader(request2.headers[\"last-event-id\"])\n                  });\n                  step = void 0;\n                  const response = this.codec.encode(output, match.procedure);\n                  return {\n                    matched: true,\n                    response\n                  };\n                }\n              );\n            } catch (e) {\n              if (step !== \"call_procedure\") {\n                setSpanError(span, e);\n              }\n              const error = step === \"decode_input\" && !(e instanceof ORPCError) ? new ORPCError(\"BAD_REQUEST\", {\n                message: `Malformed request. Ensure the request body is properly formatted and the 'Content-Type' header is set correctly.`,\n                cause: e\n              }) : toORPCError(e);\n              const response = this.codec.encodeError(error);\n              return {\n                matched: true,\n                response\n              };\n            }\n          }\n        );\n      }\n    );\n  }\n}\n\nclass StandardRPCCodec {\n  constructor(serializer) {\n    this.serializer = serializer;\n  }\n  async decode(request, _params, _procedure) {\n    const serialized = request.method === \"GET\" ? parseEmptyableJSON(request.url.searchParams.getAll(\"data\").at(-1)) : await request.body();\n    return this.serializer.deserialize(serialized);\n  }\n  encode(output, _procedure) {\n    return {\n      status: 200,\n      headers: {},\n      body: this.serializer.serialize(output)\n    };\n  }\n  encodeError(error) {\n    return {\n      status: error.status,\n      headers: {},\n      body: this.serializer.serialize(error.toJSON())\n    };\n  }\n}\n\nclass StandardRPCMatcher {\n  filter;\n  tree = new NullProtoObj();\n  pendingRouters = [];\n  constructor(options = {}) {\n    this.filter = options.filter ?? true;\n  }\n  init(router, path = []) {\n    const laziedOptions = traverseContractProcedures({ router, path }, (traverseOptions) => {\n      if (!value(this.filter, traverseOptions)) {\n        return;\n      }\n      const { path: path2, contract } = traverseOptions;\n      const httpPath = toHttpPath(path2);\n      if (isProcedure(contract)) {\n        this.tree[httpPath] = {\n          path: path2,\n          contract,\n          procedure: contract,\n          // this mean dev not used contract-first so we can used contract as procedure directly\n          router\n        };\n      } else {\n        this.tree[httpPath] = {\n          path: path2,\n          contract,\n          procedure: void 0,\n          router\n        };\n      }\n    });\n    this.pendingRouters.push(...laziedOptions.map((option) => ({\n      ...option,\n      httpPathPrefix: toHttpPath(option.path)\n    })));\n  }\n  async match(_method, pathname) {\n    if (this.pendingRouters.length) {\n      const newPendingRouters = [];\n      for (const pendingRouter of this.pendingRouters) {\n        if (pathname.startsWith(pendingRouter.httpPathPrefix)) {\n          const { default: router } = await unlazy(pendingRouter.router);\n          this.init(router, pendingRouter.path);\n        } else {\n          newPendingRouters.push(pendingRouter);\n        }\n      }\n      this.pendingRouters = newPendingRouters;\n    }\n    const match = this.tree[pathname];\n    if (!match) {\n      return void 0;\n    }\n    if (!match.procedure) {\n      const { default: maybeProcedure } = await unlazy(getRouter(match.router, match.path));\n      if (!isProcedure(maybeProcedure)) {\n        throw new Error(`\n          [Contract-First] Missing or invalid implementation for procedure at path: ${toHttpPath(match.path)}.\n          Ensure that the procedure is correctly defined and matches the expected contract.\n        `);\n      }\n      match.procedure = createContractedProcedure(maybeProcedure, match.contract);\n    }\n    return {\n      path: match.path,\n      procedure: match.procedure\n    };\n  }\n}\n\nclass StandardRPCHandler extends StandardHandler {\n  constructor(router, options = {}) {\n    const jsonSerializer = new StandardRPCJsonSerializer(options);\n    const serializer = new StandardRPCSerializer(jsonSerializer);\n    const matcher = new StandardRPCMatcher(options);\n    const codec = new StandardRPCCodec(serializer);\n    super(router, matcher, codec, options);\n  }\n}\n\nexport { CompositeStandardHandlerPlugin as C, StandardHandler as S, StandardRPCCodec as a, StandardRPCHandler as b, StandardRPCMatcher as c };\n","import { onError } from \"@orpc/server\";\nimport { RPCHandler } from \"@orpc/server/fetch\";\n\nimport { createContext } from \"@/lib/api/context\";\nimport { appRouter } from \"@/lib/api/routers\";\n\nconst rpcHandler = new RPCHandler(appRouter, {\n  interceptors: [\n    onError((error) => {\n      console.error(error);\n    }),\n  ],\n});\n\nexport async function GET(request: Request) {\n  try {\n    const context = await createContext({ request });\n    const { response } = await rpcHandler.handle(request, {\n      prefix: \"/api/rpc\",\n      context,\n    });\n    return response ?? new Response(\"Not Found\", { status: 404 });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    console.error(\"[api/rpc] GET error:\", err);\n    return Response.json(\n      { error: { code: \"INTERNAL_SERVER_ERROR\", message } },\n      { status: 500 },\n    );\n  }\n}\n\nexport async function POST(request: Request) {\n  try {\n    const context = await createContext({ request });\n    const { response } = await rpcHandler.handle(request, {\n      prefix: \"/api/rpc\",\n      context,\n    });\n    return response ?? new Response(\"Not Found\", { status: 404 });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    console.error(\"[api/rpc] POST error:\", err);\n    return Response.json(\n      { error: { code: \"INTERNAL_SERVER_ERROR\", message } },\n      { status: 500 },\n    );\n  }\n}\n","import { preventNativeAwait, isTypescriptObject } from '@orpc/shared';\nexport { AsyncIteratorClass, EventPublisher, asyncIteratorToStream as eventIteratorToStream, asyncIteratorToUnproxiedDataStream as eventIteratorToUnproxiedDataStream, onError, onFinish, onStart, onSuccess, streamToAsyncIteratorClass as streamToEventIterator } from '@orpc/shared';\nimport { i as isDefinedError } from './shared/client.BF1R3smX.mjs';\nexport { C as COMMON_ORPC_ERROR_DEFS, c as ORPCError, O as ORPC_CLIENT_PACKAGE_NAME, a as ORPC_CLIENT_PACKAGE_VERSION, g as createORPCErrorFromJson, b as fallbackORPCErrorMessage, f as fallbackORPCErrorStatus, e as isORPCErrorJson, d as isORPCErrorStatus, t as toORPCError } from './shared/client.BF1R3smX.mjs';\nexport { m as mapEventIterator } from './shared/client.BLtwTQUg.mjs';\nexport { ErrorEvent } from '@orpc/standard-server';\n\nasync function safe(promise) {\n  try {\n    const output = await promise;\n    return Object.assign(\n      [null, output, false, true],\n      { error: null, data: output, isDefined: false, isSuccess: true }\n    );\n  } catch (e) {\n    const error = e;\n    if (isDefinedError(error)) {\n      return Object.assign(\n        [error, void 0, true, false],\n        { error, data: void 0, isDefined: true, isSuccess: false }\n      );\n    }\n    return Object.assign(\n      [error, void 0, false, false],\n      { error, data: void 0, isDefined: false, isSuccess: false }\n    );\n  }\n}\nfunction resolveFriendlyClientOptions(options) {\n  return {\n    ...options,\n    context: options.context ?? {}\n    // Context only optional if all fields are optional\n  };\n}\nfunction consumeEventIterator(iterator, options) {\n  void (async () => {\n    let onFinishState;\n    try {\n      const resolvedIterator = await iterator;\n      while (true) {\n        const { done, value } = await resolvedIterator.next();\n        if (done) {\n          const realValue = value;\n          onFinishState = [null, realValue, true];\n          options.onSuccess?.(realValue);\n          break;\n        }\n        options.onEvent(value);\n      }\n    } catch (error) {\n      onFinishState = [error, void 0, false];\n      if (!options.onError && !options.onFinish) {\n        throw error;\n      }\n      options.onError?.(error);\n    } finally {\n      options.onFinish?.(onFinishState);\n    }\n  })();\n  return async () => {\n    await (await iterator)?.return?.();\n  };\n}\n\nfunction createORPCClient(link, options = {}) {\n  const path = options.path ?? [];\n  const procedureClient = async (...[input, options2 = {}]) => {\n    return await link.call(path, input, resolveFriendlyClientOptions(options2));\n  };\n  const recursive = new Proxy(procedureClient, {\n    get(target, key) {\n      if (typeof key !== \"string\") {\n        return Reflect.get(target, key);\n      }\n      return createORPCClient(link, {\n        ...options,\n        path: [...path, key]\n      });\n    }\n  });\n  return preventNativeAwait(recursive);\n}\n\nfunction createSafeClient(client) {\n  const proxy = new Proxy((...args) => safe(client(...args)), {\n    get(_, prop, receiver) {\n      const value = Reflect.get(client, prop, receiver);\n      if (typeof prop !== \"string\") {\n        return value;\n      }\n      if (!isTypescriptObject(value)) {\n        return value;\n      }\n      return createSafeClient(value);\n    }\n  });\n  return proxy;\n}\n\nclass DynamicLink {\n  constructor(linkResolver) {\n    this.linkResolver = linkResolver;\n  }\n  async call(path, input, options) {\n    const resolvedLink = await this.linkResolver(options, path, input);\n    const output = await resolvedLink.call(path, input, options);\n    return output;\n  }\n}\n\nexport { DynamicLink, consumeEventIterator, createORPCClient, createSafeClient, isDefinedError, resolveFriendlyClientOptions, safe };\n","import type { RouterClient } from \"@orpc/server\";\n\nimport { protectedProcedure, publicProcedure } from \"../index\";\n\nimport { projectRouter } from \"./project\";\nimport { settingRouter } from \"./setting\";\n\nexport const appRouter = {\n  healthCheck: publicProcedure.handler(() => {\n    return \"OK\";\n  }),\n  privateData: protectedProcedure.handler(({ context }) => {\n    return {\n      message: \"This is private\",\n      user: context.session?.user,\n    };\n  }),\n  project: projectRouter,\n  setting: settingRouter,\n};\nexport type AppRouter = typeof appRouter;\nexport type AppRouterClient = RouterClient<typeof appRouter>;\n","import { i as isContractProcedure, C as ContractProcedure, m as mergeErrorMap, V as ValidationError } from './shared/contract.D_dZrO__.mjs';\nexport { v as validateORPCError } from './shared/contract.D_dZrO__.mjs';\nimport { toHttpPath } from '@orpc/client/standard';\nimport { toArray, isAsyncIteratorObject, get, isTypescriptObject, isPropertyKey } from '@orpc/shared';\nexport { AsyncIteratorClass } from '@orpc/shared';\nimport { mapEventIterator, ORPCError } from '@orpc/client';\nexport { ORPCError } from '@orpc/client';\n\nfunction mergeMeta(meta1, meta2) {\n  return { ...meta1, ...meta2 };\n}\n\nfunction mergeRoute(a, b) {\n  return { ...a, ...b };\n}\nfunction prefixRoute(route, prefix) {\n  if (!route.path) {\n    return route;\n  }\n  return {\n    ...route,\n    path: `${prefix}${route.path}`\n  };\n}\nfunction unshiftTagRoute(route, tags) {\n  return {\n    ...route,\n    tags: [...tags, ...route.tags ?? []]\n  };\n}\nfunction mergePrefix(a, b) {\n  return a ? `${a}${b}` : b;\n}\nfunction mergeTags(a, b) {\n  return a ? [...a, ...b] : b;\n}\nfunction enhanceRoute(route, options) {\n  let router = route;\n  if (options.prefix) {\n    router = prefixRoute(router, options.prefix);\n  }\n  if (options.tags?.length) {\n    router = unshiftTagRoute(router, options.tags);\n  }\n  return router;\n}\n\nfunction getContractRouter(router, path) {\n  let current = router;\n  for (let i = 0; i < path.length; i++) {\n    const segment = path[i];\n    if (!current) {\n      return void 0;\n    }\n    if (isContractProcedure(current)) {\n      return void 0;\n    }\n    current = current[segment];\n  }\n  return current;\n}\nfunction enhanceContractRouter(router, options) {\n  if (isContractProcedure(router)) {\n    const enhanced2 = new ContractProcedure({\n      ...router[\"~orpc\"],\n      errorMap: mergeErrorMap(options.errorMap, router[\"~orpc\"].errorMap),\n      route: enhanceRoute(router[\"~orpc\"].route, options)\n    });\n    return enhanced2;\n  }\n  const enhanced = {};\n  for (const key in router) {\n    enhanced[key] = enhanceContractRouter(router[key], options);\n  }\n  return enhanced;\n}\nfunction minifyContractRouter(router) {\n  if (isContractProcedure(router)) {\n    const procedure = {\n      \"~orpc\": {\n        errorMap: {},\n        meta: router[\"~orpc\"].meta,\n        route: router[\"~orpc\"].route\n      }\n    };\n    return procedure;\n  }\n  const json = {};\n  for (const key in router) {\n    json[key] = minifyContractRouter(router[key]);\n  }\n  return json;\n}\nfunction populateContractRouterPaths(router, options = {}) {\n  const path = toArray(options.path);\n  if (isContractProcedure(router)) {\n    if (router[\"~orpc\"].route.path === void 0) {\n      return new ContractProcedure({\n        ...router[\"~orpc\"],\n        route: {\n          ...router[\"~orpc\"].route,\n          path: toHttpPath(path)\n        }\n      });\n    }\n    return router;\n  }\n  const populated = {};\n  for (const key in router) {\n    populated[key] = populateContractRouterPaths(router[key], { ...options, path: [...path, key] });\n  }\n  return populated;\n}\n\nclass ContractBuilder extends ContractProcedure {\n  constructor(def) {\n    super(def);\n    this[\"~orpc\"].prefix = def.prefix;\n    this[\"~orpc\"].tags = def.tags;\n  }\n  /**\n   * Sets or overrides the initial meta.\n   *\n   * @see {@link https://orpc.dev/docs/metadata Metadata Docs}\n   */\n  $meta(initialMeta) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      meta: initialMeta\n    });\n  }\n  /**\n   * Sets or overrides the initial route.\n   * This option is typically relevant when integrating with OpenAPI.\n   *\n   * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}\n   * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}\n   */\n  $route(initialRoute) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      route: initialRoute\n    });\n  }\n  /**\n   * Sets or overrides the initial input schema.\n   *\n   * @see {@link https://orpc.dev/docs/procedure#initial-configuration Initial Procedure Configuration Docs}\n   */\n  $input(initialInputSchema) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      inputSchema: initialInputSchema\n    });\n  }\n  /**\n   * Adds type-safe custom errors to the contract.\n   * The provided errors are spared-merged with any existing errors in the contract.\n   *\n   * @see {@link https://orpc.dev/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}\n   */\n  errors(errors) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      errorMap: mergeErrorMap(this[\"~orpc\"].errorMap, errors)\n    });\n  }\n  /**\n   * Sets or updates the metadata for the contract.\n   * The provided metadata is spared-merged with any existing metadata in the contract.\n   *\n   * @see {@link https://orpc.dev/docs/metadata Metadata Docs}\n   */\n  meta(meta) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      meta: mergeMeta(this[\"~orpc\"].meta, meta)\n    });\n  }\n  /**\n   * Sets or updates the route definition for the contract.\n   * The provided route is spared-merged with any existing route in the contract.\n   * This option is typically relevant when integrating with OpenAPI.\n   *\n   * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}\n   * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}\n   */\n  route(route) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      route: mergeRoute(this[\"~orpc\"].route, route)\n    });\n  }\n  /**\n   * Defines the input validation schema for the contract.\n   *\n   * @see {@link https://orpc.dev/docs/procedure#input-output-validation Input Validation Docs}\n   */\n  input(schema) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      inputSchema: schema\n    });\n  }\n  /**\n   * Defines the output validation schema for the contract.\n   *\n   * @see {@link https://orpc.dev/docs/procedure#input-output-validation Output Validation Docs}\n   */\n  output(schema) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      outputSchema: schema\n    });\n  }\n  /**\n   * Prefixes all procedures in the contract router.\n   * The provided prefix is post-appended to any existing router prefix.\n   *\n   * @note This option does not affect procedures that do not define a path in their route definition.\n   *\n   * @see {@link https://orpc.dev/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}\n   */\n  prefix(prefix) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      prefix: mergePrefix(this[\"~orpc\"].prefix, prefix)\n    });\n  }\n  /**\n   * Adds tags to all procedures in the contract router.\n   * This helpful when you want to group procedures together in the OpenAPI specification.\n   *\n   * @see {@link https://orpc.dev/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}\n   */\n  tag(...tags) {\n    return new ContractBuilder({\n      ...this[\"~orpc\"],\n      tags: mergeTags(this[\"~orpc\"].tags, tags)\n    });\n  }\n  /**\n   * Applies all of the previously defined options to the specified contract router.\n   *\n   * @see {@link https://orpc.dev/docs/router#extending-router Extending Router Docs}\n   */\n  router(router) {\n    return enhanceContractRouter(router, this[\"~orpc\"]);\n  }\n}\nconst oc = new ContractBuilder({\n  errorMap: {},\n  route: {},\n  meta: {}\n});\n\nconst DEFAULT_CONFIG = {\n  defaultMethod: \"POST\",\n  defaultSuccessStatus: 200,\n  defaultSuccessDescription: \"OK\",\n  defaultInputStructure: \"compact\",\n  defaultOutputStructure: \"compact\"\n};\nfunction fallbackContractConfig(key, value) {\n  if (value === void 0) {\n    return DEFAULT_CONFIG[key];\n  }\n  return value;\n}\n\nconst EVENT_ITERATOR_DETAILS_SYMBOL = Symbol(\"ORPC_EVENT_ITERATOR_DETAILS\");\nfunction eventIterator(yields, returns) {\n  return {\n    \"~standard\": {\n      [EVENT_ITERATOR_DETAILS_SYMBOL]: { yields, returns },\n      vendor: \"orpc\",\n      version: 1,\n      validate(iterator) {\n        if (!isAsyncIteratorObject(iterator)) {\n          return { issues: [{ message: \"Expect event iterator\", path: [] }] };\n        }\n        const mapped = mapEventIterator(iterator, {\n          async value(value, done) {\n            const schema = done ? returns : yields;\n            if (!schema) {\n              return value;\n            }\n            const result = await schema[\"~standard\"].validate(value);\n            if (result.issues) {\n              throw new ORPCError(\"EVENT_ITERATOR_VALIDATION_FAILED\", {\n                message: \"Event iterator validation failed\",\n                cause: new ValidationError({\n                  issues: result.issues,\n                  message: \"Event iterator validation failed\",\n                  data: value\n                })\n              });\n            }\n            return result.value;\n          },\n          error: async (error) => error\n        });\n        return { value: mapped };\n      }\n    }\n  };\n}\nfunction getEventIteratorSchemaDetails(schema) {\n  if (schema === void 0) {\n    return void 0;\n  }\n  return schema[\"~standard\"][EVENT_ITERATOR_DETAILS_SYMBOL];\n}\n\nfunction inferRPCMethodFromContractRouter(contract) {\n  return (_, path) => {\n    const procedure = get(contract, path);\n    if (!isContractProcedure(procedure)) {\n      throw new Error(\n        `[inferRPCMethodFromContractRouter] No valid procedure found at path \"${path.join(\".\")}\". This may happen when the contract router is not properly configured.`\n      );\n    }\n    const method = fallbackContractConfig(\"defaultMethod\", procedure[\"~orpc\"].route.method);\n    return method === \"HEAD\" ? \"GET\" : method;\n  };\n}\n\nfunction type(...[map]) {\n  return {\n    \"~standard\": {\n      vendor: \"custom\",\n      version: 1,\n      async validate(value) {\n        if (map) {\n          return { value: await map(value) };\n        }\n        return { value };\n      }\n    }\n  };\n}\n\nfunction isSchemaIssue(issue) {\n  if (!isTypescriptObject(issue) || typeof issue.message !== \"string\") {\n    return false;\n  }\n  if (issue.path !== void 0) {\n    if (!Array.isArray(issue.path)) {\n      return false;\n    }\n    if (!issue.path.every((segment) => isPropertyKey(segment) || isTypescriptObject(segment) && isPropertyKey(segment.key))) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { ContractBuilder, ContractProcedure, ValidationError, enhanceContractRouter, enhanceRoute, eventIterator, fallbackContractConfig, getContractRouter, getEventIteratorSchemaDetails, inferRPCMethodFromContractRouter, isContractProcedure, isSchemaIssue, mergeErrorMap, mergeMeta, mergePrefix, mergeRoute, mergeTags, minifyContractRouter, oc, populateContractRouterPaths, prefixRoute, type, unshiftTagRoute };\n","import { mergeErrorMap, mergeMeta, mergeRoute, mergePrefix, mergeTags, isContractProcedure, getContractRouter, fallbackContractConfig } from '@orpc/contract';\nexport { ValidationError, eventIterator, type, validateORPCError } from '@orpc/contract';\nimport { P as Procedure, b as addMiddleware, c as createProcedureClient, e as enhanceRouter, l as lazy, s as setHiddenRouterContract, u as unlazy, g as getRouter, i as isProcedure, d as isLazy, f as createAssertedLazyProcedure } from './shared/server.Ds4HPpvH.mjs';\nexport { L as LAZY_SYMBOL, p as call, r as createAccessibleLazyRouter, a as createContractedProcedure, h as createORPCErrorConstructorMap, q as getHiddenRouterContract, j as getLazyMeta, n as isStartWithMiddlewares, m as mergeCurrentContext, o as mergeMiddlewares, k as middlewareOutputFn, v as resolveContractProcedures, t as traverseContractProcedures, w as unlazyRouter } from './shared/server.Ds4HPpvH.mjs';\nimport { toORPCError } from '@orpc/client';\nexport { ORPCError, isDefinedError, safe } from '@orpc/client';\nimport { isObject, resolveMaybeOptionalOptions } from '@orpc/shared';\nexport { AsyncIteratorClass, EventPublisher, asyncIteratorToStream as eventIteratorToStream, asyncIteratorToUnproxiedDataStream as eventIteratorToUnproxiedDataStream, onError, onFinish, onStart, onSuccess, streamToAsyncIteratorClass as streamToEventIterator } from '@orpc/shared';\nexport { getEventMeta, withEventMeta } from '@orpc/standard-server';\n\nconst DEFAULT_CONFIG = {\n  initialInputValidationIndex: 0,\n  initialOutputValidationIndex: 0,\n  dedupeLeadingMiddlewares: true\n};\nfunction fallbackConfig(key, value) {\n  if (value === void 0) {\n    return DEFAULT_CONFIG[key];\n  }\n  return value;\n}\n\nfunction decorateMiddleware(middleware) {\n  const decorated = ((...args) => middleware(...args));\n  decorated.mapInput = (mapInput) => {\n    const mapped = decorateMiddleware(\n      (options, input, ...rest) => middleware(options, mapInput(input), ...rest)\n    );\n    return mapped;\n  };\n  decorated.concat = (concatMiddleware, mapInput) => {\n    const mapped = mapInput ? decorateMiddleware(concatMiddleware).mapInput(mapInput) : concatMiddleware;\n    const concatted = decorateMiddleware((options, input, output, ...rest) => {\n      const merged = middleware({\n        ...options,\n        next: (...[nextOptions1]) => mapped({\n          ...options,\n          context: { ...options.context, ...nextOptions1?.context },\n          next: (...[nextOptions2]) => options.next({ context: { ...nextOptions1?.context, ...nextOptions2?.context } })\n        }, input, output, ...rest)\n      }, input, output, ...rest);\n      return merged;\n    });\n    return concatted;\n  };\n  return decorated;\n}\n\nfunction createActionableClient(client) {\n  const action = async (input) => {\n    try {\n      return [null, await client(input)];\n    } catch (error) {\n      if (error instanceof Error && \"digest\" in error && typeof error.digest === \"string\" && error.digest.startsWith(\"NEXT_\")) {\n        throw error;\n      }\n      if (error instanceof Response && \"options\" in error && isObject(error.options) || isObject(error) && error.isNotFound === true) {\n        throw error;\n      }\n      return [toORPCError(error).toJSON(), void 0];\n    }\n  };\n  return action;\n}\n\nclass DecoratedProcedure extends Procedure {\n  /**\n   * Adds type-safe custom errors.\n   * The provided errors are spared-merged with any existing errors.\n   *\n   * @see {@link https://orpc.dev/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}\n   */\n  errors(errors) {\n    return new DecoratedProcedure({\n      ...this[\"~orpc\"],\n      errorMap: mergeErrorMap(this[\"~orpc\"].errorMap, errors)\n    });\n  }\n  /**\n   * Sets or updates the metadata.\n   * The provided metadata is spared-merged with any existing metadata.\n   *\n   * @see {@link https://orpc.dev/docs/metadata Metadata Docs}\n   */\n  meta(meta) {\n    return new DecoratedProcedure({\n      ...this[\"~orpc\"],\n      meta: mergeMeta(this[\"~orpc\"].meta, meta)\n    });\n  }\n  /**\n   * Sets or updates the route definition.\n   * The provided route is spared-merged with any existing route.\n   * This option is typically relevant when integrating with OpenAPI.\n   *\n   * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}\n   * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}\n   */\n  route(route) {\n    return new DecoratedProcedure({\n      ...this[\"~orpc\"],\n      route: mergeRoute(this[\"~orpc\"].route, route)\n    });\n  }\n  use(middleware, mapInput) {\n    const mapped = mapInput ? decorateMiddleware(middleware).mapInput(mapInput) : middleware;\n    return new DecoratedProcedure({\n      ...this[\"~orpc\"],\n      middlewares: addMiddleware(this[\"~orpc\"].middlewares, mapped)\n    });\n  }\n  /**\n   * Make this procedure callable (works like a function while still being a procedure).\n   *\n   * @see {@link https://orpc.dev/docs/client/server-side Server-side Client Docs}\n   */\n  callable(...rest) {\n    const client = createProcedureClient(this, ...rest);\n    return new Proxy(client, {\n      get: (target, key) => {\n        return Reflect.has(this, key) ? Reflect.get(this, key) : Reflect.get(target, key);\n      },\n      has: (target, key) => {\n        return Reflect.has(this, key) || Reflect.has(target, key);\n      }\n    });\n  }\n  /**\n   * Make this procedure compatible with server action.\n   *\n   * @see {@link https://orpc.dev/docs/server-action Server Action Docs}\n   */\n  actionable(...rest) {\n    const action = createActionableClient(createProcedureClient(this, ...rest));\n    return new Proxy(action, {\n      get: (target, key) => {\n        return Reflect.has(this, key) ? Reflect.get(this, key) : Reflect.get(target, key);\n      },\n      has: (target, key) => {\n        return Reflect.has(this, key) || Reflect.has(target, key);\n      }\n    });\n  }\n}\n\nclass Builder {\n  /**\n   * This property holds the defined options.\n   */\n  \"~orpc\";\n  constructor(def) {\n    this[\"~orpc\"] = def;\n  }\n  /**\n   * Sets or overrides the config.\n   *\n   * @see {@link https://orpc.dev/docs/client/server-side#middlewares-order Middlewares Order Docs}\n   * @see {@link https://orpc.dev/docs/best-practices/dedupe-middleware#configuration Dedupe Middleware Docs}\n   */\n  $config(config) {\n    const inputValidationCount = this[\"~orpc\"].inputValidationIndex - fallbackConfig(\"initialInputValidationIndex\", this[\"~orpc\"].config.initialInputValidationIndex);\n    const outputValidationCount = this[\"~orpc\"].outputValidationIndex - fallbackConfig(\"initialOutputValidationIndex\", this[\"~orpc\"].config.initialOutputValidationIndex);\n    return new Builder({\n      ...this[\"~orpc\"],\n      config,\n      dedupeLeadingMiddlewares: fallbackConfig(\"dedupeLeadingMiddlewares\", config.dedupeLeadingMiddlewares),\n      inputValidationIndex: fallbackConfig(\"initialInputValidationIndex\", config.initialInputValidationIndex) + inputValidationCount,\n      outputValidationIndex: fallbackConfig(\"initialOutputValidationIndex\", config.initialOutputValidationIndex) + outputValidationCount\n    });\n  }\n  /**\n   * Set or override the initial context.\n   *\n   * @see {@link https://orpc.dev/docs/context Context Docs}\n   */\n  $context() {\n    return new Builder({\n      ...this[\"~orpc\"],\n      middlewares: [],\n      inputValidationIndex: fallbackConfig(\"initialInputValidationIndex\", this[\"~orpc\"].config.initialInputValidationIndex),\n      outputValidationIndex: fallbackConfig(\"initialOutputValidationIndex\", this[\"~orpc\"].config.initialOutputValidationIndex)\n    });\n  }\n  /**\n   * Sets or overrides the initial meta.\n   *\n   * @see {@link https://orpc.dev/docs/metadata Metadata Docs}\n   */\n  $meta(initialMeta) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      meta: initialMeta\n    });\n  }\n  /**\n   * Sets or overrides the initial route.\n   * This option is typically relevant when integrating with OpenAPI.\n   *\n   * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}\n   * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}\n   */\n  $route(initialRoute) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      route: initialRoute\n    });\n  }\n  /**\n   * Sets or overrides the initial input schema.\n   *\n   * @see {@link https://orpc.dev/docs/procedure#initial-configuration Initial Procedure Configuration Docs}\n   */\n  $input(initialInputSchema) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      inputSchema: initialInputSchema\n    });\n  }\n  /**\n   * Creates a middleware.\n   *\n   * @see {@link https://orpc.dev/docs/middleware Middleware Docs}\n   */\n  middleware(middleware) {\n    return decorateMiddleware(middleware);\n  }\n  /**\n   * Adds type-safe custom errors.\n   * The provided errors are spared-merged with any existing errors.\n   *\n   * @see {@link https://orpc.dev/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}\n   */\n  errors(errors) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      errorMap: mergeErrorMap(this[\"~orpc\"].errorMap, errors)\n    });\n  }\n  use(middleware, mapInput) {\n    const mapped = mapInput ? decorateMiddleware(middleware).mapInput(mapInput) : middleware;\n    return new Builder({\n      ...this[\"~orpc\"],\n      middlewares: addMiddleware(this[\"~orpc\"].middlewares, mapped)\n    });\n  }\n  /**\n   * Sets or updates the metadata.\n   * The provided metadata is spared-merged with any existing metadata.\n   *\n   * @see {@link https://orpc.dev/docs/metadata Metadata Docs}\n   */\n  meta(meta) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      meta: mergeMeta(this[\"~orpc\"].meta, meta)\n    });\n  }\n  /**\n   * Sets or updates the route definition.\n   * The provided route is spared-merged with any existing route.\n   * This option is typically relevant when integrating with OpenAPI.\n   *\n   * @see {@link https://orpc.dev/docs/openapi/routing OpenAPI Routing Docs}\n   * @see {@link https://orpc.dev/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}\n   */\n  route(route) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      route: mergeRoute(this[\"~orpc\"].route, route)\n    });\n  }\n  /**\n   * Defines the input validation schema.\n   *\n   * @see {@link https://orpc.dev/docs/procedure#input-output-validation Input Validation Docs}\n   */\n  input(schema) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      inputSchema: schema,\n      inputValidationIndex: fallbackConfig(\"initialInputValidationIndex\", this[\"~orpc\"].config.initialInputValidationIndex) + this[\"~orpc\"].middlewares.length\n    });\n  }\n  /**\n   * Defines the output validation schema.\n   *\n   * @see {@link https://orpc.dev/docs/procedure#input-output-validation Output Validation Docs}\n   */\n  output(schema) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      outputSchema: schema,\n      outputValidationIndex: fallbackConfig(\"initialOutputValidationIndex\", this[\"~orpc\"].config.initialOutputValidationIndex) + this[\"~orpc\"].middlewares.length\n    });\n  }\n  /**\n   * Defines the handler of the procedure.\n   *\n   * @see {@link https://orpc.dev/docs/procedure Procedure Docs}\n   */\n  handler(handler) {\n    return new DecoratedProcedure({\n      ...this[\"~orpc\"],\n      handler\n    });\n  }\n  /**\n   * Prefixes all procedures in the router.\n   * The provided prefix is post-appended to any existing router prefix.\n   *\n   * @note This option does not affect procedures that do not define a path in their route definition.\n   *\n   * @see {@link https://orpc.dev/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}\n   */\n  prefix(prefix) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      prefix: mergePrefix(this[\"~orpc\"].prefix, prefix)\n    });\n  }\n  /**\n   * Adds tags to all procedures in the router.\n   * This helpful when you want to group procedures together in the OpenAPI specification.\n   *\n   * @see {@link https://orpc.dev/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}\n   */\n  tag(...tags) {\n    return new Builder({\n      ...this[\"~orpc\"],\n      tags: mergeTags(this[\"~orpc\"].tags, tags)\n    });\n  }\n  /**\n   * Applies all of the previously defined options to the specified router.\n   *\n   * @see {@link https://orpc.dev/docs/router#extending-router Extending Router Docs}\n   */\n  router(router) {\n    return enhanceRouter(router, this[\"~orpc\"]);\n  }\n  /**\n   * Create a lazy router\n   * And applies all of the previously defined options to the specified router.\n   *\n   * @see {@link https://orpc.dev/docs/router#extending-router Extending Router Docs}\n   */\n  lazy(loader) {\n    return enhanceRouter(lazy(loader), this[\"~orpc\"]);\n  }\n}\nconst os = new Builder({\n  config: {},\n  route: {},\n  meta: {},\n  errorMap: {},\n  inputValidationIndex: fallbackConfig(\"initialInputValidationIndex\"),\n  outputValidationIndex: fallbackConfig(\"initialOutputValidationIndex\"),\n  middlewares: [],\n  dedupeLeadingMiddlewares: true\n});\n\nfunction implementerInternal(contract, config, middlewares) {\n  if (isContractProcedure(contract)) {\n    const impl2 = new Builder({\n      ...contract[\"~orpc\"],\n      config,\n      middlewares,\n      inputValidationIndex: fallbackConfig(\"initialInputValidationIndex\", config?.initialInputValidationIndex) + middlewares.length,\n      outputValidationIndex: fallbackConfig(\"initialOutputValidationIndex\", config?.initialOutputValidationIndex) + middlewares.length,\n      dedupeLeadingMiddlewares: fallbackConfig(\"dedupeLeadingMiddlewares\", config.dedupeLeadingMiddlewares)\n    });\n    return impl2;\n  }\n  const impl = new Proxy(contract, {\n    get: (target, key) => {\n      if (typeof key !== \"string\") {\n        return Reflect.get(target, key);\n      }\n      let method;\n      if (key === \"middleware\") {\n        method = (mid) => decorateMiddleware(mid);\n      } else if (key === \"use\") {\n        method = (mid) => {\n          return implementerInternal(\n            contract,\n            config,\n            addMiddleware(middlewares, mid)\n          );\n        };\n      } else if (key === \"router\") {\n        method = (router) => {\n          const adapted = enhanceRouter(router, {\n            middlewares,\n            errorMap: {},\n            prefix: void 0,\n            tags: void 0,\n            dedupeLeadingMiddlewares: fallbackConfig(\"dedupeLeadingMiddlewares\", config.dedupeLeadingMiddlewares)\n          });\n          return setHiddenRouterContract(adapted, contract);\n        };\n      } else if (key === \"lazy\") {\n        method = (loader) => {\n          const adapted = enhanceRouter(lazy(loader), {\n            middlewares,\n            errorMap: {},\n            prefix: void 0,\n            tags: void 0,\n            dedupeLeadingMiddlewares: fallbackConfig(\"dedupeLeadingMiddlewares\", config.dedupeLeadingMiddlewares)\n          });\n          return setHiddenRouterContract(adapted, contract);\n        };\n      }\n      const next = getContractRouter(target, [key]);\n      if (!next) {\n        return method ?? next;\n      }\n      const nextImpl = implementerInternal(next, config, middlewares);\n      if (method) {\n        return new Proxy(method, {\n          get(_, key2) {\n            return Reflect.get(nextImpl, key2);\n          }\n        });\n      }\n      return nextImpl;\n    }\n  });\n  return impl;\n}\nfunction implement(contract, config = {}) {\n  const implInternal = implementerInternal(contract, config, []);\n  const impl = new Proxy(implInternal, {\n    get: (target, key) => {\n      let method;\n      if (key === \"$context\") {\n        method = () => impl;\n      } else if (key === \"$config\") {\n        method = (config2) => implement(contract, config2);\n      }\n      const next = Reflect.get(target, key);\n      if (!method || !next || typeof next !== \"function\" && typeof next !== \"object\") {\n        return method || next;\n      }\n      return new Proxy(method, {\n        get(_, key2) {\n          return Reflect.get(next, key2);\n        }\n      });\n    }\n  });\n  return impl;\n}\n\nfunction inferRPCMethodFromRouter(router) {\n  return async (_, path) => {\n    const { default: procedure } = await unlazy(getRouter(router, path));\n    if (!isProcedure(procedure)) {\n      throw new Error(\n        `[inferRPCMethodFromRouter] No valid procedure found at path \"${path.join(\".\")}\". This may happen when the router is not properly configured.`\n      );\n    }\n    const method = fallbackContractConfig(\"defaultMethod\", procedure[\"~orpc\"].route.method);\n    return method === \"HEAD\" ? \"GET\" : method;\n  };\n}\n\nfunction createRouterClient(router, ...rest) {\n  const options = resolveMaybeOptionalOptions(rest);\n  if (isProcedure(router)) {\n    const caller = createProcedureClient(router, options);\n    return caller;\n  }\n  const procedureCaller = isLazy(router) ? createProcedureClient(createAssertedLazyProcedure(router), options) : {};\n  const recursive = new Proxy(procedureCaller, {\n    get(target, key) {\n      if (typeof key !== \"string\") {\n        return Reflect.get(target, key);\n      }\n      const next = getRouter(router, [key]);\n      if (!next) {\n        return Reflect.get(target, key);\n      }\n      return createRouterClient(next, {\n        ...rest[0],\n        path: [...rest[0]?.path ?? [], key]\n      });\n    }\n  });\n  return recursive;\n}\n\nexport { Builder, DecoratedProcedure, Procedure, addMiddleware, createActionableClient, createAssertedLazyProcedure, createProcedureClient, createRouterClient, decorateMiddleware, enhanceRouter, fallbackConfig, getRouter, implement, implementerInternal, inferRPCMethodFromRouter, isLazy, isProcedure, lazy, os, setHiddenRouterContract, unlazy };\n","import { ORPCError } from '@orpc/client';\nimport { toArray, intercept, resolveMaybeOptionalOptions } from '@orpc/shared';\nimport { toStandardLazyRequest, toFetchResponse } from '@orpc/standard-server-fetch';\nimport { r as resolveFriendlyStandardHandleOptions } from '../../shared/server.DZ5BIITo.mjs';\nimport '@orpc/standard-server';\nimport '@orpc/contract';\nimport { C as CompositeStandardHandlerPlugin, b as StandardRPCHandler } from '../../shared/server.Bxx6tqNe.mjs';\nimport '@orpc/client/standard';\nimport '@orpc/standard-server/batch';\nimport { S as StrictGetMethodPlugin } from '../../shared/server.TEVCLCFC.mjs';\nimport '../../shared/server.Ds4HPpvH.mjs';\n\nclass BodyLimitPlugin {\n  maxBodySize;\n  constructor(options) {\n    this.maxBodySize = options.maxBodySize;\n  }\n  initRuntimeAdapter(options) {\n    options.adapterInterceptors ??= [];\n    options.adapterInterceptors.push(async (options2) => {\n      if (!options2.request.body) {\n        return options2.next();\n      }\n      let currentBodySize = 0;\n      const rawReader = options2.request.body.getReader();\n      const reader = new ReadableStream({\n        start: async (controller) => {\n          try {\n            if (Number(options2.request.headers.get(\"content-length\")) > this.maxBodySize) {\n              controller.error(new ORPCError(\"PAYLOAD_TOO_LARGE\"));\n              return;\n            }\n            while (true) {\n              const { done, value } = await rawReader.read();\n              if (done) {\n                break;\n              }\n              currentBodySize += value.length;\n              if (currentBodySize > this.maxBodySize) {\n                controller.error(new ORPCError(\"PAYLOAD_TOO_LARGE\"));\n                break;\n              }\n              controller.enqueue(value);\n            }\n          } finally {\n            controller.close();\n          }\n        }\n      });\n      const requestInit = { body: reader, duplex: \"half\" };\n      return options2.next({\n        ...options2,\n        request: new Request(options2.request, requestInit)\n      });\n    });\n  }\n}\n\nconst ORDERED_SUPPORTED_ENCODINGS = [\"gzip\", \"deflate\"];\nclass CompressionPlugin {\n  encodings;\n  threshold;\n  filter;\n  constructor(options = {}) {\n    this.encodings = options.encodings ?? ORDERED_SUPPORTED_ENCODINGS;\n    this.threshold = options.threshold ?? 1024;\n    this.filter = (request, response) => {\n      const hasContentDisposition = response.headers.has(\"content-disposition\");\n      const contentType = response.headers.get(\"content-type\");\n      if (!hasContentDisposition && contentType?.startsWith(\"text/event-stream\")) {\n        return false;\n      }\n      return options.filter ? options.filter(request, response) : isCompressibleContentType(contentType);\n    };\n  }\n  initRuntimeAdapter(options) {\n    options.adapterInterceptors ??= [];\n    options.adapterInterceptors.unshift(async (options2) => {\n      const result = await options2.next();\n      if (!result.matched) {\n        return result;\n      }\n      const response = result.response;\n      if (response.headers.has(\"content-encoding\") || response.headers.has(\"transfer-encoding\") || isNoTransformCacheControl(response.headers.get(\"cache-control\"))) {\n        return result;\n      }\n      const contentLength = response.headers.get(\"content-length\");\n      if (contentLength && Number(contentLength) < this.threshold) {\n        return result;\n      }\n      const acceptEncoding = options2.request.headers.get(\"accept-encoding\")?.split(\",\").map((enc) => enc.trim().split(\";\")[0]);\n      const encoding = this.encodings.find((enc) => acceptEncoding?.includes(enc));\n      if (!response.body || encoding === void 0) {\n        return result;\n      }\n      if (!this.filter(options2.request, response)) {\n        return result;\n      }\n      const compressedBody = response.body.pipeThrough(new CompressionStream(encoding));\n      const compressedHeaders = new Headers(response.headers);\n      compressedHeaders.delete(\"content-length\");\n      compressedHeaders.set(\"content-encoding\", encoding);\n      return {\n        ...result,\n        response: new Response(compressedBody, {\n          status: response.status,\n          statusText: response.statusText,\n          headers: compressedHeaders\n        })\n      };\n    });\n  }\n}\nconst COMPRESSIBLE_CONTENT_TYPE_REGEX = /^\\s*(?:text\\/(?!event-stream(?:[;\\s]|$))[^;\\s]+|application\\/(?:javascript|json|xml|xml-dtd|ecmascript|dart|postscript|rtf|tar|toml|vnd\\.dart|vnd\\.ms-fontobject|vnd\\.ms-opentype|wasm|x-httpd-php|x-javascript|x-ns-proxy-autoconfig|x-sh|x-tar|x-virtualbox-hdd|x-virtualbox-ova|x-virtualbox-ovf|x-virtualbox-vbox|x-virtualbox-vdi|x-virtualbox-vhd|x-virtualbox-vmdk|x-www-form-urlencoded)|font\\/(?:otf|ttf)|image\\/(?:bmp|vnd\\.adobe\\.photoshop|vnd\\.microsoft\\.icon|vnd\\.ms-dds|x-icon|x-ms-bmp)|message\\/rfc822|model\\/gltf-binary|x-shader\\/x-fragment|x-shader\\/x-vertex|[^;\\s]+?\\+(?:json|text|xml|yaml))(?:[;\\s]|$)/i;\nfunction isCompressibleContentType(contentType) {\n  if (contentType === null) {\n    return false;\n  }\n  return COMPRESSIBLE_CONTENT_TYPE_REGEX.test(contentType);\n}\nconst CACHE_CONTROL_NO_TRANSFORM_REGEX = /(?:^|,)\\s*no-transform\\s*(?:,|$)/i;\nfunction isNoTransformCacheControl(cacheControl) {\n  if (cacheControl === null) {\n    return false;\n  }\n  return CACHE_CONTROL_NO_TRANSFORM_REGEX.test(cacheControl);\n}\n\nclass CompositeFetchHandlerPlugin extends CompositeStandardHandlerPlugin {\n  initRuntimeAdapter(options) {\n    for (const plugin of this.plugins) {\n      plugin.initRuntimeAdapter?.(options);\n    }\n  }\n}\n\nclass FetchHandler {\n  constructor(standardHandler, options = {}) {\n    this.standardHandler = standardHandler;\n    const plugin = new CompositeFetchHandlerPlugin(options.plugins);\n    plugin.initRuntimeAdapter(options);\n    this.adapterInterceptors = toArray(options.adapterInterceptors);\n    this.toFetchResponseOptions = options;\n  }\n  toFetchResponseOptions;\n  adapterInterceptors;\n  async handle(request, ...rest) {\n    return intercept(\n      this.adapterInterceptors,\n      {\n        ...resolveFriendlyStandardHandleOptions(resolveMaybeOptionalOptions(rest)),\n        request,\n        toFetchResponseOptions: this.toFetchResponseOptions\n      },\n      async ({ request: request2, toFetchResponseOptions, ...options }) => {\n        const standardRequest = toStandardLazyRequest(request2);\n        const result = await this.standardHandler.handle(standardRequest, options);\n        if (!result.matched) {\n          return result;\n        }\n        return {\n          matched: true,\n          response: toFetchResponse(result.response, toFetchResponseOptions)\n        };\n      }\n    );\n  }\n}\n\nclass RPCHandler extends FetchHandler {\n  constructor(router, options = {}) {\n    if (options.strictGetMethodPluginEnabled ?? true) {\n      options.plugins ??= [];\n      options.plugins.push(new StrictGetMethodPlugin());\n    }\n    super(new StandardRPCHandler(router, options), options);\n  }\n}\n\nexport { BodyLimitPlugin, CompositeFetchHandlerPlugin, CompressionPlugin, FetchHandler, RPCHandler };\n"],"names":[],"mappings":"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","ignoreList":[1,2,4,5,6,7,8,9,10,11,14,15,16,18,20,21,22]}